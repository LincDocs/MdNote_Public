# WebæœåŠ¡å™¨-å¤šçº¿ç¨‹

## å¤šçº¿ç¨‹ç‰ˆæœ¬

### ä¸ºä»€ä¹ˆéœ€è¦å¤šçº¿ç¨‹

ç›®å‰çš„å•çº¿ç¨‹ç‰ˆæœ¬åªèƒ½ä¾æ¬¡å¤„ç†ç”¨æˆ·çš„è¯·æ±‚ï¼šä¸€æ—¶é—´åªèƒ½å¤„ç†ä¸€ä¸ªè¯·æ±‚è¿æ¥ã€‚éšç€ç”¨æˆ·çš„è¯·æ±‚æ•°å¢å¤šï¼Œå¯ä»¥é¢„æ–™çš„æ˜¯æ’åœ¨åé¢çš„ç”¨æˆ·å¯èƒ½è¦ç­‰å¾…æ•°åç§’ç”šè‡³è¶…æ—¶ï¼

æœ¬ç« æˆ‘ä»¬å°†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä½†æ˜¯é¦–å…ˆæ¥æ¨¡æ‹Ÿä¸€ä¸ªæ…¢è¯·æ±‚åœºæ™¯ï¼Œçœ‹çœ‹å•çº¿ç¨‹æ˜¯å¦çœŸçš„å¦‚æ­¤ç³Ÿç³•ã€‚

### åŸºäºå•çº¿ç¨‹æ¨¡æ‹Ÿæ…¢è¯·æ±‚

ä¸‹é¢çš„ä»£ç ä¸­ï¼Œä½¿ç”¨ sleep çš„æ–¹å¼è®©æ¯æ¬¡è¯·æ±‚æŒç»­ 5 ç§’ï¼Œæ¨¡æ‹ŸçœŸå®çš„æ…¢è¯·æ±‚:

```rust
// in main.rs
use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
    thread,
    time::Duration,
};
// --snip--

fn handle_connection(mut stream: TcpStream) {
    // --snip--

    // ä¹‹å‰çš„ `if else` è¢«ä¿®æ”¹ä¸º `match`ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œç”±äº `match` ä¸ä¼šåƒæ–¹æ³•é‚£æ ·è‡ªåŠ¨åšå¼•ç”¨æˆ–è€…è§£å¼•ç”¨ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦æ˜¾å¼è°ƒç”¨: `match &request_line[..]` ï¼Œæ¥è·å–æ‰€éœ€çš„ `&str` ç±»å‹ã€‚
    let (status_line, filename) = match &request_line[..] {
        // `/` è·¯å¾„
        "GET / HTTP/1.1" => ("HTTP/1.1 200 OK", "hello.html"),

        // `/sleep` è·¯å¾„
        "GET /sleep HTTP/1.1" => {
            thread::sleep(Duration::from_secs(5)); // ç­‰å¾…5s
            ("HTTP/1.1 200 OK", "hello.html")
        }
        _ => ("HTTP/1.1 404 NOT FOUND", "404.html"),
    };

    // --snip--
}
```

ä¸‹é¢æ¥è¯•è¯•ï¼Œå¯åŠ¨æœåŠ¡å™¨åï¼Œæ‰“å¼€ä½ çš„æµè§ˆå™¨ï¼Œè¿™æ¬¡è¦åˆ†åˆ«æ‰“å¼€ä¸¤ä¸ªé¡µé¢(tabé¡µ): `http://127.0.0.1:7878/` å’Œ `http://127.0.0.1:7878/sleep`ã€‚æ­¤æ—¶:

- å¦‚æœæˆ‘ä»¬è¿ç»­è®¿é—® `/` è·¯å¾„ï¼Œé‚£æ•ˆæœè·Ÿä¹‹å‰ä¸€æ ·ï¼šç«‹åˆ»çœ‹åˆ°è¯·æ±‚çš„é¡µé¢ã€‚
- å‡å¦‚å…ˆè®¿é—® `/sleep` ï¼Œæ¥ç€åœ¨*å¦ä¸€ä¸ªé¡µé¢*è®¿é—® `/`ï¼Œå°±ä¼šçœ‹åˆ° `/` çš„é¡µé¢ç›´åˆ° 5 ç§’åæ‰ä¼šåˆ·å‡ºæ¥ï¼ŒéªŒè¯äº†è¯·æ±‚æ’é˜Ÿè¿™ä¸ªç³Ÿç³•çš„äº‹å®ã€‚

è‡³äºå¦‚ä½•è§£å†³ï¼Œå…¶å®åŠæ³•ä¸å°‘ï¼Œæœ¬ç« æˆ‘ä»¬æ¥çœ‹çœ‹ä¸€ä¸ªç»å…¸è§£å†³æ–¹æ¡ˆï¼šçº¿ç¨‹æ± ã€‚

## ä½¿ç”¨çº¿ç¨‹æ± æ”¹å–„åå

### ä»€ä¹ˆæ˜¯çº¿ç¨‹æ± 

çº¿ç¨‹æ± åŒ…å«ä¸€ç»„å·²ç”Ÿæˆçš„çº¿ç¨‹ï¼Œå®ƒä»¬æ—¶åˆ»ç­‰å¾…ç€æ¥æ”¶å¹¶å¤„ç†æ–°çš„ä»»åŠ¡ã€‚å½“ç¨‹åºæ¥æ”¶åˆ°æ–°ä»»åŠ¡æ—¶ï¼Œå®ƒä¼šå°†çº¿ç¨‹æ± ä¸­çš„ä¸€ä¸ªçº¿ç¨‹æŒ‡æ´¾ç»™è¯¥ä»»åŠ¡ï¼Œåœ¨è¯¥çº¿ç¨‹å¿™ç€å¤„ç†æ—¶ï¼Œæ–°æ¥çš„ä»»åŠ¡ä¼šäº¤ç»™æ± ä¸­å‰©ä½™çš„çº¿ç¨‹è¿›è¡Œå¤„ç†ã€‚æœ€ç»ˆï¼Œå½“æ‰§è¡Œä»»åŠ¡çš„çº¿ç¨‹å¤„ç†å®Œåï¼Œå®ƒä¼šè¢«é‡æ–°æ”¾å…¥åˆ°çº¿ç¨‹æ± ä¸­ï¼Œå‡†å¤‡å¤„ç†æ–°ä»»åŠ¡ã€‚

å‡è®¾çº¿ç¨‹æ± ä¸­åŒ…å« N ä¸ªçº¿ç¨‹ï¼Œé‚£ä¹ˆå¯ä»¥æ¨æ–­å‡ºï¼ŒæœåŠ¡å™¨å°†æ‹¥æœ‰å¹¶å‘å¤„ç† N ä¸ªè¯·æ±‚è¿æ¥çš„èƒ½åŠ›ï¼Œä»è€Œå¢åŠ æœåŠ¡å™¨çš„ååé‡ã€‚

åŒæ—¶ï¼Œæˆ‘ä»¬å°†*é™åˆ¶çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹æ•°é‡*ï¼Œä»¥ä¿æŠ¤æœåŠ¡å™¨å…å—æ‹’ç»æœåŠ¡æ”»å‡»ï¼ˆDoSï¼‰çš„å½±å“ï¼šå¦‚æœé’ˆå¯¹æ¯ä¸ªè¯·æ±‚åˆ›å»ºä¸€ä¸ªæ–°çº¿ç¨‹ï¼Œé‚£ä¹ˆä¸€ä¸ªäººå‘æˆ‘ä»¬çš„æœåŠ¡å™¨å‘å‡º1000ä¸‡ä¸ªè¯·æ±‚ï¼Œä¼šç›´æ¥è€—å°½èµ„æºï¼Œå¯¼è‡´åç»­ç”¨æˆ·çš„è¯·æ±‚æ— æ³•è¢«å¤„ç†ï¼Œè¿™ä¹Ÿæ˜¯æ‹’ç»æœåŠ¡åç§°çš„æ¥æºã€‚

å› æ­¤ï¼Œè¿˜éœ€å¯¹çº¿ç¨‹æ± è¿›è¡Œä¸€å®šçš„æ¶æ„è®¾è®¡ï¼Œé¦–å…ˆæ˜¯è®¾å®šæœ€å¤§çº¿ç¨‹æ•°çš„ä¸Šé™ï¼Œå…¶æ¬¡ç»´æŠ¤ä¸€ä¸ªè¯·æ±‚é˜Ÿåˆ—ã€‚æ± ä¸­çš„çº¿ç¨‹å»é˜Ÿåˆ—ä¸­ä¾æ¬¡å¼¹å‡ºè¯·æ±‚å¹¶å¤„ç†ã€‚è¿™æ ·å°±å¯ä»¥åŒæ—¶å¹¶å‘å¤„ç† N ä¸ªè¯·æ±‚ï¼Œå…¶ä¸­ N æ˜¯çº¿ç¨‹æ•°ã€‚

ä½†èªæ˜çš„è¯»è€…å¯èƒ½ä¼šæƒ³åˆ°ï¼Œå‡å¦‚æ¯ä¸ªè¯·æ±‚ä¾ç„¶è€—æ—¶å¾ˆé•¿ï¼Œé‚£è¯·æ±‚é˜Ÿåˆ—ä¾ç„¶ä¼šå †ç§¯ï¼Œåç»­çš„ç”¨æˆ·è¯·æ±‚è¿˜æ˜¯éœ€è¦ç­‰å¾…è¾ƒé•¿çš„æ—¶é—´ï¼Œæ¯•ç«Ÿä½ ä¹Ÿå°± N ä¸ªçº¿ç¨‹ï¼Œä½†æ€»å½’æ¯”å•çº¿ç¨‹è¦å¼º N å€å§ ğŸ˜„

å½“ç„¶ï¼Œçº¿ç¨‹æ± ä¾ç„¶æ˜¯è¾ƒä¸ºä¼ ç»Ÿçš„æå‡ååæ–¹æ³•ï¼Œæ¯”è¾ƒæ–°çš„æœ‰ï¼š

- **å•çº¿ç¨‹å¼‚æ­¥ IO**ï¼Œä¾‹å¦‚ redisï¼›
- **å¤šçº¿ç¨‹å¼‚æ­¥ IO**ï¼Œä¾‹å¦‚ Rust çš„ä¸»æµ web æ¡†æ¶ã€‚

äº‹å®ä¸Šï¼Œå¤§å®¶åœ¨ä¸‹ä¸€ä¸ªå®æˆ˜é¡¹ç›®ä¸­ï¼Œä¼šçœ‹åˆ°ç›¸å…³æŠ€æœ¯çš„åº”ç”¨ã€‚

### (1) ä¸ºæ¯ä¸ªè¯·æ±‚ç”Ÿæˆä¸€ä¸ªçº¿ç¨‹

```rust
fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| { // åˆ›å»ºæ–°çº¿ç¨‹
            handle_connection(stream);
        });
    }
}
```

è¿™æ˜¾ç„¶ä¸æ˜¯æˆ‘ä»¬çš„æœ€ç»ˆæ–¹æ¡ˆï¼ŒåŸå› åœ¨äºå®ƒä¼šç”Ÿæˆæ— ä¸Šé™çš„çº¿ç¨‹æ•°ï¼Œæœ€ç»ˆå¯¼è‡´èµ„æºè€—å°½ã€‚ä½†å®ƒç¡®å®æ˜¯ä¸€ä¸ªå¥½çš„èµ·ç‚¹

è¿™ç§å®ç°ä¸‹ï¼Œä¾æ¬¡è®¿é—® `/sleep` å’Œ `/` å°±æ— éœ€å†ç­‰å¾…ï¼Œä¸é”™çš„å¼€å§‹ã€‚

### (2) é™åˆ¶åˆ›å»ºçº¿ç¨‹çš„æ•°é‡

```rust
fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4); // çº¿ç¨‹æ± 

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}
```

åŸåˆ™ä¸Šï¼Œæˆ‘ä»¬å¸Œæœ›åœ¨ä¸Šé¢ä»£ç çš„åŸºç¡€ä¸Šï¼Œå°½é‡å°‘çš„å»ä¿®æ”¹ï¼Œä¸Šé¢æ˜¯ä¸€ä¸ªå‡æƒ³çš„çº¿ç¨‹æ±  API å®ç°

ä»£ç è·Ÿä¹‹å‰çš„ç±»ä¼¼ï¼Œä¹Ÿéå¸¸ç®€æ´æ˜äº†ï¼Œ `ThreadPool::new(4)` åˆ›å»ºä¸€ä¸ªåŒ…å« 4 ä¸ªçº¿ç¨‹çš„çº¿ç¨‹æ± ï¼Œæ¥ç€é€šè¿‡ `pool.execute` å»åˆ†å‘æ‰§è¡Œè¯·æ±‚ã€‚

æ˜¾ç„¶ï¼Œä¸Šé¢çš„ä»£ç æ— æ³•ç¼–è¯‘ï¼Œä¸‹é¢æ¥é€æ­¥å®ç°ã€‚

### ä½¿ç”¨ç¼–è¯‘å™¨é©±åŠ¨çš„æ–¹å¼å¼€å‘ ThreadPool

ä½ å¯èƒ½å¬è¯´è¿‡æµ‹è¯•é©±åŠ¨å¼€å‘ï¼Œä½†å¬è¿‡ç¼–è¯‘å™¨é©±åŠ¨å¼€å‘å—ï¼Ÿæ¥è§è¯†ä¸‹ Rust ä¸­çš„ç»æ‹›å§ã€‚

æ£€æŸ¥ä¹‹å‰çš„ä»£ç ï¼Œçœ‹çœ‹æŠ¥ä»€ä¹ˆé”™:

```bash
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0433]: failed to resolve: use of undeclared type `ThreadPool`
  --> src/main.rs:11:16
   |
11 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^ use of undeclared type `ThreadPool`

For more information about this error, try `rustc --explain E0433`.
error: could not compile `hello` due to previous error
```

ä¿—è¯è¯´ï¼Œä¸æ€•æ•Œäººå¾ˆå¼ºï¼Œå°±æ€•ä»–ä»¬ä¸çŠ¯é”™ï¼Œå¾ˆå¥½ï¼Œç¼–è¯‘å™¨æ¼å‡ºäº†ç ´ç»½ã€‚çœ‹èµ·æ¥æˆ‘ä»¬éœ€è¦å®ç° `ThreadPool` ç±»å‹ã€‚çœ‹èµ·æ¥ï¼Œè¿˜éœ€è¦æ·»åŠ ä¸€ä¸ªåº“åŒ…ï¼Œæœªæ¥çº¿ç¨‹æ± çš„ä»£ç éƒ½å°†åœ¨è¿™ä¸ªç‹¬ç«‹çš„åŒ…ä¸­å®Œæˆï¼Œç”šè‡³äºæœªæ¥ä½ è¦å®ç°å…¶å®ƒçš„æœåŠ¡ï¼Œä¹Ÿå¯ä»¥å¤ç”¨è¿™ä¸ªå¤šçº¿ç¨‹åº“åŒ…ã€‚

åˆ›å»º `src/lib.rs` æ–‡ä»¶å¹¶å†™å…¥å¦‚ä¸‹ä»£ç :

```rust
pub struct ThreadPool;
```

æ¥ç€åœ¨ `main.rs` ä¸­å¼•å…¥:

```rust
// main.rs
use hello::ThreadPool;
```

ç¼–è¯‘åä¾ç„¶æŠ¥é”™:

```bash
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no function or associated item named `new` found for struct `ThreadPool` in the current scope
  --> src/main.rs:12:28
   |
12 |     let pool = ThreadPool::new(4);
   |                            ^^^ function or associated item not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` due to previous error
```

å¥½ï¼Œç»§ç»­å®ç° `new` å‡½æ•° :

```rust
pub struct ThreadPool;

impl ThreadPool {
    pub fn new(size: usize) -> ThreadPool {
        ThreadPool
    }
}
```

ç»§ç»­æ£€æŸ¥ï¼š

```bash
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no method named `execute` found for struct `ThreadPool` in the current scope
  --> src/main.rs:17:14
   |
17 |         pool.execute(|| {
   |              ^^^^^^^ method not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` due to previous error
```

è¿™ä¸ªæ–¹æ³•ç±»ä¼¼äº `thread::spawn`ï¼Œç”¨äºå°†é—­åŒ…ä¸­çš„ä»»åŠ¡äº¤ç»™æŸä¸ªç©ºé—²çš„çº¿ç¨‹å»æ‰§è¡Œã€‚

å…¶å®è¿™é‡Œæœ‰ä¸€ä¸ªå°éš¾ç‚¹ï¼š`execute` çš„å‚æ•°æ˜¯ä¸€ä¸ªé—­åŒ…ï¼Œå›å¿†ä¸‹ä¹‹å‰å­¦è¿‡çš„å†…å®¹ï¼Œé—­åŒ…ä½œä¸ºå‚æ•°æ—¶å¯ä»¥ç”±ä¸‰ä¸ªç‰¹å¾è¿›è¡Œçº¦æŸ: `Fn`ã€`FnMut` å’Œ `FnOnce`ï¼Œé€‰å“ªä¸ªå°±æˆä¸ºä¸€ä¸ªé—®é¢˜ã€‚ç”±äº `execute` åœ¨å®ç°ä¸Šç±»ä¼¼ `thread::spawn`ï¼Œæˆ‘ä»¬å¯ä»¥å‚è€ƒä¸‹åè€…çš„ç­¾åå¦‚ä½•å£°æ˜ã€‚

```rust
pub fn spawn<F, T>(f: F) -> JoinHandle<T>
    where
        F: FnOnce() -> T,
        F: Send + 'static,
        T: Send + 'static,
```

å¯ä»¥çœ‹å‡ºï¼Œ`spawn` é€‰æ‹© `FnOnce` ä½œä¸º `F` é—­åŒ…çš„ç‰¹å¾çº¦æŸï¼ŒåŸå› æ˜¯é—­åŒ…ä½œä¸ºä»»åŠ¡åªéœ€è¢«çº¿ç¨‹æ‰§è¡Œä¸€æ¬¡å³å¯ã€‚

`F` è¿˜æœ‰ä¸€ä¸ªç‰¹å¾çº¦æŸ `Send` ï¼Œä¹Ÿå¯ä»¥ç…§æŠ„è¿‡æ¥ï¼Œæ¯•ç«Ÿé—­åŒ…éœ€è¦ä»ä¸€ä¸ªçº¿ç¨‹ä¼ é€’åˆ°å¦ä¸€ä¸ªçº¿ç¨‹ï¼Œè‡³äºç”Ÿå‘½å‘¨æœŸçº¦æŸ `'static`ï¼Œæ˜¯å› ä¸ºæˆ‘ä»¬å¹¶ä¸çŸ¥é“çº¿ç¨‹éœ€è¦å¤šä¹…æ—¶é—´æ¥æ‰§è¡Œè¯¥ä»»åŠ¡ã€‚

```rust
impl ThreadPool {
    // --snip--
    pub fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
    }
}
```

åœ¨ç†è§£ `spawn` åï¼Œå°±å¯ä»¥è½»æ¾å†™å‡ºå¦‚ä¸Šçš„ `execute` å®ç°ï¼Œæ³¨æ„è¿™é‡Œçš„ `FnOnce()` è·Ÿ `spawn` æœ‰æ‰€ä¸åŒï¼ŒåŸå› æ˜¯è¦ `execute` ä¼ å…¥çš„é—­åŒ…æ²¡æœ‰å‚æ•°ä¹Ÿæ²¡æœ‰è¿”å›å€¼ã€‚

```bash
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.24s
```

æˆåŠŸç¼–è¯‘ï¼Œä½†åœ¨æµè§ˆå™¨è®¿é—®ä¾ç„¶ä¼šæŠ¥ä¹‹å‰ç±»ä¼¼çš„é”™è¯¯ï¼Œä¸‹é¢æ¥å®ç° `execute`ã€‚

### `new` è¿˜æ˜¯ `build`

å…³äº `ThreadPool` çš„æ„é€ å‡½æ•°ï¼Œå­˜åœ¨ä¸¤ä¸ªé€‰æ‹© `new` å’Œ `build`ã€‚

`new` å¾€å¾€ç”¨äºç®€å•åˆå§‹åŒ–ä¸€ä¸ªå®ä¾‹ï¼Œè€Œ `build` å¾€å¾€ä¼šå®Œæˆæ›´åŠ å¤æ‚çš„æ„å»ºå·¥ä½œï¼Œä¾‹å¦‚å…¥é—¨å®æˆ˜ä¸­çš„ `Config::build`ã€‚

åœ¨è¿™ä¸ªé¡¹ç›®ä¸­ï¼Œæˆ‘ä»¬å¹¶ä¸éœ€è¦åœ¨åˆå§‹åŒ–çº¿ç¨‹æ± çš„åŒæ—¶åˆ›å»ºç›¸åº”çš„çº¿ç¨‹ï¼Œå› æ­¤ `new` æ˜¯æ›´é€‚åˆçš„é€‰æ‹©:

```rust
impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        ThreadPool
    }

    // --snip--
}
```

è¿™é‡Œæœ‰ä¸¤ç‚¹å€¼å¾—æ³¨æ„:

- `usize` ç±»å‹åŒ…å« `0`ï¼Œä½†æ˜¯åˆ›å»ºæ²¡æœ‰ä»»ä½•çº¿ç¨‹çš„çº¿ç¨‹æ± æ˜¾ç„¶æ˜¯æ— æ„ä¹‰çš„ï¼Œå› æ­¤åšä¸€ä¸‹ `assert!` éªŒè¯
- `ThreadPool` æ‹¥æœ‰ä¸é”™çš„[æ–‡æ¡£æ³¨é‡Š](https://course.rs/basic/comment.html#%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A)ï¼Œç”šè‡³åŒ…å«äº†å¯èƒ½ `panic` çš„æƒ…å†µï¼Œé€šè¿‡ `cargo doc --open` å¯ä»¥è®¿é—®æ–‡æ¡£æ³¨é‡Š

### å­˜å‚¨çº¿ç¨‹

åˆ›å»º `ThreadPool` åï¼Œä¸‹ä¸€æ­¥å°±æ˜¯å­˜å‚¨å…·ä½“çš„çº¿ç¨‹ï¼Œæ—¢ç„¶è¦å­˜æ”¾çº¿ç¨‹ï¼Œä¸€ä¸ªç»•ä¸è¿‡å»çš„é—®é¢˜å°±æ˜¯ï¼šç”¨ä»€ä¹ˆç±»å‹æ¥å­˜æ”¾ï¼Œä¾‹å¦‚å‡å¦‚ä½¿ç”¨ `Vec<T>` æ¥å­˜å‚¨ï¼Œé‚£è¿™ä¸ª `T` åº”è¯¥æ˜¯ä»€ä¹ˆï¼Ÿ

ä¼°è®¡è¿˜å¾—æ¢ç´¢ä¸‹ `thread::spawn` çš„ç­¾åï¼Œæ¯•ç«Ÿå®ƒç”Ÿæˆå¹¶è¿”å›ä¸€ä¸ªçº¿ç¨‹:

```rust
pub fn spawn<F, T>(f: F) -> JoinHandle<T>
    where
        F: FnOnce() -> T,
        F: Send + 'static,
        T: Send + 'static,
```

çœ‹èµ·æ¥ `JoinHandle<T>` æ˜¯æˆ‘ä»¬éœ€è¦çš„ï¼Œè¿™é‡Œçš„ `T` æ˜¯ä¼ å…¥çš„é—­åŒ…ä»»åŠ¡æ‰€è¿”å›çš„ï¼Œæˆ‘ä»¬çš„ä»»åŠ¡æ— éœ€ä»»ä½•è¿”å›ï¼Œå› æ­¤ `T` ç›´æ¥ä½¿ç”¨ `()` å³å¯ã€‚

```rust
use std::thread;

pub struct ThreadPool {
    threads: Vec<thread::JoinHandle<()>>,
}

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let mut threads = Vec::with_capacity(size);

        for _ in 0..size {
            // create some threads and store them in the vector
        }

        ThreadPool { threads }
    }
    // --snip--
}
```

å¦‚ä¸Šæ‰€ç¤ºï¼Œæœ€ç»ˆæˆ‘ä»¬ä½¿ç”¨ `Vec<thread::JoinHandle<()>>` æ¥å­˜å‚¨çº¿ç¨‹ï¼ŒåŒæ—¶è®¾å®šäº†å®¹é‡ä¸Šé™ `with_capacity(size)`ï¼Œè¯¥æ–¹æ³•è¿˜å¯ä»¥æå‰åˆ†é…å¥½å†…å­˜ç©ºé—´ï¼Œæ¯” `Vec::new` çš„æ€§èƒ½è¦æ›´å¥½ä¸€ç‚¹ã€‚

### å°†ä»£ç ä» ThreadPool å‘é€åˆ°çº¿ç¨‹ä¸­

ä¸Šé¢çš„ä»£ç ç•™ä¸‹ä¸€ä¸ªæœªå®ç°çš„ `for` å¾ªç¯ï¼Œç”¨äºåˆ›å»ºå’Œå­˜å‚¨çº¿ç¨‹ã€‚

å­¦è¿‡å¤šçº¿ç¨‹ä¸€ç« åï¼Œå¤§å®¶åº”è¯¥çŸ¥é“ `thread::spawn` è™½ç„¶æ˜¯ç”Ÿæˆçº¿ç¨‹æœ€å¥½çš„æ–¹å¼ï¼Œä½†æ˜¯å®ƒä¼šç«‹å³æ‰§è¡Œä¼ å…¥çš„ä»»åŠ¡ï¼Œç„¶è€Œï¼Œåœ¨æˆ‘ä»¬çš„ä½¿ç”¨åœºæ™¯ä¸­ï¼Œåˆ›å»ºçº¿ç¨‹å’Œæ‰§è¡Œä»»åŠ¡æ˜æ˜¾æ˜¯è¦åˆ†ç¦»çš„ï¼Œå› æ­¤æ ‡å‡†åº“çœ‹èµ·æ¥ä¸å†é€‚åˆã€‚

å¯ä»¥è€ƒè™‘åˆ›å»ºä¸€ä¸ª `Worker` ç»“æ„ä½“ï¼Œä½œä¸º `ThreadPool` å’Œä»»åŠ¡çº¿ç¨‹è”ç³»çš„æ¡¥æ¢ï¼Œå®ƒçš„ä»»åŠ¡æ˜¯è·å¾—å°†è¦æ‰§è¡Œçš„ä»£ç ï¼Œç„¶ååœ¨å…·ä½“çš„çº¿ç¨‹ä¸­å»æ‰§è¡Œã€‚æƒ³è±¡ä¸€ä¸ªåœºæ™¯ï¼šä¸€ä¸ªé¤é¦†ï¼Œ`Worker` ç­‰å¾…é¡¾å®¢çš„ç‚¹é¤ï¼Œç„¶åå°†å…·ä½“çš„ç‚¹é¤ä¿¡æ¯ä¼ é€’ç»™å¨æˆ¿ï¼Œæ„Ÿè§‰ç±»ä¼¼æœåŠ¡å‘˜ï¼Ÿ

å¼•å…¥ `Worker` åï¼Œå°±æ— éœ€å†å­˜å‚¨ `JoinHandle<()>` å®ä¾‹ï¼Œç›´æ¥å­˜å‚¨ `Worker` å®ä¾‹ï¼šè¯¥å®ä¾‹å†…éƒ¨ä¼šå­˜å‚¨ `JoinHandle<()>`ã€‚ä¸‹é¢æ˜¯æ–°çš„çº¿ç¨‹æ± åˆ›å»ºæµç¨‹:

```rust
use std::thread;

pub struct ThreadPool {
    workers: Vec<Worker>,
}

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers }
    }
    // --snip--
}

struct Worker {
    id: usize,
    thread: thread::JoinHandle<()>,
}

impl Worker {
    fn new(id: usize) -> Worker {
        // å°šæœªå®ç°..
        let thread = thread::spawn(|| {});
        // æ¯ä¸ª `Worker` éƒ½æ‹¥æœ‰è‡ªå·±çš„å”¯ä¸€ id
        Worker { id, thread }
    }
}
```

ç”±äºå¤–éƒ¨è°ƒç”¨è€…æ— éœ€çŸ¥é“ `Worker` çš„å­˜åœ¨ï¼Œå› æ­¤è¿™é‡Œä½¿ç”¨äº†ç§æœ‰çš„å£°æ˜ã€‚

å¤§å®¶å¯ä»¥ç¼–è¯‘ä¸‹ä»£ç ï¼Œå¦‚æœå‡ºé”™äº†ï¼Œè¯·ä»”ç»†æ£€æŸ¥ä¸‹ï¼Œæ˜¯å¦é—æ¼äº†ä»€ä¹ˆï¼Œæˆªæ­¢ç›®å‰ï¼Œä»£ç æ˜¯å®Œå…¨å¯ä»¥é€šè¿‡ç¼–è¯‘çš„ï¼Œä½†æ˜¯ä»»åŠ¡è¯¥æ€ä¹ˆæ‰§è¡Œä¾ç„¶è¿˜æ²¡æœ‰å®ç°ã€‚

### å°†è¯·æ±‚å‘é€ç»™çº¿ç¨‹

åœ¨ä¸Šé¢çš„ä»£ç ä¸­ï¼Œ `thread::spawn(|| {})` è¿˜æ²¡æœ‰ç»™äºˆå®è´¨æ€§çš„å†…å®¹ï¼Œç°åœ¨ä¸€èµ·æ¥å®Œå–„ä¸‹ã€‚

é¦–å…ˆ `Worker` ç»“æ„ä½“éœ€è¦ä»çº¿ç¨‹æ±  `ThreadPool` çš„é˜Ÿåˆ—ä¸­è·å–å¾…æ‰§è¡Œçš„ä»£ç ï¼Œå¯¹äºè¿™ç±»åœºæ™¯ï¼Œæ¶ˆæ¯ä¼ é€’éå¸¸é€‚åˆï¼šæˆ‘ä»¬å°†ä½¿ç”¨æ¶ˆæ¯é€šé“( channel )ä½œä¸ºä»»åŠ¡é˜Ÿåˆ—ã€‚

```rust
use std::{sync::mpsc, thread};

pub struct ThreadPool {
    workers: Vec<Worker>,
    sender: mpsc::Sender<Job>,
}

struct Job;

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers, sender }
    }
    // --snip--
}
```

é˜…è¯»è¿‡ä¹‹å‰å†…å®¹çš„åŒå­¦åº”è¯¥çŸ¥é“ï¼Œæ¶ˆæ¯é€šé“æœ‰å‘é€ç«¯å’Œæ¥æ”¶ç«¯ï¼Œå…¶ä¸­çº¿ç¨‹æ±  `ThreadPool` æŒæœ‰å‘é€ç«¯ï¼Œé€šè¿‡ `execute` æ–¹æ³•æ¥å‘é€ä»»åŠ¡ã€‚é‚£ä¹ˆé—®é¢˜æ¥äº†ï¼Œè°æŒæœ‰æ¥æ”¶ç«¯å‘¢ï¼Ÿç­”æ¡ˆæ˜¯ `Worker`ï¼Œå®ƒçš„å†…éƒ¨çº¿ç¨‹å°†æ¥æ”¶ä»»åŠ¡ï¼Œç„¶åè¿›è¡Œå¤„ç†ã€‚

```rust
impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, receiver));
        }

        ThreadPool { workers, sender }
    }
    // --snip--
}

// --snip--

impl Worker {
    fn new(id: usize, receiver: mpsc::Receiver<Job>) -> Worker {
        let thread = thread::spawn(|| {
            receiver;
        });

        Worker { id, thread }
    }
}
```

çœ‹èµ·æ¥å¾ˆç¾å¥½ï¼Œä½†æ˜¯å¾ˆä¸å¹¸ï¼Œå®ƒä¼šæŠ¥é”™:

```bash
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0382]: use of moved value: `receiver`
  --> src/lib.rs:26:42
   |
21 |         let (sender, receiver) = mpsc::channel();
   |                      -------- move occurs because `receiver` has type `std::sync::mpsc::Receiver<Job>`, which does not implement the `Copy` trait
...
26 |             workers.push(Worker::new(id, receiver));
   |                                          ^^^^^^^^ value moved here, in previous iteration of loop

For more information about this error, try `rustc --explain E0382`.
error: could not compile `hello` due to previous error
```

åŸå› ä¹Ÿå¾ˆç®€å•ï¼Œ`receiver` å¹¶æ²¡æœ‰å®ç° `Copy`ï¼Œå› æ­¤å®ƒçš„æ‰€æœ‰æƒåœ¨ç¬¬ä¸€æ¬¡å¾ªç¯ä¸­ï¼Œå°±è¢«ä¼ å…¥åˆ°ç¬¬ä¸€ä¸ª `Worker` å®ä¾‹ä¸­ï¼Œåç»­è‡ªç„¶æ— æ³•å†ä½¿ç”¨ã€‚

æŠ¥é”™å°±è§£å†³å‘—ï¼Œä½† Rust ä¸­çš„ channel å®ç°æ˜¯ mpscï¼Œå³å¤šç”Ÿäº§è€…å•æ¶ˆè´¹è€…ï¼Œå› æ­¤æˆ‘ä»¬æ— æ³•é€šè¿‡å…‹éš†æ¶ˆè´¹è€…çš„æ–¹å¼æ¥ä¿®å¤è¿™ä¸ªé”™è¯¯ã€‚å½“ç„¶ï¼Œå‘é€å¤šæ¡æ¶ˆæ¯ç»™å¤šä¸ªæ¥æ”¶è€…ä¹Ÿä¸åœ¨è€ƒè™‘èŒƒç•´ï¼Œè¯¥æ€ä¹ˆåŠï¼Ÿä¼¼ä¹é™·å…¥äº†ç»å¢ƒã€‚

é›ªä¸ŠåŠ éœœçš„æ˜¯ï¼Œå°±ç®— `receiver` å¯ä»¥å…‹éš†ï¼Œä½†æ˜¯ä½ å¾—ä¿è¯åŒä¸€ä¸ªæ—¶é—´åªæœ‰ä¸€ä¸ª`receiver` èƒ½æ¥æ”¶æ¶ˆæ¯ï¼Œå¦åˆ™ä¸€ä¸ªä»»åŠ¡å¯èƒ½åŒæ—¶è¢«å¤šä¸ª `Worker` æ‰§è¡Œï¼Œå› æ­¤å¤šä¸ªçº¿ç¨‹éœ€è¦å®‰å…¨çš„å…±äº«å’Œä½¿ç”¨ `receiver`ï¼Œç­‰ç­‰ï¼Œå®‰å…¨çš„å…±äº«ï¼Ÿå¬ä¸Šå» `Arc` è¿™ä¸ªå¤šæ‰€æœ‰æƒç»“æ„éå¸¸é€‚åˆï¼Œäº’æ–¥ä½¿ç”¨ï¼Ÿè²Œä¼¼ `Mutex` å¾ˆé€‚åˆï¼Œç»“åˆä¸€ä¸‹ï¼Œ`Arc<Mutex<T>>`ï¼Œè¿™ä¸å°±æ˜¯æˆ‘ä»¬ä¹‹å‰è§è¿‡å¤šæ¬¡çš„çº¿ç¨‹å®‰å…¨ç±»å‹å—ï¼Ÿ

æ€»ä¹‹ï¼Œ`Arc` å…è®¸å¤šä¸ª `Worker` åŒæ—¶æŒæœ‰ `receiver`ï¼Œè€Œ `Mutex` å¯ä»¥ç¡®ä¿ä¸€æ¬¡åªæœ‰ä¸€ä¸ª `Worker` èƒ½ä» `receiver` æ¥æ”¶æ¶ˆæ¯ã€‚

```rust
use std::{
    sync::{mpsc, Arc, Mutex},
    thread,
};
// --snip--

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&receiver)));
        }

        ThreadPool { workers, sender }
    }

    // --snip--
}

// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
        // --snip--
    }
}
```

ä¿®æ”¹åï¼Œæ¯ä¸€ä¸ª Worker éƒ½å¯ä»¥å®‰å…¨çš„æŒæœ‰ `receiver`ï¼ŒåŒæ—¶ä¸å¿…æ‹…å¿ƒä¸€ä¸ªä»»åŠ¡ä¼šè¢«é‡å¤æ‰§è¡Œå¤šæ¬¡ï¼Œå®Œç¾ï¼

### å®ç° execute æ–¹æ³•

é¦–å…ˆï¼Œéœ€è¦ä¸ºä¸€ä¸ªå¾ˆé•¿çš„ç±»å‹åˆ›å»ºä¸€ä¸ªåˆ«å, æœ‰å¤šé•¿å‘¢ï¼Ÿ

```rust
// --snip--

type Job = Box<dyn FnOnce() + Send + 'static>;

impl ThreadPool {
    // --snip--

    pub fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(job).unwrap();
    }
}

// --snip--
```

åˆ›å»ºåˆ«åçš„å¨åŠ›æš‚æ—¶è¿˜çœ‹ä¸åˆ°ï¼Œæ•¬è¯·æœŸå¾…ã€‚æ€»ä¹‹ï¼Œè¿™é‡Œçš„å·¥ä½œå¾ˆç®€å•ï¼Œå°†ä¼ å…¥çš„ä»»åŠ¡åŒ…è£…æˆ `Job` ç±»å‹åï¼Œå‘é€å‡ºå»ã€‚

ä½†æ˜¯è¿˜æ²¡å®Œï¼Œæ¥æ”¶çš„ä»£ç ä¹Ÿè¦å®Œå–„ä¸‹:

```rust
// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
        let thread = thread::spawn(move || loop {
            let job = receiver.lock().unwrap().recv().unwrap();

            println!("Worker {id} got a job; executing.");

            job();
        });

        Worker { id, thread }
    }
}
```

ä¿®æ”¹åï¼Œå°±å¯ä»¥ä¸åœåœ°å¾ªç¯å»æ¥æ”¶ä»»åŠ¡ï¼Œæœ€åè¿›è¡Œæ‰§è¡Œã€‚è¿˜å¯ä»¥çœ‹åˆ°å› ä¸ºä¹‹å‰ `Job` åˆ«åçš„å¼•å…¥ï¼Œ `new` å‡½æ•°çš„ç­¾åæ‰æ²¡æœ‰è¿‡åº¦å¤æ‚ï¼Œå¦åˆ™ä½ å°†çœ‹åˆ°çš„æ˜¯ `fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Box<dyn FnOnce() + Send + 'static>>>>) -> Worker` ï¼Œæ„Ÿå—ä¸‹ç±»å‹åˆ«åçš„å¨åŠ›å§ ğŸ˜„

`lock()` æ–¹æ³•å¯ä»¥è·å¾—ä¸€ä¸ª `Mutex` é”ï¼Œè‡³äºä¸ºä½•ä½¿ç”¨ `unwrap`ï¼Œéš¾é“è·å–é”è¿˜èƒ½å¤±è´¥ï¼Ÿæ²¡é”™ï¼Œå‡å¦‚å½“å‰æŒæœ‰é”çš„çº¿ç¨‹ `panic` äº†ï¼Œé‚£ä¹ˆè¿™äº›ç­‰å¾…é”çš„çº¿ç¨‹å°±ä¼šè·å–ä¸€ä¸ªé”™è¯¯ï¼Œå› æ­¤ é€šè¿‡ `unwrap` æ¥è®©å½“å‰ç­‰å¾…çš„çº¿ç¨‹ `panic` æ˜¯ä¸€ä¸ªä¸é”™çš„è§£å†³æ–¹æ¡ˆï¼Œå½“ç„¶ä½ è¿˜å¯ä»¥æ¢æˆ `expect`ã€‚

ä¸€æ—¦è·å–åˆ°é”é‡Œçš„å†…å®¹ `mpsc::Receiver<Job>>` åï¼Œå°±å¯ä»¥è°ƒç”¨å…¶ä¸Šçš„ `recv` æ–¹æ³•æ¥æ¥æ”¶æ¶ˆæ¯ï¼Œä¾ç„¶æ˜¯ä¸€ä¸ª `unwrap`ï¼ŒåŸå› åœ¨äºæŒæœ‰å‘é€ç«¯çš„çº¿ç¨‹å¯èƒ½ä¼šè¢«å…³é—­ï¼Œè¿™ç§æƒ…å†µä¸‹ç›´æ¥ `panic` ä¹Ÿæ˜¯ä¸é”™çš„ã€‚

`recv` çš„è°ƒç”¨è¿‡ç¨‹æ˜¯é˜»å¡çš„ï¼Œæ„å‘³ç€è‹¥æ²¡æœ‰ä»»ä½•ä»»åŠ¡ï¼Œé‚£å½“å‰çš„è°ƒç”¨çº¿ç¨‹å°†ä¸€ç›´ç­‰å¾…ï¼Œç›´åˆ°æ¥æ”¶åˆ°æ–°çš„ä»»åŠ¡ã€‚`Mutex<T>` å¯ä»¥ä¿è¯åŒä¸€ä¸ªä»»åŠ¡åªä¼šè¢«ä¸€ä¸ª Worker è·å–ï¼Œä¸ä¼šè¢«é‡å¤æ‰§è¡Œã€‚

```bash
$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
warning: field is never read: `workers`
 --> src/lib.rs:7:5
  |
7 |     workers: Vec<Worker>,
  |     ^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: field is never read: `id`
  --> src/lib.rs:48:5
   |
48 |     id: usize,
   |     ^^^^^^^^^

warning: field is never read: `thread`
  --> src/lib.rs:49:5
   |
49 |     thread: thread::JoinHandle<()>,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: `hello` (lib) generated 3 warnings
    Finished dev [unoptimized + debuginfo] target(s) in 1.40s
     Running `target/debug/hello`
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
```

ç»ˆäºï¼Œç¨‹åºå¦‚æ„¿è¿è¡Œèµ·æ¥ï¼Œæˆ‘ä»¬çš„çº¿ç¨‹æ± å¯ä»¥å¹¶å‘å¤„ç†ä»»åŠ¡äº†ï¼ä»æ‰“å°çš„æ•°å­—å¯ä»¥çœ‹åˆ°ï¼Œåªæœ‰ 4 ä¸ªçº¿ç¨‹å»æ‰§è¡Œä»»åŠ¡ï¼Œç¬¦åˆæˆ‘ä»¬å¯¹çº¿ç¨‹æ± çš„è¦æ±‚ï¼Œè¿™æ ·å†ä¹Ÿä¸ç”¨æ‹…å¿ƒç³»ç»Ÿçš„çº¿ç¨‹èµ„æºä¼šè¢«æ¶ˆè€—æ®†å°½äº†ï¼

> æ³¨æ„ï¼š å‡ºäºç¼“å­˜çš„è€ƒè™‘ï¼Œæœ‰äº›æµè§ˆå™¨ä¼šå¯¹å¤šæ¬¡åŒæ ·çš„è¯·æ±‚è¿›è¡Œé¡ºåºçš„æ‰§è¡Œï¼Œå› æ­¤ä½ å¯èƒ½è¿˜æ˜¯ä¼šé‡åˆ°è®¿é—® `/sleep` åï¼Œå°±æ— æ³•è®¿é—®å¦ä¸€ä¸ª `/sleep` çš„é—®é¢˜ ğŸ˜¦

## while let çš„å·¨å¤§é™·é˜±

è¿˜æœ‰ä¸€ä¸ªé—®é¢˜ï¼Œä¸ºå•¥ä¹‹å‰æˆ‘ä»¬ä¸ç”¨ `while let` æ¥å¾ªç¯ï¼Ÿä¾‹å¦‚ï¼š

```rust
// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
        let thread = thread::spawn(move || {
            while let Ok(job) = receiver.lock().unwrap().recv() {
                println!("Worker {id} got a job; executing.");

                job();
            }
        });

        Worker { id, thread }
    }
}
```

è¿™æ®µä»£ç ç¼–è¯‘èµ·æ¥æ²¡é—®é¢˜ï¼Œä½†æ˜¯å¹¶ä¸ä¼šäº§ç”Ÿæˆ‘ä»¬é¢„æœŸçš„ç»“æœï¼šåç»­è¯·æ±‚ä¾ç„¶éœ€è¦ç­‰å¾…æ…¢è¯·æ±‚çš„å¤„ç†å®Œæˆåï¼Œæ‰èƒ½è¢«å¤„ç†ã€‚å¥‡æ€ªå§ï¼Œä»…ä»…æ˜¯ä» `let` æ”¹æˆ `while let` å°±ä¼šå˜æˆè¿™æ ·ï¼Ÿå¤§å®¶å¯ä»¥æ€è€ƒä¸‹ä¸ºä»€ä¹ˆä¼šè¿™æ ·ï¼Œå…·ä½“ç­”æ¡ˆä¼šåœ¨ä¸‹ä¸€ç« èŠ‚æœ«å°¾ç»™å‡ºï¼Œè¿™é‡Œå…ˆå‡ºç»™ä¸€ä¸ªå°æç¤ºï¼š`Mutex` è·å–çš„é”åœ¨ä½œç”¨åŸŸç»“æŸåæ‰ä¼šè¢«é‡Šæ”¾ã€‚














