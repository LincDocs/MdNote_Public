import{_ as s,c as a,b as n,o as l}from"./app-diKoMwN1.js";const t={};function e(h,i){return l(),a("div",null,[...i[0]||(i[0]=[n(`<h1 id="指针类型" tabindex="-1">指针类型</h1><h2 id="rust的借用" tabindex="-1">Rust的借用</h2><p>定义：<strong>获取变量的引用，称之为借用(borrowing)</strong></p><p>虽然Rust主要通过所有权管理，不像C那样经常存在多个指针引用同一地址的问题</p><p>但是Rust也有类似的东西。详见 Rust 的 “引用与借用”</p><p>又分：</p><ul><li>不可变引用</li><li>可变引用</li></ul><h2 id="为什么需要" tabindex="-1">为什么需要</h2><p>其实不使用这个特性，似乎没有功能上的损失。所有权系统都能做到</p><p>但写函数的时候，总要把参数传进来再返回回去，写起来非常臃肿。所以也可以看作是一种语法糖</p><h2 id="如何保证内存安全" tabindex="-1">如何保证内存安全</h2><p>我们之前知道了Rust的所有权机制，是如何保证内存安全的。</p><p>但现在又引入引用和借用机制，难道不会破坏之前设计好的内存安全和数据竞争吗？还是通过什么机制来保证安全和数据竞争？</p><h3 id="数据竞争" tabindex="-1">数据竞争</h3><blockquote><h4 id="原因" tabindex="-1">原因</h4></blockquote><p>数据竞争可由以下行为造成</p><ul><li>两个或更多的指针同时访问同一数据</li><li>至少有一个指针被用来写入数据</li><li>没有同步数据访问的机制</li></ul><blockquote><h4 id="策略" tabindex="-1">策略</h4></blockquote><p>为此添加以下规则</p><ul><li>可变引用同时只能存在一个</li><li>可变引用与不可变引用不能同时存在</li></ul><p>或浓缩一下</p><ul><li>同一时刻，你只能拥有要么一个可变引用，要么任意多个不可变引用</li></ul><blockquote><h4 id="原理" tabindex="-1">原理</h4></blockquote><p>原理上有点像读写锁，避免数据竞争。</p><p>读写锁不能同时lock，且只能有一个写锁在lock</p><blockquote><h4 id="技巧" tabindex="-1">技巧</h4></blockquote><p>多用 <code>{}</code> 来限制引用的作用域，会灵活些</p><blockquote><h4 id="理解" tabindex="-1">理解</h4></blockquote><p>或者可以用一些比喻来理解。不用 “引用” 这个其他语言的词，而是用回 “借用”。</p><p>正在借用不可变引用的用户，肯定不希望他借用的东西，被另外一个人莫名其妙改变了。</p><p>从这一点来看，其实 “借用” 与单个可变引用/不可变引用 (看作是所有者不允许被借书的人在上面画东西) 更贴切些。与多个不可变引用没那么贴切，毕竟不太能同时把东西借用给多个人</p><h3 id="内存问题-悬垂引用问题" tabindex="-1">内存问题，悬垂引用问题</h3><blockquote><p>检查器的一些个人猜测</p><ul><li>检查所有者变更后，旧所有者是否还会被使用那样。也可以检查是所有者会被借用者还回数据前，是否会被调用</li><li>在简单场景上，如调用函数。可以看作是还是使用所有权机制的一种语法糖</li></ul></blockquote><p><strong>在 Rust 中编译器可以确保引用永远也不会变成悬垂状态</strong></p><p>让我们尝试创建一个悬垂引用，Rust 会抛出一个编译时错误</p><p><strong>下面是一个例子</strong></p><p>(顺便注释了 <code>dangle</code> 代码的每一步到底发生了什么)</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    let reference_to_nothing </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> dangle</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> dangle</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;"> &amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">String {</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // dangle 返回一个字符串的引用</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    let s </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> String::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;hello&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // s 是一个新字符串</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">    &amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">s</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 返回字符串 s 的引用</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 这里 s 离开作用域并被丢弃。其内存被释放。</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 危险！</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>错误信息引用了一个我们还未介绍的功能：<a href="https://course.rs/basic/lifetime.html" target="_blank" rel="noopener noreferrer">生命周期(lifetimes)</a>。不过，即使你不理解生命周期，也可以通过错误信息知道这段代码错误的关键信息：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">this</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> function&#39;s return type contains a borrowed value, but there is no value for it to be borrowed from.</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">该函数返回了一个借用的值，但是已经找不到它所借用值的来源</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>其中一个很好的解决方法是直接返回 <code>String</code>：</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-rust"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> no_dangle</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() -&gt; </span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    let</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> s</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;hello&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    s</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样就没有任何错误了，最终 <code>String</code> 的 <strong>所有权被转移给外面的调用者</strong>。</p><h2 id="其他-nll" tabindex="-1">其他 - NLL</h2><p>一些编译器优化杂谈</p><p>Rust 的编译器一直在优化，早期的时候，引用的作用域跟变量作用域是一致的，这对日常使用带来了很大的困扰，你必须非常小心的去安排可变、不可变变量的借用，免得无法通过编译，例如以下代码：</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-rust"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">   let</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> mut</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> s</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;hello&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    let</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> r1</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &amp;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">s</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    let</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> r2</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &amp;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">s</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    println!</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;{} and {}&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">r1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">r2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 新编译器中，r1,r2作用域在这里结束</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    let</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> r3</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &amp;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">mut</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> s</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    println!</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;{}&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">r3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">} </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 老编译器中，r1、r2、r3作用域在这里结束</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 新编译器中，r3作用域在这里结束</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在老版本的编译器中（Rust 1.31 前），将会报错，因为 <code>r1</code> 和 <code>r2</code> 的作用域在花括号 <code>}</code> 处结束，那么 <code>r3</code> 的借用就会触发 <strong>无法同时借用可变和不可变</strong> 的规则。</p><p>但是在新的编译器中，该代码将顺利通过，因为 <strong>引用作用域的结束位置从花括号变成最后一次使用的位置</strong>，因此 <code>r1</code> 借用和 <code>r2</code> 借用在 <code>println!</code> 后，就结束了，此时 <code>r3</code> 可以顺利借用到可变引用。</p><p>对于这种编译器优化行为，Rust 专门起了一个名字 —— <strong>Non-Lexical Lifetimes(NLL)</strong>，专门用于找到某个引用在作用域(<code>}</code>)结束前就不再被使用的代码位置。</p>`,50)])])}const k=s(t,[["render",e]]),r=JSON.parse('{"path":"/01.%20DesignAndDevelop/Develop/01.%20Language/Rust/%E5%AD%A6%E4%B9%A0/02.%20%E6%95%B0%E6%8D%AE_%E7%AE%97%E6%B3%95/05.%20%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B.html","title":"指针类型","lang":"zh-CN","frontmatter":{"description":"指针类型 Rust的借用 定义：获取变量的引用，称之为借用(borrowing) 虽然Rust主要通过所有权管理，不像C那样经常存在多个指针引用同一地址的问题 但是Rust也有类似的东西。详见 Rust 的 “引用与借用” 又分： 不可变引用 可变引用 为什么需要 其实不使用这个特性，似乎没有功能上的损失。所有权系统都能做到 但写函数的时候，总要把参数...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"指针类型\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-10-20T22:18:42.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://LincDocs.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/01.%20Language/Rust/%E5%AD%A6%E4%B9%A0/02.%20%E6%95%B0%E6%8D%AE_%E7%AE%97%E6%B3%95/05.%20%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B.html"}],["meta",{"property":"og:site_name","content":"MdNote_Public"}],["meta",{"property":"og:title","content":"指针类型"}],["meta",{"property":"og:description","content":"指针类型 Rust的借用 定义：获取变量的引用，称之为借用(borrowing) 虽然Rust主要通过所有权管理，不像C那样经常存在多个指针引用同一地址的问题 但是Rust也有类似的东西。详见 Rust 的 “引用与借用” 又分： 不可变引用 可变引用 为什么需要 其实不使用这个特性，似乎没有功能上的损失。所有权系统都能做到 但写函数的时候，总要把参数..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-20T22:18:42.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-20T22:18:42.000Z"}]]},"git":{"createdTime":1760998722000,"updatedTime":1760998722000,"contributors":[{"name":"Linc","username":"Linc","email":"762699299@qq.com","commits":1,"url":"https://github.com/Linc"}]},"readingTime":{"minutes":4.39,"words":1318},"filePathRelative":"01. DesignAndDevelop/Develop/01. Language/Rust/学习/02. 数据+算法/05. 指针类型.md","excerpt":"\\n<h2>Rust的借用</h2>\\n<p>定义：<strong>获取变量的引用，称之为借用(borrowing)</strong></p>\\n<p>虽然Rust主要通过所有权管理，不像C那样经常存在多个指针引用同一地址的问题</p>\\n<p>但是Rust也有类似的东西。详见 Rust 的 “引用与借用”</p>\\n<p>又分：</p>\\n<ul>\\n<li>不可变引用</li>\\n<li>可变引用</li>\\n</ul>\\n<h2>为什么需要</h2>\\n<p>其实不使用这个特性，似乎没有功能上的损失。所有权系统都能做到</p>\\n<p>但写函数的时候，总要把参数传进来再返回回去，写起来非常臃肿。所以也可以看作是一种语法糖</p>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"01. DesignAndDevelop/Develop/01. Language/Rust/学习/02. 数据+算法/05. 指针类型.md","value":{"title":"05. 指针类型","path":"01. DesignAndDevelop/Develop/01. Language/Rust/学习/02. 数据+算法/05. 指针类型.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{k as comp,r as data};
