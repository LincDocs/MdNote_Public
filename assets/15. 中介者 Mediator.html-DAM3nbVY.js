import{_ as n,c as r,b as o,e as i,r as a,o as d}from"./app-LiNCBk-L.js";const l={};function p(c,e){const t=a("Mermaid");return d(),r("div",null,[e[0]||(e[0]=o('<h1 id="《c-设计模式》视频-李建忠" tabindex="-1">《C++设计模式》视频_李建忠</h1><h1 id="目录" tabindex="-1">目录</h1><p>[toc]</p><h1 id="中介者-mediator" tabindex="-1">中介者 Mediator</h1><h2 id="所属分类——-接口隔离-模式" tabindex="-1">所属分类——“接口隔离” 模式</h2><p>略</p><h2 id="动机-motivation" tabindex="-1">动机（Motivation）</h2><h3 id="简概" tabindex="-1">简概</h3><ul><li>在软件构建过程中，经常会出现多个对象互相关联交互的情况，对象之间常常会维持一种复杂的引用关系，如果遇到一些需求的更改，这种直接的引用关系将面临不断的变化。</li><li>在这种情况下，我们可使用一个 <strong>“中介对象&quot;</strong> 来管理对象间的关联关系，避免相互交互的对象之间的紧耦合引用关系，从而更好地抵御变化</li></ul><h3 id="应用体现" tabindex="-1">应用体现</h3><p>界面中控件更改影响DataModel，DataModel更改时也能影响控件（即双向绑定），可能会出现双向的互相依赖</p><p>类似于MVVM（Model-View-ViewModel，模型-视图-视图模型）本质上就是MVC （Model-View-Controller，模型-视图-控制器 ）的改进版</p><p>类似于Vue（Vue中，<code>v-bind</code>/<code> :</code>应该用的是观察者模式，而<code>v-model</code>双向绑定应该是用的中介者模式）</p><h3 id="代码体现" tabindex="-1">代码体现</h3><p>无</p><h2 id="设计模式" tabindex="-1">设计模式</h2><h3 id="模式定义" tabindex="-1">模式定义</h3><blockquote><p>用一个<strong>中介对象</strong>来<strong>封装（封装变化）<strong>一系列的对象</strong>交互</strong>。<br> 中介者使各对象不需要显式的相互引用（编译时依赖 → 运行时依赖），从而使其耦合松散（管理变化），而且可以独立地改变它们之间的交互。</p><p>——《设计模式》GoF</p></blockquote><h3 id="结构-structure" tabindex="-1">结构（Structure）</h3><p>（红色表示稳定）</p>',20)),i(t,{code:"eJxLL0osyFAIceIqLk2CsJ/sWPtkd/eLhtaXzSuedrRxKQCBY7RvakpmYkl+EUL6WdfeFxsXPp2/6/nG3bHWyTmJxcUKjgpFqSkQHYbRzvnJRaklqZg6n7Zuf7J3MkgbV2peCsJm5/ycnNTE9NJUJJudgMZARWGWOMEtcQJZkge2Ba7KMBYiZYQpZQSxj8tRV/fZln3Pp8zX1bVzNORyNNTVe9bT/nJSh56unRM634jLCaEcLI/KN+LiAjvLJTUN5C6FtMycHCvlNMs0neKSovzsVCtlY2NjKFu3PDOlJMPKpKDCmgsAOe6WkA=="}),i(t,{code:"eJxLL0osyFDwCeJyzs/JSU1ML03V1Xva0/p0wupnPe0vJ3Uo5KamZCaW5Bfp6dr5QpnRMIbCkx1rn+zuftHQ+qxr74uNC5/O3/V84+5Y6+ScxOJiBbiJCkWpKVAxuE6gEBdYyCU1DcRRSMvMybFSTrNM0ykuKcrPTrVSNjY2hrJ1yzNTSjKsTAoqrLkAU3pJ+A=="}),e[1]||(e[1]=o('<p>其中注意：ConcreteColleague1和CocreteClooeague2之间没有依赖关系</p><h3 id="要点总结" tabindex="-1">要点总结</h3><ul><li>将多个对象间复杂的关联关系解耦，Mediator模式将多个对象间的控制逻辑进行集中管理，<br><strong>变 “多个对象互相关联” 为 “多个对象和一个中介者关联”</strong>，简化了系统的维护，抵御了可能的变化。</li><li>随着控制逻辑的复杂化，Mediator具体对象的<strong>实现可能相当复杂</strong>。这时候可以对Mediator对象进行分解处理。</li><li>Facade模式是<strong>解耦系统间</strong>（单向）的对象关联关系；Mediator模式是<strong>解耦系统内</strong>各个对象之间（双向）的关联关系。</li></ul>',3))])}const s=n(l,[["render",p]]),A=JSON.parse('{"path":"/01.%20DesignAndDevelop/Develop/03.%20Tools/03.%20%E7%AE%A1%E7%90%86%E5%B1%82/01.%20%E5%A4%9A%E7%B1%BB%E7%AE%A1%E7%90%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E3%80%8AC__%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E8%A7%86%E9%A2%91_%E6%9D%8E%E5%BB%BA%E5%BF%A0/15.%20%E4%B8%AD%E4%BB%8B%E8%80%85%20Mediator.html","title":"《C++设计模式》视频_李建忠","lang":"zh-CN","frontmatter":{"description":"《C++设计模式》视频_李建忠 目录 [toc] 中介者 Mediator 所属分类——“接口隔离” 模式 略 动机（Motivation） 简概 在软件构建过程中，经常会出现多个对象互相关联交互的情况，对象之间常常会维持一种复杂的引用关系，如果遇到一些需求的更改，这种直接的引用关系将面临不断的变化。 在这种情况下，我们可使用一个 “中介对象\\" 来管理...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"《C++设计模式》视频_李建忠\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-11-08T16:11:07.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://LincDocs.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/03.%20Tools/03.%20%E7%AE%A1%E7%90%86%E5%B1%82/01.%20%E5%A4%9A%E7%B1%BB%E7%AE%A1%E7%90%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E3%80%8AC__%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E8%A7%86%E9%A2%91_%E6%9D%8E%E5%BB%BA%E5%BF%A0/15.%20%E4%B8%AD%E4%BB%8B%E8%80%85%20Mediator.html"}],["meta",{"property":"og:site_name","content":"MdNote_Public"}],["meta",{"property":"og:title","content":"《C++设计模式》视频_李建忠"}],["meta",{"property":"og:description","content":"《C++设计模式》视频_李建忠 目录 [toc] 中介者 Mediator 所属分类——“接口隔离” 模式 略 动机（Motivation） 简概 在软件构建过程中，经常会出现多个对象互相关联交互的情况，对象之间常常会维持一种复杂的引用关系，如果遇到一些需求的更改，这种直接的引用关系将面临不断的变化。 在这种情况下，我们可使用一个 “中介对象\\" 来管理..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-11-08T16:11:07.000Z"}],["meta",{"property":"article:modified_time","content":"2025-11-08T16:11:07.000Z"}]]},"git":{"createdTime":1762618267000,"updatedTime":1762618267000,"contributors":[{"name":"Linc","username":"Linc","email":"762699299@qq.com","commits":1,"url":"https://github.com/Linc"}]},"readingTime":{"minutes":2.2,"words":660},"filePathRelative":"01. DesignAndDevelop/Develop/03. Tools/03. 管理层/01. 多类管理/设计模式/《C++设计模式》视频_李建忠/15. 中介者 Mediator.md","excerpt":"\\n<h1>目录</h1>\\n<p>[toc]</p>\\n<h1>中介者 Mediator</h1>\\n<h2>所属分类——“接口隔离” 模式</h2>\\n<p>略</p>\\n<h2>动机（Motivation）</h2>\\n<h3>简概</h3>\\n<ul>\\n<li>在软件构建过程中，经常会出现多个对象互相关联交互的情况，对象之间常常会维持一种复杂的引用关系，如果遇到一些需求的更改，这种直接的引用关系将面临不断的变化。</li>\\n<li>在这种情况下，我们可使用一个 <strong>“中介对象\\"</strong> 来管理对象间的关联关系，避免相互交互的对象之间的紧耦合引用关系，从而更好地抵御变化</li>\\n</ul>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"01. DesignAndDevelop/Develop/03. Tools/03. 管理层/01. 多类管理/设计模式/《C++设计模式》视频_李建忠/15. 中介者 Mediator.md","value":{"title":"15. 中介者 Mediator","path":"01. DesignAndDevelop/Develop/03. Tools/03. 管理层/01. 多类管理/设计模式/《C++设计模式》视频_李建忠/15. 中介者 Mediator.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{s as comp,A as data};
