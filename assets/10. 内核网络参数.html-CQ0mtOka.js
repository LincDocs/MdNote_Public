import{_ as n,c as s,f as a,o as i}from"./app-B2g-EbEF.js";const t={};function d(l,e){return i(),s("div",null,e[0]||(e[0]=[a(`<h1 id="内核中的网络参数" tabindex="-1"><a class="header-anchor" href="#内核中的网络参数"><span>内核中的网络参数</span></a></h1><h2 id="nf-conntrack" tabindex="-1"><a class="header-anchor" href="#nf-conntrack"><span>nf_conntrack</span></a></h2><p><code>nf_conntrack</code>是Linux内核连接跟踪的模块，常用在<code>iptables</code>中，比如</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>-A INPUT -m state --state RELATED,ESTABLISHED  -j RETURN</span></span>
<span class="line"><span>-A INPUT -m state --state INVALID -j DROP</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>可以通过<code>cat /proc/net/nf_conntrack</code>来查看当前跟踪的连接信息，这些信息以哈希形式（用链地址法处理冲突）存在内存中，并且每条记录大约占300B空间。</p><p>与<code>nf_conntrack</code>相关的内核参数有三个：</p><ul><li><code>nf_conntrack_max</code>：连接跟踪表的大小，建议根据内存计算该值<code>CONNTRACK_MAX = RAMSIZE (in bytes) / 16384 / (x / 32)</code>，并满足<code>nf_conntrack_max=4*nf_conntrack_buckets</code>，默认262144</li><li><code>nf_conntrack_buckets</code>：哈希表的大小，(<code>nf_conntrack_max/nf_conntrack_buckets</code>就是每条哈希记录链表的长度)，默认65536</li><li><code>nf_conntrack_tcp_timeout_established</code>：tcp会话的超时时间，默认是432000 (5天)</li></ul><p>比如，对64G内存的机器，推荐配置：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>net.netfilter.nf_conntrack_max=4194304</span></span>
<span class="line"><span>net.netfilter.nf_conntrack_tcp_timeout_established=300</span></span>
<span class="line"><span>net.netfilter.nf_conntrack_buckets=1048576</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="bridge-nf" tabindex="-1"><a class="header-anchor" href="#bridge-nf"><span>bridge-nf</span></a></h2><p>bridge-nf使得netfilter可以对Linux网桥上的IPv4/ARP/IPv6包过滤。比如，设置<code>net.bridge.bridge-nf-call-iptables＝1</code>后，二层的网桥在转发包时也会被iptables的FORWARD规则所过滤，这样有时会出现L3层的iptables rules去过滤L2的帧的问题（见<a href="https://bugzilla.redhat.com/show_bug.cgi?id=512206" target="_blank" rel="noopener noreferrer">这里</a>）。</p><p>常用的选项包括</p><ul><li><code>net.bridge.bridge-nf-call-arptables</code>：是否在<code>arptables</code>的FORWARD中过滤网桥的ARP包</li><li><code>net.bridge.bridge-nf-call-ip6tables</code>：是否在<code>ip6tables</code>链中过滤IPv6包</li><li><code>net.bridge.bridge-nf-call-iptables</code>：是否在<code>iptables</code>链中过滤IPv4包</li><li><code>net.bridge.bridge-nf-filter-vlan-tagged</code>：是否在i<code>ptables/arptables</code>中过滤打了vlan标签的包</li></ul><p>当然，也可以通过<code>/sys/devices/virtual/net/&lt;bridge-name&gt;/bridge/nf_call_iptables</code>来设置，但要注意内核是取两者中大的生效。</p><p>有时，可能只希望部分网桥禁止bridge-nf，而其他网桥都开启（比如CNI网络插件中一般要求bridge-nf-call-iptables选项开启，而有时又希望禁止某个网桥的bridge-nf），这时可以改用iptables的方法：</p><div class="language-sh line-numbers-mode" data-highlighter="shiki" data-ext="sh" data-title="sh" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">iptables</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -t</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> raw</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -I</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> PREROUTING</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">bridge-nam</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">e&gt; </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">-j</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> NOTRACK</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="反向路径过滤" tabindex="-1"><a class="header-anchor" href="#反向路径过滤"><span>反向路径过滤</span></a></h2><p>反向路径过滤可用于防止数据包从一接口传入，又从另一不同的接口传出（这有时被称为 “非对称路由” ）。除非必要，否则最好将其关闭，因为它可防止来自子网络的用户采用 IP 地址欺骗手段，并减少 DDoS （分布式拒绝服务）攻击的机会。</p><p>通过 rp_filter 选项启用反向路径过滤，比如 <code>sysctl -w net.ipv4.conf.default.rp_filter=INTEGER</code>。支持三种选项：</p><ul><li>0 ——未进行源验证。</li><li>1 ——处于如 RFC3704 所定义的严格模式。</li><li>2 ——处于如 RFC3704 所定义的松散模式。</li></ul><p>可以通过 <code>net.ipv4.interface.rp_filter</code>可实现对每一网络接口设置的覆盖。</p><h2 id="tcp相关" tabindex="-1"><a class="header-anchor" href="#tcp相关"><span>TCP相关</span></a></h2><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th><th><strong>默认值</strong></th><th><strong>优化值</strong></th></tr></thead><tbody><tr><td><code>net.core.rmem_default</code></td><td>默认的TCP数据接收窗口大小（字节）</td><td>212992</td><td></td></tr><tr><td><code>net.core.rmem_max</code></td><td>最大的TCP数据接收窗口（字节）。</td><td>212992</td><td></td></tr><tr><td><code>net.core.wmem_default</code></td><td>默认的TCP数据发送窗口大小（字节）。</td><td>212992</td><td></td></tr><tr><td><code>net.core.wmem_max</code></td><td>最大的TCP数据发送窗口（字节）。</td><td>212992</td><td></td></tr><tr><td><code>net.core.netdev_max_backlog</code></td><td>在每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。</td><td>1000</td><td>10000</td></tr><tr><td><code>net.core.somaxconn</code></td><td>定义了系统中每一个端口最大的监听队列的长度，这是个全局的参数。</td><td>128</td><td>2048</td></tr><tr><td><code>net.core.optmem_max</code></td><td>表示每个套接字所允许的最大缓冲区的大小。</td><td>20480</td><td>81920</td></tr><tr><td><code>net.ipv4.tcp_mem</code></td><td>确定TCP栈应该如何反映内存使用，每个值的单位都是内存页（通常是4KB）。第一个值是内存使用的下限；第二个值是内存压力模式开始对缓冲区使用应用压力的上限；第三个值是内存使用的上限。在这个层次上可以将报文丢弃，从而减少对内存的使用。对于较大的BDP可以增大这些值（注意，其单位是内存页而不是字节）。</td><td>5814 7754 11628</td><td></td></tr><tr><td><code>net.ipv4.tcp_rmem</code></td><td>为自动调优定义socket使用的内存。第一个值是为socket接收缓冲区分配的最少字节数；第二个值是默认值（该值会被<code>rmem_default</code>覆盖），缓冲区在系统负载不重的情况下可以增长到这个值；第三个值是接收缓冲区空间的最大字节数（该值会被<code>rmem_max</code>覆盖）。</td><td>4096 87380 3970528</td><td></td></tr><tr><td><code>net.ipv4.tcp_wmem</code></td><td>为自动调优定义socket使用的内存。第一个值是为socket发送缓冲区分配的最少字节数；第二个值是默认值（该值会被<code>wmem_default</code>覆盖），缓冲区在系统负载不重的情况下可以增长到这个值；第三个值是发送缓冲区空间的最大字节数（该值会被<code>wmem_max</code>覆盖）。</td><td>4096 16384 3970528</td><td></td></tr><tr><td><code>net.ipv4.tcp_keepalive_time</code></td><td>TCP发送keepalive探测消息的间隔时间（秒），用于确认TCP连接是否有效。</td><td>7200</td><td>1800</td></tr><tr><td><code>net.ipv4.tcp_keepalive_intvl</code></td><td>探测消息未获得响应时，重发该消息的间隔时间（秒）</td><td>75</td><td>30</td></tr><tr><td><code>net.ipv4.tcp_keepalive_probes</code></td><td>在认定TCP连接失效之前，最多发送多少个keepalive探测消息。</td><td>9</td><td>3</td></tr><tr><td><code>net.ipv4.tcp_sack</code></td><td>启用有选择的应答（1表示启用），通过有选择地应答乱序接收到的报文来提高性能，让发送者只发送丢失的报文段，（对于广域网通信来说）这个选项应该启用，但是会增加对CPU的占用。</td><td>1</td><td>1</td></tr><tr><td><code>net.ipv4.tcp_fack</code></td><td>启用转发应答，可以进行有选择应答（SACK）从而减少拥塞情况的发生，这个选项也应该启用。</td><td>1</td><td>1</td></tr><tr><td><code>net.ipv4.tcp_timestamps</code></td><td>TCP时间戳（会在TCP包头增加12个字节），以一种比重发超时更精确的方法（参考RFC 1323）来启用对RTT 的计算，为实现更好的性能应该启用这个选项。</td><td>1</td><td>1</td></tr><tr><td><code>net.ipv4.tcp_window_scaling</code></td><td>启用RFC 1323定义的window scaling，要支持超过64KB的TCP窗口，必须启用该值（1表示启用），TCP窗口最大至1GB，TCP连接双方都启用时才生效。</td><td>1</td><td>1</td></tr><tr><td><code>net.ipv4.tcp_syncookies</code></td><td>表示是否打开TCP同步标签（syncookie），内核必须打开了<code>CONFIG_SYN_COOKIES</code>项进行编译，同步标签可以防止一个套接字在有过多试图连接到达时引起过载。</td><td>1</td><td>1</td></tr><tr><td><code>net.ipv4.tcp_tw_reuse</code></td><td>表示是否允许将处于TIME-WAIT状态的socket（TIME-WAIT的端口）用于新的TCP连接 。</td><td>0</td><td>1</td></tr><tr><td><code>net.ipv4.tcp_tw_recycle</code></td><td>能够更快地回收TIME-WAIT套接字。</td><td>0</td><td>1</td></tr><tr><td><code>net.ipv4.tcp_fin_timeout</code></td><td>对于本端断开的socket连接，TCP保持在FIN-WAIT-2状态的时间（秒）。对方可能会断开连接或一直不结束连接或不可预料的进程死亡。</td><td>60</td><td>30</td></tr><tr><td><code>net.ipv4.ip_local_port_range</code></td><td>表示TCP/UDP协议允许使用的本地端口号</td><td>32768 60999</td><td>1024 65000</td></tr><tr><td><code>net.ipv4.tcp_max_syn_backlog</code></td><td>对于还未获得对方确认的连接请求，可保存在队列中的最大数目。如果服务器经常出现过载，可以尝试增加这个数字。</td><td>128</td><td></td></tr><tr><td><code>net.ipv4.tcp_low_latency</code></td><td>允许TCP/IP栈适应在高吞吐量情况下低延时的情况，这个选项应该禁用。</td><td>0</td><td>0</td></tr></tbody></table><h2 id="arp相关" tabindex="-1"><a class="header-anchor" href="#arp相关"><span>ARP相关</span></a></h2><h3 id="arp回收" tabindex="-1"><a class="header-anchor" href="#arp回收"><span>ARP回收</span></a></h3><ul><li><code>gc_stale_time</code> 每次检查neighbour记录的有效性的周期。当neighbour记录失效时，将在给它发送数据前再解析一次。缺省值是60秒。</li><li><code>gc_thresh1</code> 存在于ARP高速缓存中的最少记录数，如果少于这个数，垃圾收集器将不会运行。缺省值是128。</li><li><code>gc_thresh2</code> 存在 ARP 高速缓存中的最多的记录软限制。垃圾收集器在开始收集前，允许记录数超过这个数字 5 秒。缺省值是 512。</li><li><code>gc_thresh3</code> 保存在 ARP 高速缓存中的最多记录的硬限制，一旦高速缓存中的数目高于此，垃圾收集器将马上运行。缺省值是1024。</li></ul><p>比如可以增大为</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>net.ipv4.neigh.default.gc_thresh1=1024</span></span>
<span class="line"><span>net.ipv4.neigh.default.gc_thresh2=4096</span></span>
<span class="line"><span>net.ipv4.neigh.default.gc_thresh3=8192</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="arp过滤" tabindex="-1"><a class="header-anchor" href="#arp过滤"><span>ARP过滤</span></a></h3><p>arp_filter - BOOLEAN</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>1 - Allows you to have multiple network interfaces on the same</span></span>
<span class="line"><span>subnet, and have the ARPs for each interface be answered</span></span>
<span class="line"><span>based on whether or not the kernel would route a packet from</span></span>
<span class="line"><span>the ARP&#39;d IP out that interface (therefore you must use source</span></span>
<span class="line"><span>based routing for this to work). In other words it allows control</span></span>
<span class="line"><span>of which cards (usually 1) will respond to an arp request.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>0 - (default) The kernel can respond to arp requests with addresses</span></span>
<span class="line"><span>from other interfaces. This may seem wrong but it usually makes</span></span>
<span class="line"><span>sense, because it increases the chance of successful communication.</span></span>
<span class="line"><span>IP addresses are owned by the complete host on Linux, not by</span></span>
<span class="line"><span>particular interfaces. Only for more complex setups like load-</span></span>
<span class="line"><span>balancing, does this behaviour cause problems.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>arp_filter for the interface will be enabled if at least one of</span></span>
<span class="line"><span>conf/{all,interface}/arp_filter is set to TRUE,</span></span>
<span class="line"><span>it will be disabled otherwise</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>arp_announce - INTEGER</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Define different restriction levels for announcing the local</span></span>
<span class="line"><span>source IP address from IP packets in ARP requests sent on</span></span>
<span class="line"><span>interface:</span></span>
<span class="line"><span>0 - (default) Use any local address, configured on any interface</span></span>
<span class="line"><span>1 - Try to avoid local addresses that are not in the target&#39;s</span></span>
<span class="line"><span>subnet for this interface. This mode is useful when target</span></span>
<span class="line"><span>hosts reachable via this interface require the source IP</span></span>
<span class="line"><span>address in ARP requests to be part of their logical network</span></span>
<span class="line"><span>configured on the receiving interface. When we generate the</span></span>
<span class="line"><span>request we will check all our subnets that include the</span></span>
<span class="line"><span>target IP and will preserve the source address if it is from</span></span>
<span class="line"><span>such subnet. If there is no such subnet we select source</span></span>
<span class="line"><span>address according to the rules for level 2.</span></span>
<span class="line"><span>2 - Always use the best local address for this target.</span></span>
<span class="line"><span>In this mode we ignore the source address in the IP packet</span></span>
<span class="line"><span>and try to select local address that we prefer for talks with</span></span>
<span class="line"><span>the target host. Such local address is selected by looking</span></span>
<span class="line"><span>for primary IP addresses on all our subnets on the outgoing</span></span>
<span class="line"><span>interface that include the target IP address. If no suitable</span></span>
<span class="line"><span>local address is found we select the first local address</span></span>
<span class="line"><span>we have on the outgoing interface or on all other interfaces,</span></span>
<span class="line"><span>with the hope we will receive reply for our request and</span></span>
<span class="line"><span>even sometimes no matter the source IP address we announce.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>The max value from conf/{all,interface}/arp_announce is used.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Increasing the restriction level gives more chance for</span></span>
<span class="line"><span>receiving answer from the resolved target while decreasing</span></span>
<span class="line"><span>the level announces more valid sender&#39;s information.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>arp_ignore - INTEGER</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Define different modes for sending replies in response to</span></span>
<span class="line"><span>received ARP requests that resolve local target IP addresses:</span></span>
<span class="line"><span>0 - (default): reply for any local target IP address, configured</span></span>
<span class="line"><span>on any interface</span></span>
<span class="line"><span>1 - reply only if the target IP address is local address</span></span>
<span class="line"><span>configured on the incoming interface</span></span>
<span class="line"><span>2 - reply only if the target IP address is local address</span></span>
<span class="line"><span>configured on the incoming interface and both with the</span></span>
<span class="line"><span>sender&#39;s IP address are part from same subnet on this interface</span></span>
<span class="line"><span>3 - do not reply for local addresses configured with scope host,</span></span>
<span class="line"><span>only resolutions for global and link addresses are replied</span></span>
<span class="line"><span>4-7 - reserved</span></span>
<span class="line"><span>8 - do not reply for all local addresses</span></span>
<span class="line"><span></span></span>
<span class="line"><span>The max value from conf/{all,interface}/arp_ignore is used</span></span>
<span class="line"><span>when ARP request is received on the {interface}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>arp_notify - BOOLEAN</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Define mode for notification of address and device changes.</span></span>
<span class="line"><span>0 - (default): do nothing</span></span>
<span class="line"><span>1 - Generate gratuitous arp requests when device is brought up</span></span>
<span class="line"><span>    or hardware address changes.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>arp_accept - BOOLEAN</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Define behavior for gratuitous ARP frames who&#39;s IP is not</span></span>
<span class="line"><span>already present in the ARP table:</span></span>
<span class="line"><span>0 - don&#39;t create new entries in the ARP table</span></span>
<span class="line"><span>1 - create new entries in the ARP table</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Both replies and requests type gratuitous arp will trigger the</span></span>
<span class="line"><span>ARP table to be updated, if this setting is on.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>If the ARP table already contains the IP address of the</span></span>
<span class="line"><span>gratuitous arp frame, the arp table will be updated regardless</span></span>
<span class="line"><span>if this setting is on or off.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="参考文档" tabindex="-1"><a class="header-anchor" href="#参考文档"><span>参考文档</span></a></h2><ul><li><a href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt" target="_blank" rel="noopener noreferrer">Linux Kernel ip sysctl documentation</a></li></ul>`,41)]))}const c=n(t,[["render",d],["__file","10. 内核网络参数.html.vue"]]),p=JSON.parse('{"path":"/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E4%B8%8B%E5%B1%82%E7%9B%B8%E5%85%B3/Network/%E3%80%8Asdn-handbook%E3%80%8Btonydeng/03.%20Linux%E7%BD%91%E7%BB%9C/10.%20%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E5%8F%82%E6%95%B0.html","title":"内核中的网络参数","lang":"zh-CN","frontmatter":{"description":"内核中的网络参数 nf_conntrack nf_conntrack是Linux内核连接跟踪的模块，常用在iptables中，比如 可以通过cat /proc/net/nf_conntrack来查看当前跟踪的连接信息，这些信息以哈希形式（用链地址法处理冲突）存在内存中，并且每条记录大约占300B空间。 与nf_conntrack相关的内核参数有三个： ...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E4%B8%8B%E5%B1%82%E7%9B%B8%E5%85%B3/Network/%E3%80%8Asdn-handbook%E3%80%8Btonydeng/03.%20Linux%E7%BD%91%E7%BB%9C/10.%20%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E5%8F%82%E6%95%B0.html"}],["meta",{"property":"og:site_name","content":"MdNote_Public"}],["meta",{"property":"og:title","content":"内核中的网络参数"}],["meta",{"property":"og:description","content":"内核中的网络参数 nf_conntrack nf_conntrack是Linux内核连接跟踪的模块，常用在iptables中，比如 可以通过cat /proc/net/nf_conntrack来查看当前跟踪的连接信息，这些信息以哈希形式（用链地址法处理冲突）存在内存中，并且每条记录大约占300B空间。 与nf_conntrack相关的内核参数有三个： ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-09T07:57:06.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-09T07:57:06.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"内核中的网络参数\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-09T07:57:06.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/MdNote_Public/\\"}]}"]]},"headers":[{"level":1,"title":"内核中的网络参数","slug":"内核中的网络参数","link":"#内核中的网络参数","children":[{"level":2,"title":"nf_conntrack","slug":"nf-conntrack","link":"#nf-conntrack","children":[]},{"level":2,"title":"bridge-nf","slug":"bridge-nf","link":"#bridge-nf","children":[]},{"level":2,"title":"反向路径过滤","slug":"反向路径过滤","link":"#反向路径过滤","children":[]},{"level":2,"title":"TCP相关","slug":"tcp相关","link":"#tcp相关","children":[]},{"level":2,"title":"ARP相关","slug":"arp相关","link":"#arp相关","children":[{"level":3,"title":"ARP回收","slug":"arp回收","link":"#arp回收","children":[]},{"level":3,"title":"ARP过滤","slug":"arp过滤","link":"#arp过滤","children":[]}]},{"level":2,"title":"参考文档","slug":"参考文档","link":"#参考文档","children":[]}]}],"git":{"createdTime":1739087826000,"updatedTime":1739087826000,"contributors":[{"name":"Linc","username":"Linc","email":"762699299@qq.com","commits":1,"url":"https://github.com/Linc"}]},"readingTime":{"minutes":8.59,"words":2578},"filePathRelative":"01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/《sdn-handbook》tonydeng/03. Linux网络/10. 内核网络参数.md","localizedDate":"2025年2月9日","excerpt":"\\n<h2>nf_conntrack</h2>\\n<p><code>nf_conntrack</code>是Linux内核连接跟踪的模块，常用在<code>iptables</code>中，比如</p>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>-A INPUT -m state --state RELATED,ESTABLISHED  -j RETURN</span></span>\\n<span class=\\"line\\"><span>-A INPUT -m state --state INVALID -j DROP</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/《sdn-handbook》tonydeng/03. Linux网络/10. 内核网络参数.md","value":{"title":"10. 内核网络参数","path":"01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/《sdn-handbook》tonydeng/03. Linux网络/10. 内核网络参数.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{c as comp,p as data};
