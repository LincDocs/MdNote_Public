import{_ as h,e as l,j as n,f as a,g as i,h as e,r as d,o as r}from"./app-BL9ADnaS.js";const p={},k={id:"stdfuture创建后台任务并返回值",tabindex:"-1"},o={class:"header-anchor",href:"#stdfuture创建后台任务并返回值"},c={id:"stdasync深入谈",tabindex:"-1"},A={class:"header-anchor",href:"#stdasync深入谈"},y={id:"stdthread的区别",tabindex:"-1"},g={class:"header-anchor",href:"#stdthread的区别"},u={id:"带超时的互斥量stdrecursive-timed-mutex",tabindex:"-1"},m={class:"header-anchor",href:"#带超时的互斥量stdrecursive-timed-mutex"};function f(B,s){const t=d("VPIcon");return r(),l("div",null,[s[8]||(s[8]=n('<h1 id="线程的其他补充" tabindex="-1"><a class="header-anchor" href="#线程的其他补充"><span>线程的其他补充</span></a></h1><h1 id="condition-variable、wait、notify-one、notify-all" tabindex="-1"><a class="header-anchor" href="#condition-variable、wait、notify-one、notify-all"><span>Condition_variable、wait、notify_one、notify_all</span></a></h1><h2 id="条件变量std-condition、wdit-、notify-one" tabindex="-1"><a class="header-anchor" href="#条件变量std-condition、wdit-、notify-one"><span>条件变量std::condition、wdit()、notify_one()</span></a></h2><h2 id="上述代码深入思考" tabindex="-1"><a class="header-anchor" href="#上述代码深入思考"><span>上述代码深入思考</span></a></h2><h2 id="notify-all" tabindex="-1"><a class="header-anchor" href="#notify-all"><span>notify_all</span></a></h2><h1 id="async、future、packaged-task、promise" tabindex="-1"><a class="header-anchor" href="#async、future、packaged-task、promise"><span>async、future、packaged_task、promise</span></a></h1>',6)),a("h2",k,[a("a",o,[a("span",null,[s[0]||(s[0]=i("std")),e(t,{icon:"async、std"}),s[1]||(s[1]=i("future创建后台任务并返回值"))])])]),s[9]||(s[9]=n('<h2 id="std-packaged-task" tabindex="-1"><a class="header-anchor" href="#std-packaged-task"><span>std::packaged_task</span></a></h2><h2 id="std-promise" tabindex="-1"><a class="header-anchor" href="#std-promise"><span>std::promise</span></a></h2><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结</span></a></h2><h1 id="future其他成员函数、shared-future、atomic" tabindex="-1"><a class="header-anchor" href="#future其他成员函数、shared-future、atomic"><span>future其他成员函数、shared_future、atomic</span></a></h1><h2 id="std-future的其他成员函数" tabindex="-1"><a class="header-anchor" href="#std-future的其他成员函数"><span>std::future的其他成员函数</span></a></h2><h2 id="std-shared-future" tabindex="-1"><a class="header-anchor" href="#std-shared-future"><span>std::shared_future</span></a></h2><h2 id="原子操作std-atomic" tabindex="-1"><a class="header-anchor" href="#原子操作std-atomic"><span>原子操作std::atomic</span></a></h2><h3 id="原子操作概念引出范例" tabindex="-1"><a class="header-anchor" href="#原子操作概念引出范例"><span>原子操作概念引出范例</span></a></h3><h3 id="基本的std-atomic用法范例" tabindex="-1"><a class="header-anchor" href="#基本的std-atomic用法范例"><span>基本的std::atomic用法范例</span></a></h3><h3 id="心得总结" tabindex="-1"><a class="header-anchor" href="#心得总结"><span>心得总结</span></a></h3>',10)),a("h1",c,[a("a",A,[a("span",null,[s[2]||(s[2]=i("std")),e(t,{icon:"atomic续谈、std"}),s[3]||(s[3]=i("async深入谈"))])])]),s[10]||(s[10]=n('<h2 id="原子操作std-atomic续谈" tabindex="-1"><a class="header-anchor" href="#原子操作std-atomic续谈"><span>原子操作std::atomic续谈</span></a></h2><h2 id="深入谈std-async" tabindex="-1"><a class="header-anchor" href="#深入谈std-async"><span>深入谈std::async</span></a></h2><h3 id="std-async参数详述" tabindex="-1"><a class="header-anchor" href="#std-async参数详述"><span>std::async参数详述</span></a></h3>',3)),a("h3",y,[a("a",g,[a("span",null,[s[4]||(s[4]=i("std")),e(t,{icon:"async和std"}),s[5]||(s[5]=i("thread的区别"))])])]),s[11]||(s[11]=n('<h3 id="std-async不确定性问题的解决" tabindex="-1"><a class="header-anchor" href="#std-async不确定性问题的解决"><span>std::async不确定性问题的解决</span></a></h3><h1 id="windows临界区、其他各种mutex互斥量" tabindex="-1"><a class="header-anchor" href="#windows临界区、其他各种mutex互斥量"><span>windows临界区、其他各种mutex互斥量</span></a></h1><h2 id="windows临界区" tabindex="-1"><a class="header-anchor" href="#windows临界区"><span>windows临界区</span></a></h2><h2 id="多次进入临界区试验" tabindex="-1"><a class="header-anchor" href="#多次进入临界区试验"><span>多次进入临界区试验</span></a></h2><h2 id="自动析构技术" tabindex="-1"><a class="header-anchor" href="#自动析构技术"><span>自动析构技术</span></a></h2><h2 id="recursive-mutex递归的独占互斥量" tabindex="-1"><a class="header-anchor" href="#recursive-mutex递归的独占互斥量"><span>recursive_mutex递归的独占互斥量</span></a></h2>',6)),a("h2",u,[a("a",m,[a("span",null,[s[6]||(s[6]=i("带超时的互斥量std")),e(t,{icon:"timed_mutex和std"}),s[7]||(s[7]=i("recursive_timed_mutex"))])])]),s[12]||(s[12]=n(`<h1 id="补充知识、线程池浅谈、数量谈、总结" tabindex="-1"><a class="header-anchor" href="#补充知识、线程池浅谈、数量谈、总结"><span>补充知识、线程池浅谈、数量谈、总结</span></a></h1><h2 id="补充知识点" tabindex="-1"><a class="header-anchor" href="#补充知识点"><span>补充知识点</span></a></h2><h3 id="虚假唤醒" tabindex="-1"><a class="header-anchor" href="#虚假唤醒"><span>虚假唤醒</span></a></h3><h3 id="atomic" tabindex="-1"><a class="header-anchor" href="#atomic"><span>atomic</span></a></h3><h2 id="浅谈线程池" tabindex="-1"><a class="header-anchor" href="#浅谈线程池"><span>浅谈线程池</span></a></h2><h3 id="场景设想" tabindex="-1"><a class="header-anchor" href="#场景设想"><span>场景设想</span></a></h3><h3 id="实现方式" tabindex="-1"><a class="header-anchor" href="#实现方式"><span>实现方式</span></a></h3><h2 id="线程创建数量谈" tabindex="-1"><a class="header-anchor" href="#线程创建数量谈"><span>线程创建数量谈</span></a></h2><h2 id="c-11多线程总结" tabindex="-1"><a class="header-anchor" href="#c-11多线程总结"><span>C++11多线程总结</span></a></h2><h1 id="多线程-线程的其他补充" tabindex="-1"><a class="header-anchor" href="#多线程-线程的其他补充"><span>多线程 - 线程的其他补充</span></a></h1><h2 id="线程操作补充" tabindex="-1"><a class="header-anchor" href="#线程操作补充"><span>线程操作补充</span></a></h2><h3 id="自带锁的数据-新版list" tabindex="-1"><a class="header-anchor" href="#自带锁的数据-新版list"><span>自带锁的数据 - 新版list</span></a></h3><h2 id="线程管理" tabindex="-1"><a class="header-anchor" href="#线程管理"><span>线程管理</span></a></h2><h3 id="线程id" tabindex="-1"><a class="header-anchor" href="#线程id"><span>线程id</span></a></h3><p>线程id</p><ul><li>线程id可以通过<code>std::this_thread::get_id();</code>来获取</li></ul><h3 id="踩坑问题" tabindex="-1"><a class="header-anchor" href="#踩坑问题"><span>踩坑问题</span></a></h3><h4 id="引用问题" tabindex="-1"><a class="header-anchor" href="#引用问题"><span>引用问题</span></a></h4><p>例程：</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;iostream&gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;thread&gt;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">			// 线程头文件</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">using</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> namespace</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> std</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> TA</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public:</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;"> &amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">m_i;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">				// 【新增】引用对象</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    TA</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> &amp;</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">):</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">m_i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(i) {}</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">	// 【新增】构造函数</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    void</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> operator</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()()</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">		// 线程的初始函数（类成员函数），不能带参数！！！</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    { </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        cout </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;子线程&quot;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> &lt;&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> endl;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        cout </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;m_i：&quot;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> &lt;&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> m_i </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> endl;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">	// 【新增】每次输出时m_i的值都不一样 </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}    </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">					// main函数，主线程的初始函数</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{  </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> myi </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 6</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">			// 【新增】 </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    Ta </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ta</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(myi);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">				// 【修改】传入引用对象 </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    /* std::thread mythread(Ta()); // 这里用匿名对象也是可以的 */</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    std::thread </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">mythread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(ta);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">	// 函数、类、Lambda都是可调用对象 </span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    mythread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">detach</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();       </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    cout </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;主线程&quot;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> &lt;&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> endl; </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Q：为什么每次输出时m_i的值都不一样</p><p>A：原因：detach后主线程执行完后，m_i的内存被回收销毁，此时m_i的内存的值不可控</p><h4 id="对象拷贝问题" tabindex="-1"><a class="header-anchor" href="#对象拷贝问题"><span>对象拷贝问题</span></a></h4><p>Q：使用detach()后，当主线程结束对象被销毁，子线程还能使用这个对象的成员函数吗</p><p>A：对象会被复制到线程中生成新对象<br> 前面的例程从开始到结束发生了：一次构造函数、一次拷贝构造函数、两次析构函数<br> （这里拷贝构造函数默认是浅拷贝，对象中有引用对象的要注意重写复制构造函数来深拷贝，否则会发生前面的问题）</p><h2 id="thread源码分析" tabindex="-1"><a class="header-anchor" href="#thread源码分析"><span>Thread源码分析</span></a></h2><p>构造函数是一个右值引用的可变参数模板，接受右值参数</p><p>其他暂略</p><h1 id="_00" tabindex="-1"><a class="header-anchor" href="#_00"><span>00</span></a></h1>`,29))])}const v=h(p,[["render",f],["__file","10. 线程的其他补充.html.vue"]]),F=JSON.parse('{"path":"/01.%20DesignAndDevelop/Develop/01.%20Language/C__/04.%20%E4%BC%98%E5%8C%96/%E5%A4%9A%E7%BA%BF%E7%A8%8B/10.%20%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B6%E4%BB%96%E8%A1%A5%E5%85%85.html","title":"线程的其他补充","lang":"zh-CN","frontmatter":{"description":"线程的其他补充 Condition_variable、wait、notify_one、notify_all 条件变量std::condition、wdit()、notify_one() 上述代码深入思考 notify_all async、future、packaged_task、promise std std::packaged_task std::p...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/01.%20Language/C__/04.%20%E4%BC%98%E5%8C%96/%E5%A4%9A%E7%BA%BF%E7%A8%8B/10.%20%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B6%E4%BB%96%E8%A1%A5%E5%85%85.html"}],["meta",{"property":"og:site_name","content":"MdNote_Public"}],["meta",{"property":"og:title","content":"线程的其他补充"}],["meta",{"property":"og:description","content":"线程的其他补充 Condition_variable、wait、notify_one、notify_all 条件变量std::condition、wdit()、notify_one() 上述代码深入思考 notify_all async、future、packaged_task、promise std std::packaged_task std::p..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-09T04:27:21.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-09T04:27:21.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"线程的其他补充\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-09T04:27:21.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/MdNote_Public/\\"}]}"]]},"git":{"createdTime":1741494441000,"updatedTime":1741494441000,"contributors":[{"name":"Linc","username":"Linc","email":"762699299@qq.com","commits":1,"url":"https://github.com/Linc"}]},"readingTime":{"minutes":2.28,"words":685},"filePathRelative":"01. DesignAndDevelop/Develop/01. Language/C++/04. 优化/多线程/10. 线程的其他补充.md","localizedDate":"2025年3月9日","excerpt":"\\n<h1>Condition_variable、wait、notify_one、notify_all</h1>\\n<h2>条件变量std::condition、wdit()、notify_one()</h2>\\n<h2>上述代码深入思考</h2>\\n<h2>notify_all</h2>\\n<h1>async、future、packaged_task、promise</h1>\\n<h2>std</h2>\\n<h2>std::packaged_task</h2>\\n<h2>std::promise</h2>\\n<h2>小结</h2>\\n<h1>future其他成员函数、shared_future、atomic</h1>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"01. DesignAndDevelop/Develop/01. Language/C++/04. 优化/多线程/10. 线程的其他补充.md","value":{"title":"10. 线程的其他补充","path":"01. DesignAndDevelop/Develop/01. Language/C++/04. 优化/多线程/10. 线程的其他补充.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{v as comp,F as data};
