import{_ as B,c as p,a as l,f as i,b as t,d as n,e as r,r as E,o as s}from"./app-Cy4VlaP7.js";const u={};function A(d,e){const o=E("RouteLink"),a=E("Mermaid");return s(),p("div",null,[e[13]||(e[13]=l("h1",{id:"竞争算法",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#竞争算法"},[l("span",null,"竞争算法")])],-1)),e[14]||(e[14]=l("p",null,"详细见：",-1)),l("ul",null,[l("li",null,[e[1]||(e[1]=t("线程冲突：")),n(o,{to:"/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/01.%20%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/03.%20%E7%BA%BF%E7%A8%8B%E5%86%B2%E7%AA%81/"},{default:r(()=>e[0]||(e[0]=[t("../../03. 计算机系统 - 线性学习版/01. 图解系统/03. 线程冲突/")])),_:1})]),l("li",null,[e[3]||(e[3]=t("Cache冲突：")),n(o,{to:"/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E4%B8%8B%E5%B1%82%E7%9B%B8%E5%85%B3/Network/%E3%80%8ANFV%E7%9A%84%E5%9F%BA%E7%9F%B3_%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADPDK%E3%80%8B/02.%20Cache%E5%92%8C%E5%86%85%E5%AD%98/06.%20Cache%E4%B8%80%E8%87%B4%E6%80%A7.html"},{default:r(()=>e[2]||(e[2]=[t("../下层相关/Network/《NFV的基石_深入浅出DPDK》/02. Cache和内存/06. Cache一致性.md")])),_:1})])]),e[15]||(e[15]=i('<h2 id="竞争冲突算法-vs-竞争调度算法" tabindex="-1"><a class="header-anchor" href="#竞争冲突算法-vs-竞争调度算法"><span>竞争冲突算法 vs 竞争调度算法</span></a></h2><p>这两个词的前缀 “竞争” 我是加上的，这两个东西其实都是一种 “竞争”，但本质大有不同：</p><ul><li><p>调度算法：<em>多个任务去竞争一个处理器 / 多个数据去竞争一块内存</em>。竞争的结果是用算法去计算竞争者的<strong>优先级</strong>。</p></li><li><p>竞争算法：<em>多个处理器核/线程去竞争一个资源 (内存/Cache等)</em>，和上面反过来。竞争的结果是<strong>错峰避免同时使用</strong>。</p><p>竞争算法也可以说是<strong>一致性算法</strong> (Cache一致性或者是其他的什么一致性)</p></li></ul><h2 id="竞争冲突" tabindex="-1"><a class="header-anchor" href="#竞争冲突"><span>竞争冲突</span></a></h2><h3 id="情景" tabindex="-1"><a class="header-anchor" href="#情景"><span>情景</span></a></h3><p>按多线程还是多核引起分类：</p>',6)),l("ul",null,[e[11]||(e[11]=l("li",null,[l("p",null,"多线程冲突"),l("ul",null,[l("li",null,[t("普通内存冲突，可以是"),l("strong",null,"寄存器与内存不一致"),t("冲突 "),l("ul",null,[l("li",null,[l("em",null,"锁"),t("：加锁、解锁操作（Test-and-Set 原子指令）")]),l("li",null,[l("em",null,"信号量"),t("：P、V 操作（P、V 原子指令）")])])])])],-1)),l("li",null,[e[10]||(e[10]=l("p",null,"多核冲突",-1)),l("ul",null,[e[8]||(e[8]=i("<li><p>**Cache与内存不一致 (Cache一致性)**问题。<em>一致性算法</em>：</p><ul><li>低性能错误方案： 不独占Cache</li><li>DPDK方法： 避免多个数据备份、避免多个核访问同一内存地址 <ul><li>多个核同时需要一些数据结构，为每个核都单独定义一份</li><li>多个核访问同一个网卡的接收队列/发送队列，为每个核都准备一个单独的接收队列/发送队列</li></ul></li><li>基于目录的协议（Directory-based protocol）： 全局统一管理</li><li>总线窥探协议（Bus snooping protocol）： 利用总线进行的分布式的广播和被通知</li><li>Snarfing协议： 在此不作讨论</li></ul></li>",1)),l("li",null,[e[4]||(e[4]=l("p",null,[l("strong",null,"寄存器与内存不一致"),t("冲突、即寄存器一致性问题？")],-1)),e[5]||(e[5]=l("p",null,[l("em",null,"（不一定存在。如果寄存器和Cache的数据交换是原子性的，那么不存在这个问题。问题保留，待验证）")],-1)),e[6]||(e[6]=l("p",null,"如果存在，但本质上感觉和Cache一致性是一个原理。Cache一致性能用的，对于寄存器内存应该也能用。",-1)),e[7]||(e[7]=l("p",null,"区别应该就只有对于三级Cache，不存在Cache一致性问题，只存在寄存器一致性问题。",-1)),n(a,{id:"mermaid-135",code:"eJxLL0osyFAIceLiKi5NgnCcA0LjnfOLUuMNuZ6ub3m6dsbTmSsMo+FMq8RnM9YbGsVyOScmZ6QaGkY/2dHwfNdyMA9Vzggot6sHJheLZJquni5UBbKgLkTQ0JArNS+FC2KGMdD4TnxGGCPEjBBiWHxjhKQQwzdP9q97NmXnkx27QFwjE5jnjLB4DrtSI6BSrH41gnsL2QHwADCC+PVpWytQJhpCoYcw0ASIBMxVaAJGoMBAEQCZjyxgjOADAA+J404="})]),e[9]||(e[9]=l("li",null,[l("p",null,"内存冲突、内存一致性问题？"),l("p",null,[l("em",null,"（不一定存在。感觉应该不会出现多个内存去缓存同一个硬盘数据的情况，那么就不存在这个问题。问题保留，待验证）"),t(" （搜了下好像是有这么个概念，但可能和我想象中的不同）")]),l("ul",null,[l("li",null,"CPU Cache缓存的是内存数据，内存缓存的是硬盘数据")])],-1))])]),e[12]||(e[12]=i("<li><p>网络并发 (Server端多协程/线程/进程都有可能)</p><ul><li>MySQL的<em>并发</em>导致<strong>用户获取和数据库不一致 (事务隔离性)</strong>：MySQL 的 MVCC（Multi-Version Concurrency Control，多版本并发控制）</li><li>Redis缓存和数据库保证一致性。<em>并发</em>以及缓存和数据库修改先后的问题，可能导致<strong>数据库和缓存不一致</strong>问题。</li><li><strong>Redis集群的一致性</strong>：主从模式、哨兵模式、切片集群模式</li></ul></li>",1))]),e[16]||(e[16]=i('<h3 id="情景-总结" tabindex="-1"><a class="header-anchor" href="#情景-总结"><span>情景 - 总结</span></a></h3><p>共同点：</p><ul><li>几乎都是<em>并发引起</em>的</li><li>几乎都是<em>两个存储空间的一致性</em>问题</li><li>几乎都是<em>双写一致性</em>的问题（例外：<em>读写一致性</em>也可能有问题，这种一般通过过期时间来解决）</li></ul><h3 id="解决方法" tabindex="-1"><a class="header-anchor" href="#解决方法"><span>解决方法</span></a></h3><ul><li>多线程冲突 <ul><li>基本通过原子操作解决 (锁/信号量)，避免指令乱序</li></ul></li><li>一致性冲突 (多个数据备份) <ul><li>通过全局统一管理</li><li>分布式的广播/被广播</li></ul></li><li>其他 <ul><li>MySQL 的 MVCC（Multi-Version Concurrency Control，多版本并发控制）</li></ul></li></ul><h3 id="解决方法-总结" tabindex="-1"><a class="header-anchor" href="#解决方法-总结"><span>解决方法 - 总结</span></a></h3><p>共同点：</p><ul><li>（待总结）</li></ul><h2 id="其他-杂项" tabindex="-1"><a class="header-anchor" href="#其他-杂项"><span>其他？杂项？</span></a></h2><p>（<strong>GPT</strong>）</p><blockquote><ul><li>共享内存</li><li>总线</li><li>互斥锁</li><li>IO设备</li><li>其他共享资源 <ul><li>信号量 <ul><li>事件</li><li>队列</li></ul></li></ul></li></ul><p>方法</p><ul><li><strong>锁优化：</strong> 使用更细粒度的锁、自旋锁、读写锁等技术来减少锁竞争。</li><li><strong>无锁算法：</strong> 采用无锁或无等待的数据结构和算法，避免使用锁。</li><li><strong>缓存优化：</strong> 使用缓存一致性协议、伪共享填充等技术来提高缓存利用率。</li><li><strong>线程池：</strong> 通过线程池管理线程，避免线程频繁创建和销毁。</li><li><strong>异步I/O：</strong> 使用异步I/O操作，避免线程阻塞。</li><li><strong>负载均衡：</strong> 将任务均匀分配给各个核心，避免单个核心负载过重。</li></ul></blockquote><blockquote><p>我有一个疑问，Cache一致性那里有三个前提条件。但这里不考虑寄存器的吗？为什么限制了那么多原因？我感觉非独占Cache也会出现问题啊，多核是独占寄存器的啊。</p><p>目前我个人的理解是，也会有冲突，但这种冲突不叫 “Cache一致性的竞争冲突”，而是别的冲突，姑且叫 “寄存器的竞争冲突” 好了。</p><p>不确定</p></blockquote>',12))])}const m=B(u,[["render",A],["__file","竞争冲突算法.html.vue"]]),D=JSON.parse('{"path":"/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E5%85%B6%E4%BB%96%E6%8A%BD%E8%B1%A1/%E7%AB%9E%E4%BA%89%E5%86%B2%E7%AA%81%E7%AE%97%E6%B3%95.html","title":"竞争算法","lang":"zh-CN","frontmatter":{"description":"竞争算法 详细见： 线程冲突： Cache冲突： 竞争冲突算法 vs 竞争调度算法 这两个词的前缀 “竞争” 我是加上的，这两个东西其实都是一种 “竞争”，但本质大有不同： 调度算法：多个任务去竞争一个处理器 / 多个数据去竞争一块内存。竞争的结果是用算法去计算竞争者的优先级。 竞争算法：多个处理器核/线程去竞争一个资源 (内存/Cache等)，和上面...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E5%85%B6%E4%BB%96%E6%8A%BD%E8%B1%A1/%E7%AB%9E%E4%BA%89%E5%86%B2%E7%AA%81%E7%AE%97%E6%B3%95.html"}],["meta",{"property":"og:site_name","content":"MdNote_Public"}],["meta",{"property":"og:title","content":"竞争算法"}],["meta",{"property":"og:description","content":"竞争算法 详细见： 线程冲突： Cache冲突： 竞争冲突算法 vs 竞争调度算法 这两个词的前缀 “竞争” 我是加上的，这两个东西其实都是一种 “竞争”，但本质大有不同： 调度算法：多个任务去竞争一个处理器 / 多个数据去竞争一块内存。竞争的结果是用算法去计算竞争者的优先级。 竞争算法：多个处理器核/线程去竞争一个资源 (内存/Cache等)，和上面..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-03T08:19:47.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-03T08:19:47.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"竞争算法\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-03T08:19:47.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/MdNote_Public/\\"}]}"]]},"headers":[{"level":1,"title":"竞争算法","slug":"竞争算法","link":"#竞争算法","children":[{"level":2,"title":"竞争冲突算法 vs 竞争调度算法","slug":"竞争冲突算法-vs-竞争调度算法","link":"#竞争冲突算法-vs-竞争调度算法","children":[]},{"level":2,"title":"竞争冲突","slug":"竞争冲突","link":"#竞争冲突","children":[{"level":3,"title":"情景","slug":"情景","link":"#情景","children":[]},{"level":3,"title":"情景 - 总结","slug":"情景-总结","link":"#情景-总结","children":[]},{"level":3,"title":"解决方法","slug":"解决方法","link":"#解决方法","children":[]},{"level":3,"title":"解决方法 - 总结","slug":"解决方法-总结","link":"#解决方法-总结","children":[]}]},{"level":2,"title":"其他？杂项？","slug":"其他-杂项","link":"#其他-杂项","children":[]}]}],"git":{"createdTime":1738570787000,"updatedTime":1738570787000,"contributors":[{"name":"Linc","username":"Linc","email":"762699299@qq.com","commits":1,"url":"https://github.com/Linc"}]},"readingTime":{"minutes":4.85,"words":1454},"filePathRelative":"01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/其他抽象/竞争冲突算法.md","localizedDate":"2025年2月3日","excerpt":"\\n<p>详细见：</p>\\n<ul>\\n<li>线程冲突：<a href=\\"/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/01.%20%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/03.%20%E7%BA%BF%E7%A8%8B%E5%86%B2%E7%AA%81/\\" target=\\"_blank\\">../../03. 计算机系统 - 线性学习版/01. 图解系统/03. 线程冲突/</a></li>\\n<li>Cache冲突：<a href=\\"/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E4%B8%8B%E5%B1%82%E7%9B%B8%E5%85%B3/Network/%E3%80%8ANFV%E7%9A%84%E5%9F%BA%E7%9F%B3_%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADPDK%E3%80%8B/02.%20Cache%E5%92%8C%E5%86%85%E5%AD%98/06.%20Cache%E4%B8%80%E8%87%B4%E6%80%A7.html\\" target=\\"_blank\\">../下层相关/Network/《NFV的基石_深入浅出DPDK》/02. Cache和内存/06. Cache一致性.md</a></li>\\n</ul>","autoDesc":true,"bioChainData":{"outlink":[{"title":"06. Cache一致性","link":"01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/《NFV的基石_深入浅出DPDK》/02. Cache和内存/06. Cache一致性.html"}],"backlink":[],"localMap":{"nodes":[{"id":"01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/其他抽象/竞争冲突算法.md","value":{"title":"竞争冲突算法","path":"01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/其他抽象/竞争冲突算法.md","outlink":["01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/《NFV的基石_深入浅出DPDK》/02. Cache和内存/06. Cache一致性.md"],"backlink":[]}},{"id":"01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/《NFV的基石_深入浅出DPDK》/02. Cache和内存/06. Cache一致性.md","value":{"title":"06. Cache一致性","path":"01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/《NFV的基石_深入浅出DPDK》/02. Cache和内存/06. Cache一致性.md","outlink":[],"backlink":[]}}],"links":[{"source":"01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/其他抽象/竞争冲突算法.md","target":"01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/《NFV的基石_深入浅出DPDK》/02. Cache和内存/06. Cache一致性.md"}]}}}');export{m as comp,D as data};
