import{_ as r,c as t,b as o,o as l}from"./app-BvVwUQfW.js";const a={};function n(i,e){return l(),t("div",null,[...e[0]||(e[0]=[o('<h1 id="日常开发常用库" tabindex="-1">日常开发常用库</h1><h2 id="目录索引" tabindex="-1">目录索引</h2><ul><li><a href="https://rusty.course.rs/awesome-daily-dev.html#%E5%A4%9A%E7%BA%BF%E7%A8%8B" target="_blank" rel="noopener noreferrer">多线程</a></li><li><a href="https://rusty.course.rs/awesome-daily-dev.html#webhttp" target="_blank" rel="noopener noreferrer">Web/HTTP</a>, <a href="https://rusty.course.rs/awesome-daily-dev.html#SQL%E5%AE%A2%E6%88%B7%E7%AB%AF" target="_blank" rel="noopener noreferrer">SQL客户端</a>, <a href="https://rusty.course.rs/awesome-daily-dev.html#NoSql%E5%AE%A2%E6%88%B7%E7%AB%AF" target="_blank" rel="noopener noreferrer">NoSql客户端</a>， <a href="https://rusty.course.rs/awesome-daily-dev.html#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener noreferrer">网络通信协议</a>, <a href="https://rusty.course.rs/awesome-daily-dev.html#%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener noreferrer">异步网络编程</a></li><li><a href="https://rusty.course.rs/awesome-daily-dev.html#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0" target="_blank" rel="noopener noreferrer">服务发现</a>, <a href="https://rusty.course.rs/awesome-daily-dev.html#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97" target="_blank" rel="noopener noreferrer">消息队列</a>, <a href="https://rusty.course.rs/awesome-daily-dev.html#%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E" target="_blank" rel="noopener noreferrer">搜索引擎</a></li><li><a href="https://rusty.course.rs/awesome-daily-dev.html#%E7%BC%96%E8%A7%A3%E7%A0%81" target="_blank" rel="noopener noreferrer">编解码</a>, <a href="https://rusty.course.rs/awesome-daily-dev.html#Email" target="_blank" rel="noopener noreferrer">Email</a>, <a href="https://rusty.course.rs/awesome-daily-dev.html#%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E6%A8%A1%E7%89%88" target="_blank" rel="noopener noreferrer">常用正则模版</a></li><li><a href="https://rusty.course.rs/awesome-daily-dev.html#%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7" target="_blank" rel="noopener noreferrer">日志监控</a>, <a href="https://rusty.course.rs/awesome-daily-dev.html#%E4%BB%A3%E7%A0%81Debug" target="_blank" rel="noopener noreferrer">代码Debug</a>, <a href="https://rusty.course.rs/awesome-daily-dev.html#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" target="_blank" rel="noopener noreferrer">性能优化</a></li></ul><h2 id="web-http" tabindex="-1">Web/HTTP</h2><ul><li><p>HTTP客户端</p><ul><li><a href="https://github.com/seanmonstar/reqwest" target="_blank" rel="noopener noreferrer">reqwest</a> 一个简单又强大的HTTP客户端，<code>reqwest</code>是目前使用最多的HTTP库</li></ul></li><li><p>Web框架</p><ul><li><a href="https://github.com/tokio-rs/axum" target="_blank" rel="noopener noreferrer">axum</a> 基于Tokio和Hyper打造，模块化设计较好，目前口碑很好，值得使用Ergonomic and modular web framework built with Tokio, Tower, and Hyper</li><li><a href="https://github.com/SergioBenitez/Rocket" target="_blank" rel="noopener noreferrer">Rocket</a> 功能强大，API简单的Web框架，但是主要开发者目前因为个人原因无法进行后续开发，未来存在不确定性</li><li><a href="https://github.com/actix/actix-web" target="_blank" rel="noopener noreferrer">actix-web</a> 性能极高的Web框架，就是团队内部有些问题，未来存在一定的不确定性</li><li>总体来说，上述三个web框架都有很深的用户基础，其实都可以选用，如果让我推荐，顺序如下: <code>axum</code> &gt; <code>Rocket</code> &gt; <code>actix-web</code>。 不过如果你不需要多么完善的web功能，只需要一个性能极高的http库，那么<code>actix-web</code>是非常好的选择，它的性能非常非常非常高！</li></ul></li></ul><h2 id="日志监控" tabindex="-1">日志监控</h2><ul><li>日志 [<a href="https://crates.io/keywords/log" target="_blank" rel="noopener noreferrer">crates.io</a>] [<a href="https://github.com/search?q=rust+log" target="_blank" rel="noopener noreferrer">github</a>] <ul><li><a href="https://github.com/tokio-rs/tracing" target="_blank" rel="noopener noreferrer">tokio-rs/tracing</a> 强大的日志框架，同时还支持OpenTelemetry格式，无缝打通未来的监控</li><li><a href="https://github.com/rust-lang/log" target="_blank" rel="noopener noreferrer">rust-lang/log</a> 官方日志库，事实上的API标准, 但是三方库未必遵循</li><li><a href="https://github.com/estk/log4rs" target="_blank" rel="noopener noreferrer">estk/log4rs</a> 模仿JAVA <code>logback</code>和<code>log4j</code>实现的日志库, 可配置性较强</li><li>在其它文章中，也许会推荐slog，但是我们不推荐，一个是因为近半年未更新，一个是<code>slog</code>自己也推荐使用<code>tracing</code>。</li></ul></li><li>监控 <ul><li><a href="https://github.com/open-telemetry/opentelemetry-rust" target="_blank" rel="noopener noreferrer">OpenTelemetry</a> <code>OpenTelemetry</code>是现在非常火的可观测性解决方案，提供了协议、API、SDK等核心工具，用于收集监控数据，最后将这些metrics/logs/traces数据写入到<code>prometheus</code>, <code>jaeger</code>等监控平台中。最主要是，它后台很硬，后面有各大公司作为背书，未来非常看好！</li><li><a href="https://github.com/vectordotdev/vector" target="_blank" rel="noopener noreferrer">vectordotdev/vector</a> 一个性能很高的数据采集agent，采集本地的日志、监控等数据，发送到远程的kafka、jaeger等数据下沉端，它最大的优点就是能从多种数据源(包括Opentelemetry)收集数据，然后推送到多个数据处理或者存储等下沉端。</li></ul></li></ul><h2 id="sql客户端" tabindex="-1">SQL客户端</h2><ul><li>性能对比 <ul><li><a href="https://github.com/diesel-rs/metrics" target="_blank" rel="noopener noreferrer">metrics</a> 该库对Rust现存的数据库连接服务进行性能测试，若大家有性能上的需求，值得一看</li></ul></li><li>通用 <ul><li><a href="https://github.com/launchbadge/sqlx" target="_blank" rel="noopener noreferrer">launchbadge/sqlx</a> 异步实现、高性能、纯Rust代码的SQL库，支持<code>PostgreSQL</code>, <code>MySQL</code>, <code>SQLite</code>,和 <code>MSSQL</code>.</li></ul></li><li>ORM <ul><li><a href="https://github.com/rbatis/rbatis" target="_blank" rel="noopener noreferrer">rbatis/rbatis</a> 国内团队开发的ORM，异步、性能高、简单易上手</li><li><a href="https://github.com/diesel-rs/diesel" target="_blank" rel="noopener noreferrer">diesel-rs/diesel</a> 安全、扩展性强的Rust ORM库，支持<code>Mysql</code>、<code>Postgre</code>、<code>SqlLite</code></li></ul></li><li>Mysql <ul><li><a href="https://github.com/blackbeam/rust-mysql-simple" target="_blank" rel="noopener noreferrer">blackbeam/rust-mysql-simple</a> 纯Rust实现的Mysql驱动,提供连接池</li><li><a href="https://github.com/blackbeam/mysql_async" target="_blank" rel="noopener noreferrer">blackbeam/mysql_async</a> 基于Tokio实现的异步Mysql驱动</li><li>上面两个都是一个团队出品，前者文档更全、star更多，建议使用前者</li></ul></li><li>Postgre <ul><li><a href="https://github.com/sfackler/rust-postgres" target="_blank" rel="noopener noreferrer">sfackler/rust-postgres</a> 纯Rust实现的Postgre客户端</li></ul></li><li>Sqlite <ul><li><a href="https://github.com/rusqlite/rusqlite" target="_blank" rel="noopener noreferrer">rusqlite</a> 用于<a href="https://www.sqlite.org/index.html" target="_blank" rel="noopener noreferrer">Sqlite3</a>的Rust客户端</li></ul></li></ul><h2 id="nosql客户端" tabindex="-1">NoSql客户端</h2><ul><li>Redis <ul><li><a href="https://github.com/mitsuhiko/redis-rs" target="_blank" rel="noopener noreferrer">mitsuhiko/redis-rs</a> 虽然最近更新不太活跃，但是它依然是最好的redis客户端，说实话，我期待更好的，可能这也是Rust生态的未来可期之处吧</li></ul></li><li>Canssandra <ul><li><a href="https://github.com/krojew/cdrs-tokio" target="_blank" rel="noopener noreferrer">krojew/cdrs-tokio</a> [<a href="https://crates.io/crates/cdrs-tokio" target="_blank" rel="noopener noreferrer">cdrs-tokio</a>] 生产可用的Cassandra客户端，异步、纯Rust实现，就是个人项目 + star较少，未来不确定会不会不维护</li><li><a href="https://github.com/scylladb/scylla-rust-driver" target="_blank" rel="noopener noreferrer">scylla-rust-driver</a> ScyllaDB提供的官方库，支持cql协议，由于背靠大山，未来非常可期</li></ul></li><li>MongoDB <ul><li><a href="https://github.com/mongodb/mongo-rust-driver" target="_blank" rel="noopener noreferrer">mongodb/mongo-rust-driver</a> 官方MongoDB客户端，闭着眼睛选就对了</li></ul></li></ul><h2 id="分布式" tabindex="-1">分布式</h2><h3 id="服务发现" tabindex="-1">服务发现</h3><ul><li><a href="https://github.com/luncj/etcd-rs" target="_blank" rel="noopener noreferrer">luncj/etcd-rs</a> 异步实现的Rust etcd客户端，优点是有一定的文档、作者较为活跃,意味着你提问题他可能会回答，不过，如果你不放心，还是考虑使用HTTP的方式访问ETCD</li></ul><h3 id="消息队列" tabindex="-1">消息队列</h3><ul><li>Kafka <ul><li><a href="https://github.com/fede1024/rust-rdkafka" target="_blank" rel="noopener noreferrer">fede1024/rust-rdkafka</a> Rust Kafka客户端，基于C版本的Kafka库[librdkafka]实现，文档较全、功能较为全面</li><li><a href="https://github.com/kafka-rust/kafka-rust" target="_blank" rel="noopener noreferrer">kafka-rust/kafka-rust</a> 相比上一个库，它算是纯Rust实现，文档还行，支持Kafka0.8.2及以后的版本，但是对于部分0.9版本的特性还不支持。同时有一个问题：最初的作者不维护了，转给了现在的作者，但是感觉好像也不是很活跃</li></ul></li><li>Nats <ul><li><a href="https://github.com/nats-io/nats.rs" target="_blank" rel="noopener noreferrer">nats-io/nats.rs</a> Nats官方提供的客户端</li></ul></li></ul><h2 id="网络、通信协议" tabindex="-1">网络、通信协议</h2><ul><li>Websocket <ul><li><a href="https://github.com/snapview/tokio-tungstenite" target="_blank" rel="noopener noreferrer">snapview/tokio-tungstenite</a> 更适合Web应用使用的生产级Websocket库，它是异步非阻塞的，基于基于下下面的<code>tungstenite-rs</code>库和tokio实现</li><li><a href="https://github.com/websockets-rs/rust-websocket" target="_blank" rel="noopener noreferrer">rust-websocket</a> 老牌Websocket库，提供了客户端和服务器端实现，但是。。。很久没更新了</li><li><a href="https://github.com/snapview/tungstenite-rs" target="_blank" rel="noopener noreferrer">snapview/tungstenite-rs</a> 轻量级的Websocket流实现，该库更偏底层，例如，你可以用来构建其它网络库</li></ul></li><li>gRPC <ul><li><a href="https://github.com/hyperium/tonic" target="_blank" rel="noopener noreferrer">hyperium/tonic</a> 纯Rust实现的gRPC客户端和服务器端，支持async/await异步调用，文档和示例较为清晰</li><li><a href="https://github.com/tikv/grpc-rs" target="_blank" rel="noopener noreferrer">tikv/grpc-rs</a> 国产开源之光Tidb团队出品的gRPC框架, 基于C的代码实现, 就是最近好像不是很活跃</li><li>其实这两个实现都很优秀，把<code>tonic</code>放在第一位，主要是因为它是纯Rust实现，同时社区也更为活跃，但是并不代表它比<code>tikv</code>的更好！</li><li><a href="https://github.com/tokio-rs/prost" target="_blank" rel="noopener noreferrer">tokio-rs/prost</a> 纯Rust实现的<a href="https://developers.google.com/protocol-buffers/" target="_blank" rel="noopener noreferrer">Protocol Buffers</a>类库，Prost 支持从 proto2 和 proto3 文件生成简单、实用的代码。</li></ul></li><li>QUIC <ul><li><a href="https://github.com/cloudflare/quiche" target="_blank" rel="noopener noreferrer">cloudflare/quiche</a> 大名鼎鼎<code>cloudflare</code>提供的QUIC实现，据说在公司内部重度使用，有了大规模生产级别的验证，非常值得信任，同时该库还实现了HTTP/3</li><li><a href="https://github.com/quinn-rs/quinn" target="_blank" rel="noopener noreferrer">quinn-rs/quinn</a> 提供异步API调用，纯Rust实现，同时提供了几个有用的网络库</li></ul></li><li>MQTT <ul><li><a href="https://github.com/bytebeamio/rumqtt" target="_blank" rel="noopener noreferrer">bytebeamio/rumqtt</a> MQTT3.1.1/5协议库，同时实现了客户端与服务器端broker</li><li><a href="https://github.com/ntex-rs/ntex-mqtt" target="_blank" rel="noopener noreferrer">ntex-rs/ntex-mqtt</a> 客户端与服务端框架，支持MQTT3.1.1与5协议</li><li><a href="https://github.com/eclipse/paho.mqtt.rust" target="_blank" rel="noopener noreferrer">eclipse/paho.mqtt.rust</a> 老牌MQTT框架，对MQTT支持较全, 其它各语言的实现也有</li></ul></li></ul><h2 id="异步网络编程" tabindex="-1">异步网络编程</h2><ul><li><a href="https://github.com/tokio-rs/tokio" target="_blank" rel="noopener noreferrer">tokio-rs/tokio</a> 最火的异步网络库，除了复杂上手难度高一些外，没有其它大的问题。同时tokio团队提供了多个非常优秀的Rust库，整个生态欣欣向荣，用户认可度很高</li><li><a href="https://async.rs/" target="_blank" rel="noopener noreferrer">async-std</a> 跟标准库API很像的异步网络库，相对简单易用，但是貌似开发有些停滞，还有就是功能上不够完善。但是对于普通用户来说，这个库非常值得一试，它在功能和简单易用上取得了很好的平衡</li><li><a href="https://github.com/actix/actix" target="_blank" rel="noopener noreferrer">actix</a> 基于Actor模型的异步网络库，但这个库的开发貌似已经停滞，他们团队一直在专注于<code>actix-web</code>的开发</li><li><a href="https://github.com/tokio-rs/mio" target="_blank" rel="noopener noreferrer">mio</a> 严格来说，MIO与之前三个不是同一个用途的，MIO = Meta IO，是一个底层IO库，往往用于构建其它网络库，当然如果你对应用网络性能有非常极限的要求， 可以考虑它，因为它的层次比较低，所带来的抽象负担小，所以性能损耗小</li><li>如果你要开发生产级别的项目，我推荐使用<code>tokio</code>，稳定可靠，功能丰富，控制粒度细；自己的学习项目或者没有那么严肃的开源项目，我推荐<code>async-std</code>，简单好用，值得学习；当你确切知道需要Actor网络模型时，就用<code>actix</code></li></ul><h2 id="搜索引擎" tabindex="-1">搜索引擎</h2><ul><li><p>ElasticSearch客户端</p><ul><li><a href="https://github.com/elastic/elasticsearch-rs" target="_blank" rel="noopener noreferrer">elastic/elasticsearch</a> 官方es客户端，目前第三方的基本都处于停滞状态，所以不管好坏，用呗</li></ul></li><li><p>Rust搜索引擎</p><ul><li><a href="https://github.com/quickwit-inc/tantivy" target="_blank" rel="noopener noreferrer">Tantivy</a> Tantivy是Rust实现的本地搜索库，功能对标<code>lucene</code>，如果你不需要分布式，那么引入tantivy作为自己本地Rust服务的一个搜索，是相当不错的选择，该库作者一直很活跃，而且最近还创立了搜索引擎公司，感觉大有作为. 该库的优点在于纯Rust实现，性能高(lucene的2-3倍)，资源占用低(对比java自然不是一个数量级)，社区活跃。</li></ul></li><li><p>Rust搜索平台</p><ul><li><a href="https://github.com/quickwit-inc/quickwit" target="_blank" rel="noopener noreferrer">quickwit</a> 对标ElasticSearch，一个通用目的的分布式搜索平台，目前还在起步阶段(0.2版本)，未来非常可期，目前还不建议使用</li><li><a href="https://github.com/meilisearch/MeiliSearch" target="_blank" rel="noopener noreferrer">MeiliSearch</a> 虽然也是一个搜索平台，但是并不是通用目的的，<code>MeiliSearch</code>目标是为终端用户提供边输入边提示的即刻搜索功能，因此是一个轻量级搜索平台，不适用于数据量大时的搜索目的。总之，如果你需要在网页端或者APP为用户提供一个搜索条，然后支持输入容错、前缀搜索时，就可以使用它。</li></ul></li></ul><h2 id="代码debug" tabindex="-1">代码Debug</h2><ul><li>GDB <ul><li><a href="https://github.com/cs01/gdbgui" target="_blank" rel="noopener noreferrer">gdbgui</a> 提供浏览器支持的gdb debug工具，支持C，C++，Rust和Go.</li></ul></li><li>LLDB <ul><li><a href="https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb" target="_blank" rel="noopener noreferrer">CodeLLDB</a> — 专门为VSCode设计的LLDB Debug扩展</li></ul></li></ul><h2 id="性能优化" tabindex="-1">性能优化</h2><ul><li><a href="https://github.com/bheisler/criterion.rs" target="_blank" rel="noopener noreferrer">bheisler/criterion.rs</a> 比官方提供的benchmark库更好，目前已经成为事实上标准的性能测试工具</li><li><a href="https://github.com/koute/bytehound" target="_blank" rel="noopener noreferrer">Bytehound</a> Linux下的内存分析工具，可以用来分析：内存泄漏、内存分配、调用栈追踪，甚至它还有一个浏览器UI! 懂的人都懂，性能测试工具的UI服务是多么稀缺和珍贵！</li><li><a href="https://github.com/llogiq/flame" target="_blank" rel="noopener noreferrer">llogiq/flame</a> 专为Rust打造的火焰图分析工具，可以告诉你程序在哪些代码上花费的时间过多，非常适合用于代码性能瓶颈的分析。与<code>perf</code>不同，<code>flame</code>库允许你自己定义想要测试的代码片段，只需要在代码前后加上相应的指令即可，非常好用</li><li><a href="https://github.com/sharkdp/hyperfine" target="_blank" rel="noopener noreferrer">sharkdp/hyperfine</a> 一个命令行benchmark工具，支持任意shell命令，支持缓存清除、预热、多次运行统计分析等，尽量保证结果的准确性</li></ul><h2 id="多线程" tabindex="-1">多线程</h2><ul><li>消息通道channel <ul><li><a href="https://github.com/crossbeam-rs/crossbeam/tree/master/crossbeam-channel" target="_blank" rel="noopener noreferrer"><strong>crossbeam-channel</strong></a>, 老牌强库，功能较全，性能较强，之前是独立的库，但是后面合并到了<code>crossbeam</code>主仓库中</li><li><a href="https://github.com/zesterer/flume" target="_blank" rel="noopener noreferrer"><strong>flume</strong></a>, 官方给出的性能数据要比crossbeam更好些，但是貌似最近没怎么更新</li></ul></li><li>并发原语(锁) <ul><li><a href="https://crates.io/crates/parking_lot" target="_blank" rel="noopener noreferrer">parking_lot</a>, 社区较为活跃，star较多，更新较为活跃</li><li><a href="https://crates.io/crates/spin" target="_blank" rel="noopener noreferrer">spin</a>, 在多数场景中性能比<code>parking_lot</code>高一点，最近没怎么更新</li><li>如果不是追求特别极致的性能，建议选择前者</li></ul></li></ul><h2 id="编解码" tabindex="-1">编解码</h2><ul><li><a href="https://github.com/serde-rs/serde" target="_blank" rel="noopener noreferrer">Serde</a> 一个超高性能的通用序列化/反序列化框架，可以跟多种协议的库联合使用，实现统一编解码格式</li><li>CSV <ul><li><a href="https://github.com/BurntSushi/rust-csv" target="_blank" rel="noopener noreferrer">BurntSushi/rust-csv</a> 高性能CSV读写库，支持<a href="https://github.com/serde-rs/serde" target="_blank" rel="noopener noreferrer">Serde</a></li></ul></li><li>JSON <ul><li><a href="https://github.com/serde-rs/json" target="_blank" rel="noopener noreferrer">serde-rs/json</a> 快到上天的JSON库，也是Rust事实上的标准JSON库，你也可以使用它的大哥<a href="https://github.com/serde-rs/serde" target="_blank" rel="noopener noreferrer">serde</a>，一个更通用的序列化/反序列化库</li></ul></li><li>MsgPack <ul><li><a href="https://github.com/3Hren/msgpack-rust" target="_blank" rel="noopener noreferrer">3Hren/msgpack-rust</a> 纯Rust实现的MessagePack编解码协议</li></ul></li><li>ProtocolBuffers <ul><li><a href="https://github.com/tokio-rs/prost" target="_blank" rel="noopener noreferrer">tokio-rs/prost</a> tokio出品，基本都属精品，此库也不例外，简单易用，文档详细</li><li><a href="https://github.com/stepancheg/rust-protobuf" target="_blank" rel="noopener noreferrer">stepancheg/rust-protobuf</a> 纯Rust实现</li></ul></li><li>TOML <ul><li><a href="https://github.com/alexcrichton/toml-rs" target="_blank" rel="noopener noreferrer">alexcrichton/toml-rs</a> TOML编码/解码，可以配合<code>serde</code>使用</li></ul></li><li>XML <ul><li><a href="https://github.com/tafia/quick-xml" target="_blank" rel="noopener noreferrer">tafia/quick-xml</a> 高性能XML库，可以配合<code>serde</code>使用，文档较为详细</li></ul></li><li>YAML <ul><li><a href="https://github.com/dtolnay/serde-yaml" target="_blank" rel="noopener noreferrer">dtolnay/serde-yaml</a> 使用<code>serde</code>编解码<code>YAML</code>格式的数据</li></ul></li></ul><h2 id="ui-开发框架" tabindex="-1">UI 开发框架</h2><ul><li>跨平台 <ul><li><a href="https://github.com/DioxusLabs/dioxus" target="_blank" rel="noopener noreferrer">DioxusLabs/Dioxus</a> 跨平台 UI 开发框架，支持 <code>WASM</code>、<code>Desktop</code>、<code>TUI</code> 等应用开发，文档较为详细</li></ul></li></ul><h2 id="email" tabindex="-1">Email</h2><ul><li><a href="https://github.com/lettre/lettre" target="_blank" rel="noopener noreferrer">lettre/lettre</a> — Rust SMTP库</li></ul>',34)])])}const h=r(a,[["render",n]]),u=JSON.parse('{"path":"/01.%20DesignAndDevelop/Develop/01.%20Language/Rust/%E5%AD%A6%E4%B9%A0/08.%20%E5%8A%9F%E8%83%BD%E7%B1%BB/51.%20%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%BA%93.html","title":"日常开发常用库","lang":"zh-CN","frontmatter":{"description":"日常开发常用库 目录索引 多线程 Web/HTTP, SQL客户端, NoSql客户端， 网络通信协议, 异步网络编程 服务发现, 消息队列, 搜索引擎 编解码, Email, 常用正则模版 日志监控, 代码Debug, 性能优化 Web/HTTP HTTP客户端 reqwest 一个简单又强大的HTTP客户端，reqwest是目前使用最多的HTTP库...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"日常开发常用库\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2026-01-01T16:20:02.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://LincDocs.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/01.%20Language/Rust/%E5%AD%A6%E4%B9%A0/08.%20%E5%8A%9F%E8%83%BD%E7%B1%BB/51.%20%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%BA%93.html"}],["meta",{"property":"og:site_name","content":"MdNote_Public"}],["meta",{"property":"og:title","content":"日常开发常用库"}],["meta",{"property":"og:description","content":"日常开发常用库 目录索引 多线程 Web/HTTP, SQL客户端, NoSql客户端， 网络通信协议, 异步网络编程 服务发现, 消息队列, 搜索引擎 编解码, Email, 常用正则模版 日志监控, 代码Debug, 性能优化 Web/HTTP HTTP客户端 reqwest 一个简单又强大的HTTP客户端，reqwest是目前使用最多的HTTP库..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-01-01T16:20:02.000Z"}],["meta",{"property":"article:modified_time","content":"2026-01-01T16:20:02.000Z"}]]},"git":{"createdTime":1767284402000,"updatedTime":1767284402000,"contributors":[{"name":"Linc","username":"Linc","email":"762699299@qq.com","commits":1,"url":"https://github.com/Linc"}]},"readingTime":{"minutes":10.78,"words":3235},"filePathRelative":"01. DesignAndDevelop/Develop/01. Language/Rust/学习/08. 功能类/51. 日常开发常用库.md","excerpt":"\\n<h2>目录索引</h2>\\n<ul>\\n<li><a href=\\"https://rusty.course.rs/awesome-daily-dev.html#%E5%A4%9A%E7%BA%BF%E7%A8%8B\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">多线程</a></li>\\n<li><a href=\\"https://rusty.course.rs/awesome-daily-dev.html#webhttp\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">Web/HTTP</a>, <a href=\\"https://rusty.course.rs/awesome-daily-dev.html#SQL%E5%AE%A2%E6%88%B7%E7%AB%AF\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">SQL客户端</a>, <a href=\\"https://rusty.course.rs/awesome-daily-dev.html#NoSql%E5%AE%A2%E6%88%B7%E7%AB%AF\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">NoSql客户端</a>， <a href=\\"https://rusty.course.rs/awesome-daily-dev.html#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">网络通信协议</a>, <a href=\\"https://rusty.course.rs/awesome-daily-dev.html#%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">异步网络编程</a></li>\\n<li><a href=\\"https://rusty.course.rs/awesome-daily-dev.html#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">服务发现</a>, <a href=\\"https://rusty.course.rs/awesome-daily-dev.html#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">消息队列</a>, <a href=\\"https://rusty.course.rs/awesome-daily-dev.html#%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">搜索引擎</a></li>\\n<li><a href=\\"https://rusty.course.rs/awesome-daily-dev.html#%E7%BC%96%E8%A7%A3%E7%A0%81\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">编解码</a>, <a href=\\"https://rusty.course.rs/awesome-daily-dev.html#Email\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">Email</a>, <a href=\\"https://rusty.course.rs/awesome-daily-dev.html#%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E6%A8%A1%E7%89%88\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">常用正则模版</a></li>\\n<li><a href=\\"https://rusty.course.rs/awesome-daily-dev.html#%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">日志监控</a>, <a href=\\"https://rusty.course.rs/awesome-daily-dev.html#%E4%BB%A3%E7%A0%81Debug\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">代码Debug</a>, <a href=\\"https://rusty.course.rs/awesome-daily-dev.html#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">性能优化</a></li>\\n</ul>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"01. DesignAndDevelop/Develop/01. Language/Rust/学习/08. 功能类/51. 日常开发常用库.md","value":{"title":"51. 日常开发常用库","path":"01. DesignAndDevelop/Develop/01. Language/Rust/学习/08. 功能类/51. 日常开发常用库.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{h as comp,u as data};
