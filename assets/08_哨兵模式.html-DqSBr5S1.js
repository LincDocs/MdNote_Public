import{_ as e,c as t,b as s,o as n}from"./app-LiNCBk-L.js";const l={};function a(p,i){return n(),t("div",null,[...i[0]||(i[0]=[s(`<h1 id="redis哨兵模式" tabindex="-1">Redis哨兵模式</h1><h2 id="概念" tabindex="-1">概念</h2><p>之前模式的缺点：</p><blockquote><p>前面 主从模式 笔记中设置了一个一主二从的简单集群，但存在一些缺点：</p><p>例如如果主节点宕机了，需要将一个节点提升为主节点</p><p>这时产生了人工干预，没有自动故障转移。而哨兵模式可以解决这个问题。</p></blockquote><p>哨兵模式</p><blockquote><p>大致原理：哨兵会以一个独立的进程运行在集群中并监控各个节点。</p><p>主要执行的功能：</p><ol><li>监控。不断发送命令来检查节点是否正常</li><li>通知。当发现节点出现问题后，哨兵通过发布订阅模式来通知其他节点</li><li>自动故障转移。当主节点不能正常工作时，开始自动故障转移，将一个从节点升级为主节点，再让其他节点指向新主节点</li></ol></blockquote><h2 id="使用" tabindex="-1">使用</h2><p>先添加哨兵节点</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">$</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> vi</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> sentinel.conf</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">					# 配置哨兵节点</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sentinel</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> monitor</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> master</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 127.0.0.1</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 6379</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">	# 这个端口是主节点的端口，哨兵自身的端口是随机的</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">$</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> redis-sentinel</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> sentinel.conf</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">		# 启动哨兵节点</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 在主节点服务器所在终端Ctrl+C来模拟主节点宕机</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 然后等待一下，就能看在启动哨兵节点的终端看到检测到了，并将6381节点设置成了新的主节点</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="其他" tabindex="-1">其他</h2><h3 id="哨兵节点宕机问题" tabindex="-1">哨兵节点宕机问题</h3><p>因为哨兵节点的进程也有可能挂掉，实际生产环境中，往往设置三个哨兵节点保证高可用。</p><p>三个哨兵节点会通过选举方式选出一个领导者，来进行监听。领导者挂掉后剩余哨兵节点会重新选举</p><h3 id="个人疑问" tabindex="-1">（个人疑问）</h3><p>个人Q：主从节点连接的发起端是从节点，但你哨兵设置新节点是新端口而非沿用之前的端口，那么从节点应该没办法连接到新的主节点吧？何况哨兵端口也是随机的</p>`,15)])])}const h=e(l,[["render",a]]),d=JSON.parse('{"path":"/01.%20DesignAndDevelop/Develop/04.%20Project/Platform/Web/04.%20%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/01.%20Redis/03_%E5%85%B6%E4%BB%96/08_%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.html","title":"Redis哨兵模式","lang":"zh-CN","frontmatter":{"description":"Redis哨兵模式 概念 之前模式的缺点： 前面 主从模式 笔记中设置了一个一主二从的简单集群，但存在一些缺点： 例如如果主节点宕机了，需要将一个节点提升为主节点 这时产生了人工干预，没有自动故障转移。而哨兵模式可以解决这个问题。 哨兵模式 大致原理：哨兵会以一个独立的进程运行在集群中并监控各个节点。 主要执行的功能： 监控。不断发送命令来检查节点是否...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis哨兵模式\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-11-08T16:11:07.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://LincDocs.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/04.%20Project/Platform/Web/04.%20%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/01.%20Redis/03_%E5%85%B6%E4%BB%96/08_%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.html"}],["meta",{"property":"og:site_name","content":"MdNote_Public"}],["meta",{"property":"og:title","content":"Redis哨兵模式"}],["meta",{"property":"og:description","content":"Redis哨兵模式 概念 之前模式的缺点： 前面 主从模式 笔记中设置了一个一主二从的简单集群，但存在一些缺点： 例如如果主节点宕机了，需要将一个节点提升为主节点 这时产生了人工干预，没有自动故障转移。而哨兵模式可以解决这个问题。 哨兵模式 大致原理：哨兵会以一个独立的进程运行在集群中并监控各个节点。 主要执行的功能： 监控。不断发送命令来检查节点是否..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-11-08T16:11:07.000Z"}],["meta",{"property":"article:modified_time","content":"2025-11-08T16:11:07.000Z"}]]},"git":{"createdTime":1762618267000,"updatedTime":1762618267000,"contributors":[{"name":"Linc","username":"Linc","email":"762699299@qq.com","commits":1,"url":"https://github.com/Linc"}]},"readingTime":{"minutes":1.7,"words":511},"filePathRelative":"01. DesignAndDevelop/Develop/04. Project/Platform/Web/04. 后端/数据库/01. Redis/03_其他/08_哨兵模式.md","excerpt":"\\n<h2>概念</h2>\\n<p>之前模式的缺点：</p>\\n<blockquote>\\n<p>前面 主从模式 笔记中设置了一个一主二从的简单集群，但存在一些缺点：</p>\\n<p>例如如果主节点宕机了，需要将一个节点提升为主节点</p>\\n<p>这时产生了人工干预，没有自动故障转移。而哨兵模式可以解决这个问题。</p>\\n</blockquote>\\n<p>哨兵模式</p>\\n<blockquote>\\n<p>大致原理：哨兵会以一个独立的进程运行在集群中并监控各个节点。</p>\\n<p>主要执行的功能：</p>\\n<ol>\\n<li>监控。不断发送命令来检查节点是否正常</li>\\n<li>通知。当发现节点出现问题后，哨兵通过发布订阅模式来通知其他节点</li>\\n<li>自动故障转移。当主节点不能正常工作时，开始自动故障转移，将一个从节点升级为主节点，再让其他节点指向新主节点</li>\\n</ol>\\n</blockquote>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"01. DesignAndDevelop/Develop/04. Project/Platform/Web/04. 后端/数据库/01. Redis/03_其他/08_哨兵模式.md","value":{"title":"08_哨兵模式","path":"01. DesignAndDevelop/Develop/04. Project/Platform/Web/04. 后端/数据库/01. Redis/03_其他/08_哨兵模式.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{h as comp,d as data};
