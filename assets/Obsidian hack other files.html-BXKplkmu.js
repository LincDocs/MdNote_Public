import{_ as s,c as a,b as n,o as t}from"./app-BvVwUQfW.js";const l={};function h(e,i){return t(),a("div",null,[...i[0]||(i[0]=[n(`<h1 id="obsidian插件去读写规则外的文件" tabindex="-1">Obsidian插件去读写规则外的文件</h1><p>obsidian开发中，插件可以获取的数据，除了插件文件夹的data.json、库内使用api去读取的文件外，还能通过什么方式？</p><p>能否获取插件文件夹内除 data.json 外的其他文件？像一些插件/css管理器插件还能检测插件/css和修改，像 i18n 甚至能去修改其他插件文件夹，这些是hack手段吗还是obsidian 提供的api</p><h2 id="gemini-2-5-pro" tabindex="-1">gemini 2.5 pro</h2><p>你好！这是一个非常好的问题，触及了 Obsidian 插件开发的本质。你的观察非常敏锐，很多强大插件的功能确实超越了表面上的 API。</p><p>简单来说，答案是：<strong>是的，插件几乎可以访问你电脑上当前用户权限下的任何文件，这既不是 hack，也超出了 Obsidian 官方 API 的范畴，其根本原因在于 Obsidian 的技术架构。</strong></p><p>下面我来详细解释一下。</p><h3 id="插件可以获取的数据来源" tabindex="-1">插件可以获取的数据来源</h3><p>Obsidian 插件可以访问的数据主要来自以下三个层面：</p><h4 id="_1-obsidian-官方-api-the-official-way" tabindex="-1">1. Obsidian 官方 API (The Official Way)</h4><p>这是 Obsidian 官方提供和推荐的、最安全和稳定的方法。它主要包括：</p><ul><li><strong>库内文件 (Vault Files):</strong><ul><li>使用 <code>this.app.vault</code> 对象来读取、写入、修改、删除库中的 Markdown 文件和附件。</li><li>例如 <code>app.vault.read()</code>, <code>app.vault.write()</code>, <code>app.vault.getFiles()</code> 等。</li><li>这是最常见的操作，比如各种笔记增强插件都是基于此。</li></ul></li><li><strong>插件自身配置 (Plugin Data):</strong><ul><li>使用 <code>this.loadData()</code> 和 <code>this.saveData()</code> 方法。</li><li>这其实是 Obsidian 封装好的快捷方式，用于读取和写入位于插件目录下的 <code>data.json</code> 文件 (<code>&lt;vault&gt;/.obsidian/plugins/your-plugin-name/data.json</code>)。</li><li>这是为了方便插件保存自己的设置。</li></ul></li></ul><h4 id="_2-node-js-api-the-under-the-hood-way" tabindex="-1">2. Node.js API (The &quot;Under the Hood&quot; Way)</h4><p>这是理解你问题的关键。Obsidian 是一个基于 <strong>Electron</strong> 的桌面应用。Electron 本质上是一个 &quot;壳&quot;，它捆绑了 <strong>Chromium</strong> (用于显示界面) 和 <strong>Node.js</strong> (用于与操作系统交互)。</p><p><strong>这意味着，你的插件代码实际上是在一个完整的 Node.js 环境中运行的！</strong></p><p>因此，你可以直接在插件代码中引入 Node.js 的内置模块，尤其是 <code>fs</code> (File System) 模块。</p><div class="language-ts line-numbers-mode" data-highlighter="shiki" data-ext="ts" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-ts"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 你可以在你的 main.ts 或其他插件文件中这样写</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#E45649;--shiki-dark:#D19A66;"> *</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;"> as</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> fs</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> from</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;fs&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#E45649;--shiki-dark:#D19A66;"> *</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;"> as</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> path</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> from</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;path&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// ... 在你的插件类中 ...</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">async</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> onload</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 获取当前 vault 的绝对路径</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> vaultPath</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">app</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">vault</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">adapter</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;"> as</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;"> any</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">).</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">basePath</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 1. 读取插件文件夹内的其他文件</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> myFilePath</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> path</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">join</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">manifest</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">dir</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;my-other-file.txt&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">fs</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">existsSync</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">myFilePath</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> content</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> fs</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">readFileSync</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">myFilePath</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;utf-8&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">        console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;成功读取插件目录下的其他文件:&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">content</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 2. 探测其他插件的文件夹</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> pluginsDir</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> path</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">join</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">vaultPath</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;.obsidian/plugins&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> allPlugins</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> fs</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">readdirSync</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">pluginsDir</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;检测到的所有插件文件夹:&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">allPlugins</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 3. 修改其他插件的文件 (!!! 极度不推荐 !!!)</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 比如，i18n 插件可能会这样做来替换语言文件</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> anotherPluginPath</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> path</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">join</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">pluginsDir</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;some-other-plugin&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;main.js&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">fs</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">existsSync</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">anotherPluginPath</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // const originalCode = fs.readFileSync(anotherPluginPath, &#39;utf-8&#39;);</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 在这里可以对文件内容进行修改和写回，但风险很高</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">        console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">\`可以访问到 </span><span style="--shiki-light:#CA1243;--shiki-dark:#C678DD;">\${</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">anotherPluginPath</span><span style="--shiki-light:#CA1243;--shiki-dark:#C678DD;">}</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">\`</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过这种方式，插件可以：</p><ul><li><strong>读取自己文件夹内的任何文件</strong>：不只是 <code>data.json</code>，可以是 <code>styles.css</code>, <code>template.html</code>, <code>extra-data.xml</code> 等任何你放进去的文件。</li><li><strong>遍历 <code>.obsidian</code> 目录</strong>：可以扫描所有已安装的插件、CSS 片段、主题。这就是 &quot;CSS/插件管理器&quot; 类插件的工作原理。</li><li><strong>修改其他插件/主题的文件</strong>：i18n (多语言) 插件就是通过读取其他插件的 <code>manifest.json</code> 和 <code>main.js</code>，然后将需要翻译的字符串替换掉，来实现汉化的。</li></ul><h4 id="_3-dom-api-web-技术" tabindex="-1">3. DOM API (Web 技术)</h4><p>因为界面是基于 Chromium 的，插件也可以像网页脚本一样操作 DOM，获取和修改页面的任何元素。但这主要用于界面交互，而不是文件数据层面。</p><h3 id="核心问题-这是-hack-吗" tabindex="-1">核心问题：这是 Hack 吗？</h3><p><strong>不是严格意义上的 Hack，更应该称之为“利用底层环境特性”。</strong></p><ul><li><p><strong>Obsidian 官方的态度</strong>：官方文档主要引导开发者使用封装好的、稳定的 API。直接使用 Node.js API 被认为是不稳定且有风险的，因为：</p><ol><li><strong>没有版本保证</strong>：Obsidian 更新可能会改变底层文件结构（比如 <code>.obsidian</code> 目录），导致你的插件崩溃。</li><li><strong>安全性</strong>：这赋予了插件极大的权限。一个恶意插件可以读取你电脑上的敏感文件（只要当前用户有权限访问）。这也是为什么 Obsidian 需要用户手动关闭“安全模式”并信任插件作者。</li><li><strong>兼容性</strong>：这种方式可能导致插件间冲突。如果两个插件都去修改第三个插件的文件，结果可能是灾难性的。</li></ol></li><li><p><strong>社区的实践</strong>：尽管有风险，但为了实现更高级的功能，许多知名插件（如你提到的 i18n、BRAT 等）都广泛使用了 Node.js API。这已经成为社区的一种“标准实践”。</p></li></ul><h3 id="总结" tabindex="-1">总结</h3><table><thead><tr><th>数据访问方式</th><th>API/技术</th><th>作用范围</th><th>是否官方推荐</th><th>稳定性</th><th>案例</th></tr></thead><tbody><tr><td><strong>库内文件</strong></td><td><code>app.vault</code> API</td><td>Vault 内的笔记和附件</td><td><strong>是</strong></td><td>高</td><td>多数笔记功能插件</td></tr><tr><td><strong>插件设置</strong></td><td><code>loadData</code>/<code>saveData</code></td><td>插件目录下的 <code>data.json</code></td><td><strong>是</strong></td><td>高</td><td>保存插件配置</td></tr><tr><td><strong>任意文件</strong></td><td><strong>Node.js <code>fs</code> 模块</strong></td><td><strong>用户权限内的几乎所有文件</strong></td><td><strong>否</strong></td><td><strong>低</strong></td><td><strong>插件管理器、i18n、主题下载器</strong></td></tr></tbody></table><p>所以，你的理解是正确的。那些看起来“神奇”的插件，正是利用了 Obsidian 运行在 Node.js 环境这一核心特性，直接进行了文件系统层面的操作，从而超越了标准 API 的限制。在开发自己的插件时，如果必须使用这种方法，请务必做好错误处理，并明确告知用户可能存在的风险。</p>`,27)])])}const p=s(l,[["render",h]]),d=JSON.parse('{"path":"/01.%20DesignAndDevelop/Develop/04.%20Project/Type/Doc/MarkdwonAbout/01.%20Soft%20And%20Frame/Obsidian/%E4%B8%AA%E4%BA%BA%E6%9D%82%E8%AE%B0/Obsidian%20hack%20other%20files.html","title":"Obsidian插件去读写规则外的文件","lang":"zh-CN","frontmatter":{"create_date":"2025-10-08T00:00:00.000Z","last_date":"2025-10-08T00:00:00.000Z","main_tag":"obsidian插件开发","description":"Obsidian插件去读写规则外的文件 obsidian开发中，插件可以获取的数据，除了插件文件夹的data.json、库内使用api去读取的文件外，还能通过什么方式？ 能否获取插件文件夹内除 data.json 外的其他文件？像一些插件/css管理器插件还能检测插件/css和修改，像 i18n 甚至能去修改其他插件文件夹，这些是hack手段吗还是ob...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Obsidian插件去读写规则外的文件\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2026-01-01T16:20:02.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://LincDocs.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/04.%20Project/Type/Doc/MarkdwonAbout/01.%20Soft%20And%20Frame/Obsidian/%E4%B8%AA%E4%BA%BA%E6%9D%82%E8%AE%B0/Obsidian%20hack%20other%20files.html"}],["meta",{"property":"og:site_name","content":"MdNote_Public"}],["meta",{"property":"og:title","content":"Obsidian插件去读写规则外的文件"}],["meta",{"property":"og:description","content":"Obsidian插件去读写规则外的文件 obsidian开发中，插件可以获取的数据，除了插件文件夹的data.json、库内使用api去读取的文件外，还能通过什么方式？ 能否获取插件文件夹内除 data.json 外的其他文件？像一些插件/css管理器插件还能检测插件/css和修改，像 i18n 甚至能去修改其他插件文件夹，这些是hack手段吗还是ob..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-01-01T16:20:02.000Z"}],["meta",{"property":"article:modified_time","content":"2026-01-01T16:20:02.000Z"}]]},"git":{"createdTime":1767284402000,"updatedTime":1767284402000,"contributors":[{"name":"Linc","username":"Linc","email":"762699299@qq.com","commits":1,"url":"https://github.com/Linc"}]},"readingTime":{"minutes":4.92,"words":1477},"filePathRelative":"01. DesignAndDevelop/Develop/04. Project/Type/Doc/MarkdwonAbout/01. Soft And Frame/Obsidian/个人杂记/Obsidian hack other files.md","excerpt":"\\n<p>obsidian开发中，插件可以获取的数据，除了插件文件夹的data.json、库内使用api去读取的文件外，还能通过什么方式？</p>\\n<p>能否获取插件文件夹内除 data.json 外的其他文件？像一些插件/css管理器插件还能检测插件/css和修改，像 i18n 甚至能去修改其他插件文件夹，这些是hack手段吗还是obsidian 提供的api</p>\\n<h2>gemini 2.5 pro</h2>\\n<p>你好！这是一个非常好的问题，触及了 Obsidian 插件开发的本质。你的观察非常敏锐，很多强大插件的功能确实超越了表面上的 API。</p>\\n<p>简单来说，答案是：<strong>是的，插件几乎可以访问你电脑上当前用户权限下的任何文件，这既不是 hack，也超出了 Obsidian 官方 API 的范畴，其根本原因在于 Obsidian 的技术架构。</strong></p>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"01. DesignAndDevelop/Develop/04. Project/Type/Doc/MarkdwonAbout/01. Soft And Frame/Obsidian/个人杂记/Obsidian hack other files.md","value":{"title":"Obsidian hack other files","path":"01. DesignAndDevelop/Develop/04. Project/Type/Doc/MarkdwonAbout/01. Soft And Frame/Obsidian/个人杂记/Obsidian hack other files.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{p as comp,d as data};
