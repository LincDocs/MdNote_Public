import{_ as d,c,f as e,o}from"./app-BpMPCgQm.js";const n={};function r(a,t){return o(),c("div",null,t[0]||(t[0]=[e('<h1 id="gcc-g-rcc" tabindex="-1"><a class="header-anchor" href="#gcc-g-rcc"><span>gcc g++ rcc</span></a></h1><h2 id="gcc与g" tabindex="-1"><a class="header-anchor" href="#gcc与g"><span>gcc与g++</span></a></h2><p>详见《深入理解计算机系统》</p><blockquote><h4 id="linux编译器和反汇编器的使用" tabindex="-1"><a class="header-anchor" href="#linux编译器和反汇编器的使用"><span>Linux编译器和反汇编器的使用</span></a></h4></blockquote><p>gcc和g++都可以编译C/C++，但教程上一般是gcc对C，gcc汇编，g++对C++，具体的这里不再深入</p><p>两者的用法几乎完全一致</p><table><thead><tr><th>linux指令（<code>gcc</code>与<code>objdump</code>）</th><th>操作</th><th>生成文件</th><th>文件补充</th></tr></thead><tbody><tr><td><code>gcc -Og -S main.c</code></td><td>仅编译</td><td>汇编文件<code>main.s</code></td><td>可以文本方式打开阅读汇编代码</td></tr><tr><td><code>gcc -Og -S -masm=intel main.c</code></td><td>仅编译</td><td>汇编文件<code>main.s</code></td><td>还可以生成Intel格式的代码（没区别？）</td></tr><tr><td><code>gcc -Og -c main.c</code></td><td>编译+汇编</td><td>二进制文件<code>main.o</code></td><td><code>sudo ./main.o</code>可运行该文件</td></tr><tr><td><code>gcc -Og -o prog main.c hello.c</code></td><td>编译+汇编+链接</td><td>二进制文件<code>prog</code></td><td><code>sudo ./prog</code>可运行该文件</td></tr><tr><td><code>gcc main.c</code></td><td>编译+汇编+链接</td><td>二进制文件<code>a.out</code></td><td><code>sudo ./a.out</code>可运行该文件</td></tr><tr><td>——————</td><td>——————</td><td>——————</td><td>——————</td></tr><tr><td><code>g++ -S main.cpp</code></td><td>仅编译</td><td>汇编文件<code>main.s</code></td><td>可以文本方式打开阅读汇编代码</td></tr><tr><td><code>g++ -c main.cpp</code></td><td>编译+汇编</td><td>二进制文件<code>main.o</code></td><td><code>sudo ./main.o</code>可运行该文件</td></tr><tr><td><code>g++ -o [world] main.cpp</code></td><td>编译+汇编+链接</td><td>二进制文件<code>main</code> (或<code>world</code>)</td><td><code>sudo ./prog</code>可运行该文件</td></tr><tr><td><code>g++ main.cpp</code></td><td>编译+汇编+链接</td><td>二进制文件<code>a.out</code></td><td><code>sudo ./a.out</code>可运行该文件</td></tr><tr><td>——————</td><td>——————</td><td>——————</td><td>——————</td></tr><tr><td><code>objdump -d mstore.o</code></td><td>反汇编二进制代码</td><td>不生成，在终端显示结果</td><td></td></tr><tr><td><code>objdump -d prog</code></td><td>反汇编二进制代码</td><td>不生成，在终端显示结果</td><td></td></tr></tbody></table><p><strong>表格补充：如进行链接，则必须要有一个main函数</strong></p><p>反编译器（disassembler）补充：反汇编特性：</p><ul><li>指令长度：x86-64的从1-15个字节不等，常用指令和操作数较少的指令所需的字节数少（反之）</li><li>设计指令格式的方式：从某个给定位置开始可以唯一性解码（如：只有pushq %rbx是以字节值53开头的）</li><li>指令名：反汇编使用的指令命名规则和GCC生成的有细微差别（如：末尾的q）</li></ul><h2 id="rcc" tabindex="-1"><a class="header-anchor" href="#rcc"><span>rcc</span></a></h2><p>详见QT笔记</p><p>参考：<a href="https://blog.csdn.net/xld_19920728/article/details/86305026" target="_blank" rel="noopener noreferrer">【CSDN】Qt中rcc工具简介</a></p><p>RCC 代表 <s>反向 C 编译器（Reverse C Compiler）</s>（不确定）</p><p>Qt 自带的开发工具集里有专门的 rcc 工具，用于将 *.qrc 里面描述的图片、文档等编译成对应的源代码文件 qrc_*.cpp 或者独立的二进制资源文件 *.rcc。下面介绍 rcc 工具的两种用途：</p><ul><li>（1）生成独立的二进制资源文件 *.rcc</li><li>（2）应用程序内嵌资源</li></ul>',16)]))}const g=d(n,[["render",r],["__file","gcc g__ rcc.html.vue"]]),l=JSON.parse('{"path":"/01.%20DesignAndDevelop/Develop/03.%20Tools/02.%20%E5%BC%80%E5%8F%91%E5%B1%82/Build%20Tools/gcc%20g__%20rcc.html","title":"gcc g++ rcc","lang":"zh-CN","frontmatter":{"description":"gcc g++ rcc gcc与g++ 详见《深入理解计算机系统》 Linux编译器和反汇编器的使用 gcc和g++都可以编译C/C++，但教程上一般是gcc对C，gcc汇编，g++对C++，具体的这里不再深入 两者的用法几乎完全一致 表格补充：如进行链接，则必须要有一个main函数 反编译器（disassembler）补充：反汇编特性： 指令长度：x...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/03.%20Tools/02.%20%E5%BC%80%E5%8F%91%E5%B1%82/Build%20Tools/gcc%20g__%20rcc.html"}],["meta",{"property":"og:site_name","content":"MdNote_Public"}],["meta",{"property":"og:title","content":"gcc g++ rcc"}],["meta",{"property":"og:description","content":"gcc g++ rcc gcc与g++ 详见《深入理解计算机系统》 Linux编译器和反汇编器的使用 gcc和g++都可以编译C/C++，但教程上一般是gcc对C，gcc汇编，g++对C++，具体的这里不再深入 两者的用法几乎完全一致 表格补充：如进行链接，则必须要有一个main函数 反编译器（disassembler）补充：反汇编特性： 指令长度：x..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-05T16:08:48.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-05T16:08:48.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"gcc g++ rcc\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-05T16:08:48.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/MdNote_Public/\\"}]}"]]},"headers":[{"level":1,"title":"gcc g++ rcc","slug":"gcc-g-rcc","link":"#gcc-g-rcc","children":[{"level":2,"title":"gcc与g++","slug":"gcc与g","link":"#gcc与g","children":[]},{"level":2,"title":"rcc","slug":"rcc","link":"#rcc","children":[]}]}],"git":{"createdTime":1738771728000,"updatedTime":1738771728000,"contributors":[{"name":"Linc","username":"Linc","email":"762699299@qq.com","commits":1,"url":"https://github.com/Linc"}]},"readingTime":{"minutes":2.04,"words":612},"filePathRelative":"01. DesignAndDevelop/Develop/03. Tools/02. 开发层/Build Tools/gcc g++ rcc.md","localizedDate":"2025年2月5日","excerpt":"\\n<h2>gcc与g++</h2>\\n<p>详见《深入理解计算机系统》</p>\\n<blockquote>\\n<h4>Linux编译器和反汇编器的使用</h4>\\n</blockquote>\\n<p>gcc和g++都可以编译C/C++，但教程上一般是gcc对C，gcc汇编，g++对C++，具体的这里不再深入</p>\\n<p>两者的用法几乎完全一致</p>\\n<table>\\n<thead>\\n<tr>\\n<th>linux指令（<code>gcc</code>与<code>objdump</code>）</th>\\n<th>操作</th>\\n<th>生成文件</th>\\n<th>文件补充</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>gcc -Og -S main.c</code></td>\\n<td>仅编译</td>\\n<td>汇编文件<code>main.s</code></td>\\n<td>可以文本方式打开阅读汇编代码</td>\\n</tr>\\n<tr>\\n<td><code>gcc -Og -S -masm=intel main.c</code></td>\\n<td>仅编译</td>\\n<td>汇编文件<code>main.s</code></td>\\n<td>还可以生成Intel格式的代码（没区别？）</td>\\n</tr>\\n<tr>\\n<td><code>gcc -Og -c main.c</code></td>\\n<td>编译+汇编</td>\\n<td>二进制文件<code>main.o</code></td>\\n<td><code>sudo ./main.o</code>可运行该文件</td>\\n</tr>\\n<tr>\\n<td><code>gcc -Og -o prog main.c hello.c</code></td>\\n<td>编译+汇编+链接</td>\\n<td>二进制文件<code>prog</code></td>\\n<td><code>sudo ./prog</code>可运行该文件</td>\\n</tr>\\n<tr>\\n<td><code>gcc main.c</code></td>\\n<td>编译+汇编+链接</td>\\n<td>二进制文件<code>a.out</code></td>\\n<td><code>sudo ./a.out</code>可运行该文件</td>\\n</tr>\\n<tr>\\n<td>——————</td>\\n<td>——————</td>\\n<td>——————</td>\\n<td>——————</td>\\n</tr>\\n<tr>\\n<td><code>g++ -S main.cpp</code></td>\\n<td>仅编译</td>\\n<td>汇编文件<code>main.s</code></td>\\n<td>可以文本方式打开阅读汇编代码</td>\\n</tr>\\n<tr>\\n<td><code>g++ -c main.cpp</code></td>\\n<td>编译+汇编</td>\\n<td>二进制文件<code>main.o</code></td>\\n<td><code>sudo ./main.o</code>可运行该文件</td>\\n</tr>\\n<tr>\\n<td><code>g++ -o [world] main.cpp</code></td>\\n<td>编译+汇编+链接</td>\\n<td>二进制文件<code>main</code> (或<code>world</code>)</td>\\n<td><code>sudo ./prog</code>可运行该文件</td>\\n</tr>\\n<tr>\\n<td><code>g++ main.cpp</code></td>\\n<td>编译+汇编+链接</td>\\n<td>二进制文件<code>a.out</code></td>\\n<td><code>sudo ./a.out</code>可运行该文件</td>\\n</tr>\\n<tr>\\n<td>——————</td>\\n<td>——————</td>\\n<td>——————</td>\\n<td>——————</td>\\n</tr>\\n<tr>\\n<td><code>objdump -d mstore.o</code></td>\\n<td>反汇编二进制代码</td>\\n<td>不生成，在终端显示结果</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>objdump -d prog</code></td>\\n<td>反汇编二进制代码</td>\\n<td>不生成，在终端显示结果</td>\\n<td></td>\\n</tr>\\n</tbody>\\n</table>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"01. DesignAndDevelop/Develop/03. Tools/02. 开发层/Build Tools/gcc g++ rcc.md","value":{"title":"gcc g++ rcc","path":"01. DesignAndDevelop/Develop/03. Tools/02. 开发层/Build Tools/gcc g++ rcc.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{g as comp,l as data};
