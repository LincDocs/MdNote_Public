import{_ as o,c as n,a as l,b as i,d as r,e as s,f as a,r as E,o as B}from"./app-CqYK0DZN.js";const m={};function p(d,e){const t=E("RouteLink");return B(),n("div",null,[e[2]||(e[2]=l("h1",{id:"调度算法",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#调度算法"},[l("span",null,"调度算法")])],-1)),l("p",null,[e[1]||(e[1]=i("详细见 ")),r(t,{to:"/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/01.%20%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/06.%20%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"},{default:s(()=>e[0]||(e[0]=[i("../../03. 计算机系统 - 线性学习版/01. 图解系统/06. 调度算法/")])),_:1})]),e[3]||(e[3]=a('<h2 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h2><h3 id="计算机相关的调度算法-四类、多种" tabindex="-1"><a class="header-anchor" href="#计算机相关的调度算法-四类、多种"><span>计算机相关的调度算法 (四类、多种)</span></a></h3><p>本质都是<strong>优化优先级</strong>（具体体现为处理顺序的优先级/保留的优先级）</p><ul><li>进程调度算法。核心：<strong>优化顺序，减少等待时间总和</strong><ul><li><em>先来先服务</em>调度算法 (<em>FCFS</em>)</li><li>最短作业优先调度算法 (<em>SJF</em>)</li><li>高响应比优先调度算法 (<em>HRRN</em>)</li><li>时间片轮转调度算法 (<em>PR</em>)</li><li>最高优先级调度算法 (<em>HPF</em>)</li><li>多级反馈队列调度算法 (<em>MFQ</em>)</li></ul></li><li>磁盘调度算法。核心：<strong>优化顺序，减少总寻道的时间</strong><ul><li><em>先来先服务</em>算法 (<em>FCFS</em>)</li><li>最短寻道时间优先算法 (<em>SSF</em>)</li><li>扫描算法 (<em>Scan</em>)</li><li>循环扫描算法 (<em>CScan</em>)</li><li>LOOK 与 C-LOOK 算法</li></ul></li><li>页面置换算法。核心：<strong>优化选择，减少页面的置换次数</strong><ul><li>最佳页面置换算法 (<em>OPT</em>)</li><li><s>先进先出置换算法 (<em>FIFO</em>)</s></li><li>最近最久未使用的置换算法 (<em>LRU</em>)</li><li>时钟页面置换算法 (<em>Lock</em>)</li><li>最不常用置换算法 (<em>LFU</em>)</li></ul></li><li>I/O调度算法。核心：<strong>优化顺序，无唯一目标</strong>（I/O 请求队列，详见设备管理一章） <ul><li>没有调度算法</li><li>先入先出调度算法</li><li>完全公平调度算法</li><li>优先级调度算法</li><li>最终期限调度算法</li></ul></li></ul><h3 id="redis-的内存淘汰策略-八种" tabindex="-1"><a class="header-anchor" href="#redis-的内存淘汰策略-八种"><span>Redis 的内存淘汰策略 (八种)</span></a></h3><p>Redis 的内存淘汰策略（和页面置换是很相似的）</p><p>Redis 内存淘汰策略共有八种：（且这些策略可以进行以下分类）</p><ul><li>不进行数据淘汰的策略 <ul><li><strong>noeviction</strong>（Redis3.0之后，默认的内存淘汰策略） ：它表示当运行内存超过最大设置内存时，不淘汰任何数据，而是不再提供服务，直接返回错误。</li></ul></li><li>进行数据淘汰的策略 <ul><li>在设置了过期时间的数据中进行淘汰 <ul><li><strong>volatile-random</strong>：随机淘汰设置了过期时间的任意键值；</li><li><strong>volatile-ttl</strong>：优先淘汰更早过期的键值。</li><li><strong>volatile-lru</strong>（Redis3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；</li><li><strong>volatile-lfu</strong>（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值；</li></ul></li><li>在所有数据范围内进行淘汰 <ul><li><strong>allkeys-random</strong>：随机淘汰任意键值;</li><li><strong>allkeys-lru</strong>：淘汰整个键值中最久未使用的键值；</li><li><strong>allkeys-lfu</strong>（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值。</li></ul></li></ul></li></ul>',8))])}const c=o(m,[["render",p],["__file","竞争调度算法.html.vue"]]),u=JSON.parse('{"path":"/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E5%85%B6%E4%BB%96%E6%8A%BD%E8%B1%A1/%E7%AB%9E%E4%BA%89%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.html","title":"调度算法","lang":"zh-CN","frontmatter":{"description":"调度算法 详细见 目录 计算机相关的调度算法 (四类、多种) 本质都是优化优先级（具体体现为处理顺序的优先级/保留的优先级） 进程调度算法。核心：优化顺序，减少等待时间总和 先来先服务调度算法 (FCFS) 最短作业优先调度算法 (SJF) 高响应比优先调度算法 (HRRN) 时间片轮转调度算法 (PR) 最高优先级调度算法 (HPF) 多级反馈队列调...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E5%85%B6%E4%BB%96%E6%8A%BD%E8%B1%A1/%E7%AB%9E%E4%BA%89%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.html"}],["meta",{"property":"og:site_name","content":"MdNote_Public"}],["meta",{"property":"og:title","content":"调度算法"}],["meta",{"property":"og:description","content":"调度算法 详细见 目录 计算机相关的调度算法 (四类、多种) 本质都是优化优先级（具体体现为处理顺序的优先级/保留的优先级） 进程调度算法。核心：优化顺序，减少等待时间总和 先来先服务调度算法 (FCFS) 最短作业优先调度算法 (SJF) 高响应比优先调度算法 (HRRN) 时间片轮转调度算法 (PR) 最高优先级调度算法 (HPF) 多级反馈队列调..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-01-28T10:12:49.000Z"}],["meta",{"property":"article:modified_time","content":"2025-01-28T10:12:49.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"调度算法\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-01-28T10:12:49.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/MdNote_Public/\\"}]}"]]},"headers":[{"level":1,"title":"调度算法","slug":"调度算法","link":"#调度算法","children":[{"level":2,"title":"目录","slug":"目录","link":"#目录","children":[{"level":3,"title":"计算机相关的调度算法 (四类、多种)","slug":"计算机相关的调度算法-四类、多种","link":"#计算机相关的调度算法-四类、多种","children":[]},{"level":3,"title":"Redis 的内存淘汰策略 (八种)","slug":"redis-的内存淘汰策略-八种","link":"#redis-的内存淘汰策略-八种","children":[]}]}]}],"git":{"createdTime":1738059169000,"updatedTime":1738059169000,"contributors":[{"name":"Linc","username":"Linc","email":"762699299@qq.com","commits":1,"url":"https://github.com/Linc"}]},"readingTime":{"minutes":2.29,"words":686},"filePathRelative":"01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/其他抽象/竞争调度算法.md","localizedDate":"2025年1月28日","excerpt":"\\n<p>详细见 <a href=\\"/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/01.%20%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/06.%20%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/\\" target=\\"_blank\\">../../03. 计算机系统 - 线性学习版/01. 图解系统/06. 调度算法/</a></p>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/其他抽象/竞争调度算法.md","value":{"title":"竞争调度算法","path":"01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/其他抽象/竞争调度算法.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{c as comp,u as data};
