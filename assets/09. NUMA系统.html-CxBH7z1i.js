import{_ as i,c as t,f as s,o as n}from"./app-Bf82mvyV.js";const l={};function a(o,e){return n(),t("div",null,e[0]||(e[0]=[s(`<h1 id="numa系统-未" tabindex="-1"><a class="header-anchor" href="#numa系统-未"><span>NUMA系统 (未)</span></a></h1><p>之前的章节已经简要介绍过NUMA系统，它是一种多处理器环境下设计的计算机内存结构。NUMA系统是从SMP（Symmetric Multiple Processing，对称多处理器）系统演化而来。</p><p>SMP系统最初是在20世纪90年代由Unisys、Convex Computer（后来的HP）、Honeywell、IBM等公司开发的一款商用系统，该系统被广泛应用于Unix类的操作系统，后来又扩展到Windows NT中，该系统有如下特点：</p><ol><li>所有的硬件资源都是共享的。即每个处理器都能访问到任何内存、外设等。</li><li>所有的处理器都是平等的，没有主从关系。</li><li>内存是统一结构、统一寻址的（UMA，Uniform Memory Architecture）。</li><li>处理器和内存，处理器和处理器都通过一条总线连接起来。</li></ol><p>其结构如图2-14所示：</p><p>SMP的问题也很明显，因为所有的处理器都通过一条总线连接起来，因此随着处理器的增加，系统总线成为了系统瓶颈，另外，处理器和内存之间的通信延迟也较大。为了克服以上的缺点，才应运而生了NUMA架构，如图2-15所示。</p><p>图2-14　SMP系统示意图</p><p>![img](09. NUMA系统.assets/Image00033.jpg)</p><p>图2-15　NUMA系统示意图</p><p>![img](09. NUMA系统.assets/Image00039.jpg)</p><p>NUMA 是起源于AMD Opteron的微架构，同时被英特尔Nehalem架构采用。在这个架构中，处理器和本地内存之间拥有更小的延迟和更大的带宽，而整个内存仍然可作为一个整体，任何处理器都能够访问，只不过跨处理器的内存访问的速度相对较慢一点。同时，每个处理器都可以拥有本地的总线，如PCIE、SATA、USB等。和内存一样，处理器访问本地的总线延迟低，吞吐率高；访问远程资源，则延迟高，并且要和其他处理器共享一条总线。图2-16是英特尔公司的至强E5服务器的架构示意图。</p><p>图2-16　至强E5服务器架构示意图</p><p>![img](09. NUMA系统.assets/Image00043.jpg)</p><p>可以看到，该架构有两个处理器，处理器通过QPI总线相连。每个处理器都有本地的四个通道的内存系统，并且也有属于自己的PCIE总线系统。两个处理器有点不同的是，第一个处理器集成了南桥芯片，而第二个处理器只有本地的PCIE总线。</p><p>和SMP系统相比，NUMA系统访问本地内存的带宽更大，延迟更小，但是访问远程的内存成本相对就高多了。因此，我们要充分利用NUMA系统的这个特点，避免远程访问资源。</p><p>以下是DPDK在NUMA系统中的一些实例。</p><ol><li>Per-core memory。一个处理器上有多个核（core），per-core memory是指每个核都有属于自己的内存，即对于经常访问的数据结构，每个核都有自己的备份。这样做一方面是为了本地内存的需要，另外一方面也是因为上文提到的Cache一致性的需要，避免多个核访问同一个Cache行。</li><li>本地设备本地处理。即用本地的处理器、本地的内存来处理本地的设备上产生的数据。如果有一个PCI设备在node0上，就用node0上的核来处理该设备，处理该设备用到的数据结构和数据缓冲区都从node0上分配。以下是一个分配本地内存的例子：</li></ol><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 为队列结构分配内存</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// allocate memory for the queue structure</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">q </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> rte_zmalloc_socket</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;fm10k&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> sizeof</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">q</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">),</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  RTE_CACHE_LINE_SIZE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> socket_id</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>该例试图分配一个结构体，通过传递socket_id，即node id获得本地内存，并且以Cache行对齐。</p>`,19)]))}const r=i(l,[["render",a],["__file","09. NUMA系统.html.vue"]]),h=JSON.parse('{"path":"/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E4%B8%8B%E5%B1%82%E7%9B%B8%E5%85%B3/Network/%E3%80%8ANFV%E7%9A%84%E5%9F%BA%E7%9F%B3_%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADPDK%E3%80%8B/02.%20Cache%E5%92%8C%E5%86%85%E5%AD%98/09.%20NUMA%E7%B3%BB%E7%BB%9F.html","title":"NUMA系统 (未)","lang":"zh-CN","frontmatter":{"description":"NUMA系统 (未) 之前的章节已经简要介绍过NUMA系统，它是一种多处理器环境下设计的计算机内存结构。NUMA系统是从SMP（Symmetric Multiple Processing，对称多处理器）系统演化而来。 SMP系统最初是在20世纪90年代由Unisys、Convex Computer（后来的HP）、Honeywell、IBM等公司开发的一...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E4%B8%8B%E5%B1%82%E7%9B%B8%E5%85%B3/Network/%E3%80%8ANFV%E7%9A%84%E5%9F%BA%E7%9F%B3_%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADPDK%E3%80%8B/02.%20Cache%E5%92%8C%E5%86%85%E5%AD%98/09.%20NUMA%E7%B3%BB%E7%BB%9F.html"}],["meta",{"property":"og:site_name","content":"MdNote_Public"}],["meta",{"property":"og:title","content":"NUMA系统 (未)"}],["meta",{"property":"og:description","content":"NUMA系统 (未) 之前的章节已经简要介绍过NUMA系统，它是一种多处理器环境下设计的计算机内存结构。NUMA系统是从SMP（Symmetric Multiple Processing，对称多处理器）系统演化而来。 SMP系统最初是在20世纪90年代由Unisys、Convex Computer（后来的HP）、Honeywell、IBM等公司开发的一..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-03T15:36:56.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-03T15:36:56.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"NUMA系统 (未)\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-03T15:36:56.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/MdNote_Public/\\"}]}"]]},"headers":[{"level":1,"title":"NUMA系统 (未)","slug":"numa系统-未","link":"#numa系统-未","children":[]}],"git":{"createdTime":1738597016000,"updatedTime":1738597016000,"contributors":[{"name":"Linc","username":"Linc","email":"762699299@qq.com","commits":1,"url":"https://github.com/Linc"}]},"readingTime":{"minutes":3.29,"words":988},"filePathRelative":"01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/《NFV的基石_深入浅出DPDK》/02. Cache和内存/09. NUMA系统.md","localizedDate":"2025年2月3日","excerpt":"\\n<p>之前的章节已经简要介绍过NUMA系统，它是一种多处理器环境下设计的计算机内存结构。NUMA系统是从SMP（Symmetric Multiple Processing，对称多处理器）系统演化而来。</p>\\n<p>SMP系统最初是在20世纪90年代由Unisys、Convex Computer（后来的HP）、Honeywell、IBM等公司开发的一款商用系统，该系统被广泛应用于Unix类的操作系统，后来又扩展到Windows NT中，该系统有如下特点：</p>\\n<ol>\\n<li>所有的硬件资源都是共享的。即每个处理器都能访问到任何内存、外设等。</li>\\n<li>所有的处理器都是平等的，没有主从关系。</li>\\n<li>内存是统一结构、统一寻址的（UMA，Uniform Memory Architecture）。</li>\\n<li>处理器和内存，处理器和处理器都通过一条总线连接起来。</li>\\n</ol>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/《NFV的基石_深入浅出DPDK》/02. Cache和内存/09. NUMA系统.md","value":{"title":"09. NUMA系统","path":"01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/《NFV的基石_深入浅出DPDK》/02. Cache和内存/09. NUMA系统.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{r as comp,h as data};
