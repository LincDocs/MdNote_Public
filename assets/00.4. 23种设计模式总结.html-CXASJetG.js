import{_ as e,c as l,b as r,o as n}from"./app-mhWA6H0A.js";const i={};function d(a,t){return n(),l("div",null,[...t[0]||(t[0]=[r('<h1 id="《c-设计模式》视频-李建忠" tabindex="-1">《C++设计模式》视频_李建忠</h1><h1 id="目录" tabindex="-1">目录</h1><h1 id="_23种设计模式总结" tabindex="-1">23种设计模式总结</h1><h2 id="分类总结" tabindex="-1">分类总结</h2><h3 id="几种分类方式" tabindex="-1">几种分类方式</h3><ul><li><p>从目的来看（《设计模式：可复用面向对象》中的分类）</p><ul><li><table><thead><tr><th style="text-align:center;">分类</th><th style="text-align:center;">中译</th><th style="text-align:center;">设计模式</th></tr></thead><tbody><tr><td style="text-align:center;">创建型模式<br>（Creational）<br>5</td><td style="text-align:center;">抽象工厂<br>构建器（生成器）<br>工厂方法<br>原型<br>单件</td><td style="text-align:center;">Abstract Factory<br>Builder<br>Factory Method<br>Prototype<br>Singleton</td></tr><tr><td style="text-align:center;">结构型模式<br>（Structural）<br>7</td><td style="text-align:center;">适配器<br>桥接模式<br>组成<br>装饰<br>外观（门面）<br>享元<br>代理</td><td style="text-align:center;">Adapter<br>Bridge<br>Composite<br>Decorator<br>Facade<br>Flyweight<br>Proxy</td></tr><tr><td style="text-align:center;">行为型模式<br>（Behavioral）<br>11</td><td style="text-align:center;">职责链<br>命令<br>解释器（解析器）<br>迭代器<br>中介者<br>备忘录<br>观察者<br>状态<br>策略<br>模板方法<br>访问者</td><td style="text-align:center;">Chain of Responsibility<br>Command<br>Interpreter<br>Iterator<br>Mediator<br>Memento<br>Observer<br>State<br>Strategy<br>Template Method<br>Visitor</td></tr></tbody></table></li></ul></li><li><p>从范围来看</p><ul><li>类模式：处理类与子类的静态关系（偏重继承方案）</li><li>对象模式：处理对象间的动态关系（偏重组合方案）</li></ul></li><li><p>从封装变化角度对模式分类（《设计模式_李建忠视频》中的分类）（其中划掉部分表示比较少用或过时）</p><ul><li><table><thead><tr><th style="text-align:center;">分类</th><th style="text-align:center;">中译</th><th style="text-align:center;">设计模式</th><th style="text-align:center;">目的分类</th></tr></thead><tbody><tr><td style="text-align:center;">组件协作</td><td style="text-align:center;">模板方法<br>策略模式<br>观察者模式</td><td style="text-align:center;">Template Method<br>Strategy<br>Observer/Event</td><td style="text-align:center;">行为型</td></tr><tr><td style="text-align:center;">单一职责</td><td style="text-align:center;">装饰模式<br>桥接模式</td><td style="text-align:center;">Decorator<br>Bridge</td><td style="text-align:center;">结构型</td></tr><tr><td style="text-align:center;">对象创建</td><td style="text-align:center;">工厂模式<br>抽象工厂<br>原型模式<br><s>构建器模式</s></td><td style="text-align:center;">Factory Method<br>Abstract Factory<br>Prototype<br>Builder</td><td style="text-align:center;">创建型</td></tr><tr><td style="text-align:center;">对象性能</td><td style="text-align:center;">单件模式<br>享元模式</td><td style="text-align:center;">Singleton<br>Flyweight</td><td style="text-align:center;">创建型<br>结构型</td></tr><tr><td style="text-align:center;">接口隔离</td><td style="text-align:center;">门面模式<br>代理模式<br>适配器<br><s>中介者模式</s></td><td style="text-align:center;">Facade<br>Proxy<br>Adapter<br>Mediator</td><td style="text-align:center;">结构型<br>行为型</td></tr><tr><td style="text-align:center;">状态变化</td><td style="text-align:center;">状态模式<br><s>备忘录模式</s></td><td style="text-align:center;">State<br>Memento</td><td style="text-align:center;">行为型</td></tr><tr><td style="text-align:center;">数据结构</td><td style="text-align:center;">组合模式<br><s>迭代器模式</s><br><s>职责链模式</s></td><td style="text-align:center;">Composite<br>Iterator<br>Chain of Responsibility</td><td style="text-align:center;">结构型<br>行为型</td></tr><tr><td style="text-align:center;">行为变化</td><td style="text-align:center;"><s>命令模式</s><br><s>访问器模式</s></td><td style="text-align:center;">Command<br>Visitor</td><td style="text-align:center;">行为型</td></tr><tr><td style="text-align:center;">领域问题</td><td style="text-align:center;"><s>解析器模式</s></td><td style="text-align:center;">Interpreter</td><td style="text-align:center;">行为型</td></tr></tbody></table></li></ul></li></ul><h3 id="分类总结-1" tabindex="-1">分类总结</h3><p>略</p><h3 id="个人分类" tabindex="-1">个人分类</h3><p>前面提到过可以用不同的方式对这23种设计模式进行划分和分类</p><p>包括：</p><ul><li>按目的来看（书上的3种）</li><li>按封装变化角度（李建忠的9种）</li><li>按范围来看（2种）</li><li>按启用的原则来看（8种，但一个设计模式会涉及多种原则）</li><li>按重构技法来看（5种，但一个设计模式会涉及多种原则）</li><li>按中间层来看（见下）</li></ul><p>另外，从 Java 中也有一具话叫 “没有什么是加中间层不能解决的，如果有，就再加一层”。我认为我可以以 “中间层” 为切入点，再进行分类。<br> 缺点是这种分类偏代码向，不够本质，归纳流于表面</p><p>有两种中间层提供方法</p><ul><li>a和b之间直接提供。例如 <ul><li>工厂模式：a create b 的中间添加中间层</li><li>适配器模式</li></ul></li><li>通过基类提供。a -&gt; a基 -&gt; b基 -&gt; b，使用这种方法进行传递。<br> 有点类似封装变化点的原则、和晚绑定的技法</li></ul><h2 id="总概共同特点" tabindex="-1">总概共同特点</h2><ul><li><p>一个目标：管理变化，提高复用！</p></li><li><p>两种手段</p><ul><li>分解</li><li>抽象</li></ul></li><li><p>八大原则</p><ul><li>依赖倒置原则（DIP）</li><li>开放封闭原则（OCP）（开闭原则）</li><li>单一职责原则（SRP）</li><li>里氏代换原则（LSP）（Liskov代换原则 / 里斯科夫代换）</li><li>接口隔离原则（ISP）</li><li>合成复用原则（优先使用对象组合，而不是类继承）</li><li>封装变化点</li><li>面向接口编程，而不是面向实现编程</li></ul></li><li><p>五种重构技法</p><ul><li>静态 --&gt; 动态</li><li>早绑定 --&gt; 晚绑定</li><li>继承 --&gt; 组合</li><li>编译时依赖 --&gt; 运行时依赖</li><li>紧耦合 --&gt; 松耦合</li></ul></li><li><p>类图的共同特点与趋向</p><ul><li>继承 --&gt; 组合且是包含一个<strong>抽象基类的指针</strong></li><li><code>class A:B{}</code>（×）</li><li><code>class A{B b}</code>（×）</li><li><code>class A{B* pb}</code>（√）</li></ul></li><li><p>什么时候不用模式（不要盲目模式、为了模式而模式）</p><ul><li>代码可读性很差时</li><li>需求理解还很浅时</li><li>变化没有显现时</li><li>不是系统的关键依赖点</li><li>项目没有复用价值时（比如对于做外包的）</li><li>项目将要发布时</li></ul></li><li><p>设计模式成长之路</p><ul><li>&quot;手中无剑，心中无剑”：见模式而不知</li><li>&quot;手中有剑，心中无剑&quot;：可以识别模式，作为应用开发人员使用模式</li><li>&quot;手中有剑，心中有剑&quot;：作为框架开发人员为应用设计某些模式</li><li>&quot;手中无剑，心中有剑&quot;：忘掉模式，只有原则</li></ul></li></ul><h2 id="每种设计模式的要点" tabindex="-1">每种设计模式的要点</h2><p>略</p><h2 id="常见框架中的设计模式" tabindex="-1">常见框架中的设计模式</h2><h3 id="模板模式-template-method" tabindex="-1">模板模式 Template Method</h3><ul><li>这个太常见了，我就不举例了</li></ul><h3 id="观察者模式-observer" tabindex="-1">观察者模式 Observer</h3><ul><li>Java中的Listener机制</li><li>C#的Event模式</li><li>Qt的single-slot机制、Model-View模式</li><li>Vue的核心——数据驱动视图（Observer模块）</li></ul><h3 id="中介者模式-mediator" tabindex="-1">中介者模式 Mediator</h3><ul><li><p>类似于MVVM（Model-View-ViewModel，模型-视图-视图模型）本质上就是MVC （Model-View-Controller，模型-视图-控制器 ）的改进版</p></li><li><p>类似于Vue（Vue中，<code>v-bind</code>/<code> :</code>应该用的是观察者模式，而<code>v-model</code>双向绑定应该是用的中介者模式）</p></li></ul><h3 id="单例模式-singleton" tabindex="-1">单例模式 Singleton</h3><ul><li>Qt的QPluginLoader的instance()方法</li><li>Qt开发过程中的自定义类PluginManager也用到了这个模式</li></ul><h3 id="职责链模式-chain-of-responsibility" tabindex="-1">职责链模式 Chain of Responsibility</h3><ul><li>Android的事件分发机制</li><li>QT的消息传递机制</li></ul><h3 id="适配器模式-adapter" tabindex="-1">适配器模式 Adapter</h3><ul><li>原生Android开发的控件有用到过</li></ul>',32)])])}const s=e(i,[["render",d]]),o=JSON.parse('{"path":"/01.%20DesignAndDevelop/Develop/03.%20Tools/03.%20%E7%AE%A1%E7%90%86%E5%B1%82/01.%20%E5%A4%9A%E7%B1%BB%E7%AE%A1%E7%90%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E3%80%8AC__%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E8%A7%86%E9%A2%91_%E6%9D%8E%E5%BB%BA%E5%BF%A0/00.4.%2023%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93.html","title":"《C++设计模式》视频_李建忠","lang":"zh-CN","frontmatter":{"description":"《C++设计模式》视频_李建忠 目录 23种设计模式总结 分类总结 几种分类方式 从目的来看（《设计模式：可复用面向对象》中的分类） 从范围来看 类模式：处理类与子类的静态关系（偏重继承方案） 对象模式：处理对象间的动态关系（偏重组合方案） 从封装变化角度对模式分类（《设计模式_李建忠视频》中的分类）（其中划掉部分表示比较少用或过时） 分类总结 略 个...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"《C++设计模式》视频_李建忠\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-12-21T16:15:42.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://LincDocs.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/03.%20Tools/03.%20%E7%AE%A1%E7%90%86%E5%B1%82/01.%20%E5%A4%9A%E7%B1%BB%E7%AE%A1%E7%90%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E3%80%8AC__%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E8%A7%86%E9%A2%91_%E6%9D%8E%E5%BB%BA%E5%BF%A0/00.4.%2023%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93.html"}],["meta",{"property":"og:site_name","content":"MdNote_Public"}],["meta",{"property":"og:title","content":"《C++设计模式》视频_李建忠"}],["meta",{"property":"og:description","content":"《C++设计模式》视频_李建忠 目录 23种设计模式总结 分类总结 几种分类方式 从目的来看（《设计模式：可复用面向对象》中的分类） 从范围来看 类模式：处理类与子类的静态关系（偏重继承方案） 对象模式：处理对象间的动态关系（偏重组合方案） 从封装变化角度对模式分类（《设计模式_李建忠视频》中的分类）（其中划掉部分表示比较少用或过时） 分类总结 略 个..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-21T16:15:42.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-21T16:15:42.000Z"}]]},"git":{"createdTime":1766333742000,"updatedTime":1766333742000,"contributors":[{"name":"Linc","username":"Linc","email":"762699299@qq.com","commits":1,"url":"https://github.com/Linc"}]},"readingTime":{"minutes":5.01,"words":1502},"filePathRelative":"01. DesignAndDevelop/Develop/03. Tools/03. 管理层/01. 多类管理/设计模式/《C++设计模式》视频_李建忠/00.4. 23种设计模式总结.md","excerpt":"\\n<h1>目录</h1>\\n<h1>23种设计模式总结</h1>\\n<h2>分类总结</h2>\\n<h3>几种分类方式</h3>\\n<ul>\\n<li>\\n<p>从目的来看（《设计模式：可复用面向对象》中的分类）</p>\\n<ul>\\n<li>\\n<table>\\n<thead>\\n<tr>\\n<th style=\\"text-align:center\\">分类</th>\\n<th style=\\"text-align:center\\">中译</th>\\n<th style=\\"text-align:center\\">设计模式</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td style=\\"text-align:center\\">创建型模式<br>（Creational）<br>5</td>\\n<td style=\\"text-align:center\\">抽象工厂<br>构建器（生成器）<br>工厂方法<br>原型<br>单件</td>\\n<td style=\\"text-align:center\\">Abstract Factory<br>Builder<br>Factory Method<br>Prototype<br>Singleton</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:center\\">结构型模式<br>（Structural）<br>7</td>\\n<td style=\\"text-align:center\\">适配器<br>桥接模式<br>组成<br>装饰<br>外观（门面）<br>享元<br>代理</td>\\n<td style=\\"text-align:center\\">Adapter<br>Bridge<br>Composite<br>Decorator<br>Facade<br>Flyweight<br>Proxy</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:center\\">行为型模式<br>（Behavioral）<br>11</td>\\n<td style=\\"text-align:center\\">职责链<br>命令<br>解释器（解析器）<br>迭代器<br>中介者<br>备忘录<br>观察者<br>状态<br>策略<br>模板方法<br>访问者</td>\\n<td style=\\"text-align:center\\">Chain of Responsibility<br>Command<br>Interpreter<br>Iterator<br>Mediator<br>Memento<br>Observer<br>State<br>Strategy<br>Template Method<br>Visitor</td>\\n</tr>\\n</tbody>\\n</table>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>从范围来看</p>\\n<ul>\\n<li>类模式：处理类与子类的静态关系（偏重继承方案）</li>\\n<li>对象模式：处理对象间的动态关系（偏重组合方案）</li>\\n</ul>\\n</li>\\n<li>\\n<p>从封装变化角度对模式分类（《设计模式_李建忠视频》中的分类）（其中划掉部分表示比较少用或过时）</p>\\n<ul>\\n<li>\\n<table>\\n<thead>\\n<tr>\\n<th style=\\"text-align:center\\">分类</th>\\n<th style=\\"text-align:center\\">中译</th>\\n<th style=\\"text-align:center\\">设计模式</th>\\n<th style=\\"text-align:center\\">目的分类</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td style=\\"text-align:center\\">组件协作</td>\\n<td style=\\"text-align:center\\">模板方法<br>策略模式<br>观察者模式</td>\\n<td style=\\"text-align:center\\">Template Method<br>Strategy<br>Observer/Event</td>\\n<td style=\\"text-align:center\\">行为型</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:center\\">单一职责</td>\\n<td style=\\"text-align:center\\">装饰模式<br>桥接模式</td>\\n<td style=\\"text-align:center\\">Decorator<br>Bridge</td>\\n<td style=\\"text-align:center\\">结构型</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:center\\">对象创建</td>\\n<td style=\\"text-align:center\\">工厂模式<br>抽象工厂<br>原型模式<br><s>构建器模式</s></td>\\n<td style=\\"text-align:center\\">Factory Method<br>Abstract Factory<br>Prototype<br>Builder</td>\\n<td style=\\"text-align:center\\">创建型</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:center\\">对象性能</td>\\n<td style=\\"text-align:center\\">单件模式<br>享元模式</td>\\n<td style=\\"text-align:center\\">Singleton<br>Flyweight</td>\\n<td style=\\"text-align:center\\">创建型<br>结构型</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:center\\">接口隔离</td>\\n<td style=\\"text-align:center\\">门面模式<br>代理模式<br>适配器<br><s>中介者模式</s></td>\\n<td style=\\"text-align:center\\">Facade<br>Proxy<br>Adapter<br>Mediator</td>\\n<td style=\\"text-align:center\\">结构型<br>行为型</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:center\\">状态变化</td>\\n<td style=\\"text-align:center\\">状态模式<br><s>备忘录模式</s></td>\\n<td style=\\"text-align:center\\">State<br>Memento</td>\\n<td style=\\"text-align:center\\">行为型</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:center\\">数据结构</td>\\n<td style=\\"text-align:center\\">组合模式<br><s>迭代器模式</s><br><s>职责链模式</s></td>\\n<td style=\\"text-align:center\\">Composite<br>Iterator<br>Chain of Responsibility</td>\\n<td style=\\"text-align:center\\">结构型<br>行为型</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:center\\">行为变化</td>\\n<td style=\\"text-align:center\\"><s>命令模式</s><br><s>访问器模式</s></td>\\n<td style=\\"text-align:center\\">Command<br>Visitor</td>\\n<td style=\\"text-align:center\\">行为型</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:center\\">领域问题</td>\\n<td style=\\"text-align:center\\"><s>解析器模式</s></td>\\n<td style=\\"text-align:center\\">Interpreter</td>\\n<td style=\\"text-align:center\\">行为型</td>\\n</tr>\\n</tbody>\\n</table>\\n</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"01. DesignAndDevelop/Develop/03. Tools/03. 管理层/01. 多类管理/设计模式/《C++设计模式》视频_李建忠/00.4. 23种设计模式总结.md","value":{"title":"00.4. 23种设计模式总结","path":"01. DesignAndDevelop/Develop/03. Tools/03. 管理层/01. 多类管理/设计模式/《C++设计模式》视频_李建忠/00.4. 23种设计模式总结.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{s as comp,o as data};
