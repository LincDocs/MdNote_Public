import{_ as i,c as t,a as l,b as e,o as a}from"./app-CqYK0DZN.js";const o={};function r(c,n){return a(),t("div",null,n[0]||(n[0]=[l("h3",{id:"继承的设计技巧",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#继承的设计技巧"},[l("span",null,"继承的设计技巧")])],-1),l("ul",null,[l("li",null,"1.将公共操作和域放在超类"),l("li",null,[e("2.不要使用受保护的域 "),l("ul",null,[l("li",null,"有些程序员认为，将大多数的实例域定义为protected是一个不错的主意，只有这样，子类才能够在需要的时候直接访问它们。 然而，protected机制并不能够带来更好的保护，其原因主要有两点。"),l("li",null,"第一，子类集合是无限制的，任何一个人都能够由某个类派生一个子类，并编写代码以直接访问protected的实例域，从而破坏了封装性。"),l("li",null,"第二，在Java程序设计语言中，在同一个包中的所有类都可以访问proteced域，而不管它是否为这个类的子类。 （这点与C++不同）")])]),l("li",null,"3.使用继承实现“is-a”关系"),l("li",null,[e("4.除非所有继承的方法都有意义，否则不要使用继承 "),l("ul",null,[l("li",{"css-module":"."},"假设想编写一个Holiday类。毫无疑问，每个假日也是一日，并且一日可以用Gregorian Calendar类的实例表示，因此可以使用继承 class Holiday extends GregorianCalender"),l("li",null,"很遗憾，在继承的操作中，假日集不是封闭的。在GregorianCalendar中有一个公有方法add，可以将假日转换成非假日"),l("li",null,"因此，继承对于这个例子来说并不太适宜"),l("li",null,"如果扩展LocalDate就不会出现这个问题。由于这个类是不可变的，所以没有任何方法会把假日变成非假日")])]),l("li",null,[e("5.在覆盖方法时，不要改变预期的行为 "),l("ul",null,[l("li",null,"置换原则不仅应用于语法，而且也可以应用于行为")])]),l("li",null,[e("6.使用多态，而非类型信息 "),l("ul",null,[l("li",null,"面对if-else代码时，都应该考虑使用多态性"),l("li",null,"action1与action2表示的是相同的概念吗？如果是相同的概念，就应该为这个概念定义一个方法，并将其放置在两个类的超类或接口中")])]),l("li",null,[e("7.不要过多地使用反射 "),l("ul",null,[l("li",null,"反射机制使得人们可以通过在运行时查看域和方法，让人们编写出更具有通用性的程序。 这种功能对于编写系统程序来说极其实用，但是通常不适于编写应用程序。"),l("li",null,"反射是很脆弱的，即编译器很难帮助人们发现程序中的错误")])])],-1)]))}const d=i(o,[["render",r],["__file","01. 继承与重用思想.html.vue"]]),p=JSON.parse('{"path":"/01.%20DesignAndDevelop/Develop/01.%20Language/Java/06.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/03.%20%E7%B1%BB%E7%9A%84%E9%87%8D%E7%94%A8/01.%20%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%87%8D%E7%94%A8%E6%80%9D%E6%83%B3.html","title":"01. 继承与重用思想","lang":"zh-CN","frontmatter":{"description":"继承的设计技巧 1.将公共操作和域放在超类 2.不要使用受保护的域 有些程序员认为，将大多数的实例域定义为protected是一个不错的主意，只有这样，子类才能够在需要的时候直接访问它们。 然而，protected机制并不能够带来更好的保护，其原因主要有两点。 第一，子类集合是无限制的，任何一个人都能够由某个类派生一个子类，并编写代码以直接访问prot...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/01.%20Language/Java/06.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/03.%20%E7%B1%BB%E7%9A%84%E9%87%8D%E7%94%A8/01.%20%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%87%8D%E7%94%A8%E6%80%9D%E6%83%B3.html"}],["meta",{"property":"og:site_name","content":"MdNote_Public"}],["meta",{"property":"og:description","content":"继承的设计技巧 1.将公共操作和域放在超类 2.不要使用受保护的域 有些程序员认为，将大多数的实例域定义为protected是一个不错的主意，只有这样，子类才能够在需要的时候直接访问它们。 然而，protected机制并不能够带来更好的保护，其原因主要有两点。 第一，子类集合是无限制的，任何一个人都能够由某个类派生一个子类，并编写代码以直接访问prot..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-01-28T10:12:49.000Z"}],["meta",{"property":"article:modified_time","content":"2025-01-28T10:12:49.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-01-28T10:12:49.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/MdNote_Public/\\"}]}"]]},"headers":[{"level":3,"title":"继承的设计技巧","slug":"继承的设计技巧","link":"#继承的设计技巧","children":[]}],"git":{"createdTime":1738059169000,"updatedTime":1738059169000,"contributors":[{"name":"Linc","username":"Linc","email":"762699299@qq.com","commits":1,"url":"https://github.com/Linc"}]},"readingTime":{"minutes":2,"words":599},"filePathRelative":"01. DesignAndDevelop/Develop/01. Language/Java/06. 面向对象/03. 类的重用/01. 继承与重用思想.md","localizedDate":"2025年1月28日","excerpt":"<h3>继承的设计技巧</h3>\\n<ul>\\n<li>1.将公共操作和域放在超类</li>\\n<li>2.不要使用受保护的域\\n<ul>\\n<li>有些程序员认为，将大多数的实例域定义为protected是一个不错的主意，只有这样，子类才能够在需要的时候直接访问它们。\\n然而，protected机制并不能够带来更好的保护，其原因主要有两点。</li>\\n<li>第一，子类集合是无限制的，任何一个人都能够由某个类派生一个子类，并编写代码以直接访问protected的实例域，从而破坏了封装性。</li>\\n<li>第二，在Java程序设计语言中，在同一个包中的所有类都可以访问proteced域，而不管它是否为这个类的子类。\\n（这点与C++不同）</li>\\n</ul>\\n</li>\\n<li>3.使用继承实现“is-a”关系</li>\\n<li>4.除非所有继承的方法都有意义，否则不要使用继承\\n<ul>\\n<li css-module=\\".\\">假设想编写一个Holiday类。毫无疑问，每个假日也是一日，并且一日可以用Gregorian Calendar类的实例表示，因此可以使用继承\\nclass Holiday extends GregorianCalender</li>\\n<li>很遗憾，在继承的操作中，假日集不是封闭的。在GregorianCalendar中有一个公有方法add，可以将假日转换成非假日</li>\\n<li>因此，继承对于这个例子来说并不太适宜</li>\\n<li>如果扩展LocalDate就不会出现这个问题。由于这个类是不可变的，所以没有任何方法会把假日变成非假日</li>\\n</ul>\\n</li>\\n<li>5.在覆盖方法时，不要改变预期的行为\\n<ul>\\n<li>置换原则不仅应用于语法，而且也可以应用于行为</li>\\n</ul>\\n</li>\\n<li>6.使用多态，而非类型信息\\n<ul>\\n<li>面对if-else代码时，都应该考虑使用多态性</li>\\n<li>action1与action2表示的是相同的概念吗？如果是相同的概念，就应该为这个概念定义一个方法，并将其放置在两个类的超类或接口中</li>\\n</ul>\\n</li>\\n<li>7.不要过多地使用反射\\n<ul>\\n<li>反射机制使得人们可以通过在运行时查看域和方法，让人们编写出更具有通用性的程序。\\n这种功能对于编写系统程序来说极其实用，但是通常不适于编写应用程序。</li>\\n<li>反射是很脆弱的，即编译器很难帮助人们发现程序中的错误</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"01. DesignAndDevelop/Develop/01. Language/Java/06. 面向对象/03. 类的重用/01. 继承与重用思想.md","value":{"title":"01. 继承与重用思想","path":"01. DesignAndDevelop/Develop/01. Language/Java/06. 面向对象/03. 类的重用/01. 继承与重用思想.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{d as comp,p as data};
