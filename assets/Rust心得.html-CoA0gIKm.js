import{_ as s,c as t,b as e,o as n}from"./app-d9fdI8-N.js";const l={};function a(d,i){return n(),t("div",null,[...i[0]||(i[0]=[e(`<h1 id="rust心得-202510" tabindex="-1">Rust心得 - 202510</h1><h2 id="fn-trait-家族" tabindex="-1"><code>Fn</code> trait 家族</h2><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-rust"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 不可变借用的闭包 - 可以并发调用</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Fn</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(&amp;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">self</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) -&gt; </span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">Output</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 可变借用的闭包 - 不能安全并发</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">FnMut</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(&amp;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">mut</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> self</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) -&gt; </span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">Output</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 获取所有权的闭包 - 只能调用一次</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">FnOnce</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">self</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) -&gt; </span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">Output</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="send-sync-trait" tabindex="-1"><code>Send</code> + <code>Sync</code> trait</h2><p>对于真正的并发，还需要：</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-rust"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 可以安全地在线程间传递所有权</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">T</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">Send</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 可以安全地在线程间共享不可变引用</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">T</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">Sync</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="吐槽" tabindex="-1">吐槽</h2><h3 id="类型吐槽" tabindex="-1">类型吐槽</h3><p>对于复合类型的参数和返回值，ts 是最爽的，c enum 稍不爽，rust enum 很不爽</p><h2 id="arc-原理" tabindex="-1">Arc 原理</h2><p>rust 的 <code>Arc::</code> 变量，是通过锁实现的吗？还是什么？性能如何</p><p>你好！这是一个非常好的问题，直击 Rust 并发编程的核心。</p><p>简单来说：<strong><code>Arc</code> 不是通过锁实现的，而是通过原子操作（Atomic Operations）实现的。</strong></p><p>下面详细解释一下：</p><h3 id="_1-arc-是什么-如何工作" tabindex="-1">1. <code>Arc</code> 是什么？如何工作？</h3><p><code>Arc</code> 的全称是 <strong>A</strong>tomically <strong>R</strong>eference <strong>C</strong>ounted（原子引用计数）。它是一个智能指针，允许多个线程以安全的方式“共享”同一份数据的所有权。</p><ul><li>核心机制：引用计数<br><code>Arc</code> 内部包含一个指向堆上数据的指针，以及一个“引用计数器”。 <ul><li>当你克隆（<code>clone</code>）一个 <code>Arc</code> 时，它不会复制底层的数据，而仅仅是原子性地将引用计数加一。</li><li>当一个 <code>Arc</code> 的实例离开作用域（被 <code>drop</code>）时，它会原子性地将引用计数减一。</li><li>只有当引用计数变为 0 时，底层的数据才会被真正地释放。</li></ul></li><li>关键点：原子操作<br> 这里的“原子性”是关键。在多线程环境中，多个线程可能同时尝试增加或减少引用计数。如果使用普通的加减法，会导致数据竞争（Data Race），最终计数会出错。<br><code>Arc</code> 使用的是 CPU 提供的原子指令（例如 <code>fetchadd</code>, <code>fetchsub</code>）。这些指令是不可中断的，能确保即使在多核 CPU 上，计数的修改也是完整、独立的，从而保证了线程安全。</li></ul><h3 id="_2-arc-和锁-mutex-的区别" tabindex="-1">2. <code>Arc</code> 和锁（<code>Mutex</code>）的区别</h3><p>这是最容易混淆的地方：</p><ul><li><strong><code>Arc</code>：保证“共享所有权”的线程安全。</strong><br> 它只保证引用计数本身在多线程下的正确性。它<strong>不提供</strong>对内部数据的修改（mutability）能力。你不能直接通过一个 <code>Arc&lt;T&gt;</code> 来修改 <code>T</code>。</li><li><strong>锁 (<code>Mutex</code>, <code>RwLock</code>)：保证“数据访问”的线程安全。</strong><br> 锁提供的是“互斥”（Mutual Exclusion）。当你想要修改数据时，必须先获取锁。一旦一个线程获得了锁，其他线程就必须等待，直到该锁被释放。这保证了在任何时刻，只有一个线程能访问或修改数据。</li></ul><h3 id="_3-arc-和-mutex-的结合使用" tabindex="-1">3. <code>Arc</code> 和 <code>Mutex</code> 的结合使用</h3><p>在实际的并发编程中，我们常常需要既能在线程间共享数据，又能修改它。因此，<code>Arc&lt;Mutex&lt;T&gt;&gt;</code> 这个组合非常常见：</p><ul><li><code>Arc&lt;T&gt;</code>：让多个线程都能“拥有”指向 <code>T</code> 的指针。</li><li><code>Mutex&lt;T&gt;</code>：包裹住数据 <code>T</code>，提供一个安全的修改机制。</li></ul><p>当你这样做时：</p><ol><li>使用 <code>Arc::clone()</code> 将 <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> 的所有权安全地分发给多个线程。这个过程是无锁的，只涉及原子操作。</li><li>在某个线程中，当你需要访问或修改内部数据 <code>T</code> 时，你必须调用 <code>.lock()</code> 方法来获取 <code>Mutex</code> 的锁。这个过程是<strong>阻塞的</strong>，可能会产生等待。</li></ol><p>所以，<strong>锁的开销来自于 <code>Mutex</code>，而不是 <code>Arc</code></strong>。</p><h3 id="_4-性能如何" tabindex="-1">4. 性能如何？</h3><ul><li><code>Arc</code> 本身的性能非常好 <ul><li>克隆 <code>Arc</code> 和销毁它只涉及一次原子操作。在现代 CPU 上，原子操作是一条硬件指令，速度非常快，远比操作系统层面的锁（获取和释放）要轻量。</li><li>与单线程的 <code>Rc</code>（非原子引用计数）相比，<code>Arc</code> 会有一点点性能开销，因为原子操作需要处理 CPU 缓存同步等问题，比普通整数加减要慢一些。但在绝大多数情况下，这点开销是完全可以接受的，并且是线程安全所必需的。</li></ul></li><li>瓶颈通常在锁上<br> 如果你的程序中大量使用了 <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>，性能瓶颈几乎总是出现在对 <code>Mutex</code> 的争用上。如果多个线程频繁地需要获取同一个锁，就会导致大量的等待，从而降低程序的并发性能。</li></ul><h3 id="总结" tabindex="-1">总结</h3><table><thead><tr><th style="text-align:left;">特性</th><th style="text-align:left;"><code>Arc</code></th><th style="text-align:left;"><code>Mutex</code></th></tr></thead><tbody><tr><td style="text-align:left;">目的</td><td style="text-align:left;">在线程间安全地共享数据所有权</td><td style="text-align:left;">保护数据，提供安全的独占访问/修改</td></tr><tr><td style="text-align:left;">实现机制</td><td style="text-align:left;">原子引用计数 (Atomic Operations)</td><td style="text-align:left;">操作系统提供的锁机制 (如 futex)</td></tr><tr><td style="text-align:left;">是否加锁</td><td style="text-align:left;"><strong>否</strong></td><td style="text-align:left;"><strong>是</strong></td></tr><tr><td style="text-align:left;">性能开销</td><td style="text-align:left;"><strong>低</strong> (一次原子指令)</td><td style="text-align:left;"><strong>高</strong> (可能涉及系统调用和线程阻塞)</td></tr></tbody></table><h2 id="再看-rust-match" tabindex="-1">再看 rust match</h2><p>用久了对 match 有了更深层次的体会，一句话总结:</p><p>ts 的 if 允许类型缩窄，<em>而 rust 的 if 不允许类型缩窄</em>。<strong>rust 的 match 就是带类型缩窄的 if 语句</strong></p>`,33)])])}const r=s(l,[["render",a]]),h=JSON.parse('{"path":"/03.%20SkillAndProduction/%E6%9C%AA%E5%88%86%E7%B1%BB/Rust%E5%BF%83%E5%BE%97.html","title":"Rust心得 - 202510","lang":"zh-CN","frontmatter":{"description":"Rust心得 - 202510 Fn trait 家族 Send + Sync trait 对于真正的并发，还需要： 吐槽 类型吐槽 对于复合类型的参数和返回值，ts 是最爽的，c enum 稍不爽，rust enum 很不爽 Arc 原理 rust 的 Arc:: 变量，是通过锁实现的吗？还是什么？性能如何 你好！这是一个非常好的问题，直击 Rust...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Rust心得 - 202510\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-11-24T19:40:57.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://LincDocs.github.io/MdNote_Public/03.%20SkillAndProduction/%E6%9C%AA%E5%88%86%E7%B1%BB/Rust%E5%BF%83%E5%BE%97.html"}],["meta",{"property":"og:site_name","content":"MdNote_Public"}],["meta",{"property":"og:title","content":"Rust心得 - 202510"}],["meta",{"property":"og:description","content":"Rust心得 - 202510 Fn trait 家族 Send + Sync trait 对于真正的并发，还需要： 吐槽 类型吐槽 对于复合类型的参数和返回值，ts 是最爽的，c enum 稍不爽，rust enum 很不爽 Arc 原理 rust 的 Arc:: 变量，是通过锁实现的吗？还是什么？性能如何 你好！这是一个非常好的问题，直击 Rust..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-11-24T19:40:57.000Z"}],["meta",{"property":"article:modified_time","content":"2025-11-24T19:40:57.000Z"}]]},"git":{"createdTime":1764013257000,"updatedTime":1764013257000,"contributors":[{"name":"Linc","username":"Linc","email":"762699299@qq.com","commits":1,"url":"https://github.com/Linc"}]},"readingTime":{"minutes":4.25,"words":1274},"filePathRelative":"03. SkillAndProduction/未分类/Rust心得.md","excerpt":"\\n<h2><code>Fn</code> trait 家族</h2>\\n<div class=\\"language-rust line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"rust\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code class=\\"language-rust\\"><span class=\\"line\\"><span style=\\"--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic\\">// 不可变借用的闭包 - 可以并发调用</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#4078F2;--shiki-dark:#61AFEF\\">Fn</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">(&amp;</span><span style=\\"--shiki-light:#E45649;--shiki-dark:#E5C07B\\">self</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">) -&gt; </span><span style=\\"--shiki-light:#0184BC;--shiki-dark:#E5C07B\\">Output</span></span>\\n<span class=\\"line\\"></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic\\">// 可变借用的闭包 - 不能安全并发</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#4078F2;--shiki-dark:#61AFEF\\">FnMut</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">(&amp;</span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">mut</span><span style=\\"--shiki-light:#E45649;--shiki-dark:#E5C07B\\"> self</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">) -&gt; </span><span style=\\"--shiki-light:#0184BC;--shiki-dark:#E5C07B\\">Output</span></span>\\n<span class=\\"line\\"></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic\\">// 获取所有权的闭包 - 只能调用一次</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#4078F2;--shiki-dark:#61AFEF\\">FnOnce</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">(</span><span style=\\"--shiki-light:#E45649;--shiki-dark:#E5C07B\\">self</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">) -&gt; </span><span style=\\"--shiki-light:#0184BC;--shiki-dark:#E5C07B\\">Output</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"03. SkillAndProduction/未分类/Rust心得.md","value":{"title":"Rust心得","path":"03. SkillAndProduction/未分类/Rust心得.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{r as comp,h as data};
