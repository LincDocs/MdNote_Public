import{_ as a,c as i,f as c,o as t}from"./app-FxoUaQFi.js";const l={};function h(n,e){return t(),i("div",null,e[0]||(e[0]=[c('<h1 id="cache的写策略" tabindex="-1"><a class="header-anchor" href="#cache的写策略"><span>Cache的写策略</span></a></h1><p>内存的数据被加载到Cache后，在某个时刻其要被写回内存，对于这个时刻的选取，有如下几个不同的策略。</p><h2 id="通用策略" tabindex="-1"><a class="header-anchor" href="#通用策略"><span>通用策略</span></a></h2><h3 id="直写-write-through" tabindex="-1"><a class="header-anchor" href="#直写-write-through"><span>直写（write-through）</span></a></h3><ul><li><p>策略：直写指在处理器<em>对Cache写入的同时，将数据写入到内存中</em></p></li><li><p>优点：这种策略保证了在<em>任何时刻，内存的数据和Cache中的数据都是同步的</em>，这种方式简单、可靠。</p></li><li><p>缺点：但由于处理器每次对Cache更新时都要对内存进行写操作，因此总线工作繁忙，内存的带宽被大大占用，因此运行速度会受到影响。</p><p>假设一段程序在频繁地修改一个局部变量，尽管这个局部变量的生命周期很短，而且其他进程/线程也用不到它，CPU依然会频繁地在Cache和内存之间交换数据，造成不必要的带宽损失。</p></li></ul><h3 id="回写-write-back" tabindex="-1"><a class="header-anchor" href="#回写-write-back"><span>回写（write-back）</span></a></h3><ul><li><p>策略：回写系统通过将Cache line的标志位字段<em>添加一个Dirty标志位</em>。当处理器在改写了某个Cache line后，并不是马上把其写回内存，而是将该Cache line的Dirty标志设置为1。 当处理器<em>再次修改</em>该Cache line并且写回到Cache中，查表发现该Dirty位已经为1，则先将Cache line内容写回到内存中相应的位置，再将新数据写到Cache中。</p></li><li><p>优点：回写相对于直写而言是一种高效的方法。直写不仅浪费时间，而且有时是不必要的，比如上文提到的局部变量的例子。</p></li><li><p>缺点：其实，回写策略在多核系统中会引起Cache一致性的问题。设想有两个处理器核心都需要对某个内存块进行读写，其中一个核心已经修改了该数据块，并且写回到Cache中，设置了Dirty位；这时另外一个核心也完成了该内存块的修改，并且准备写入到Cache中，这时才发现该Cache line是“脏”的。</p><p>在这种情况下，Cache如何处理呢？之后的章节我们会继续这个话题。</p></li></ul><h3 id="总结、比较" tabindex="-1"><a class="header-anchor" href="#总结、比较"><span>总结、比较</span></a></h3><p>回写相较于直写，简而言之就是：</p><ul><li>修改Cache的行为是不变的，改变的是与此同时往内存进行同步的频率</li><li>频率低则高效，但更容易引发资源竞争冲突</li></ul><h2 id="特殊的地址空间策略" tabindex="-1"><a class="header-anchor" href="#特殊的地址空间策略"><span>特殊的地址空间策略</span></a></h2><p>除了上述这两种写策略，还有WC（write-combining）和UC（uncacheable）。这两种策略都是针对特殊的地址空间来使用的。</p><h3 id="wc-write-combining-集合写" tabindex="-1"><a class="header-anchor" href="#wc-write-combining-集合写"><span>WC（write-combining，集合写）</span></a></h3><ul><li><p>场景：针对于具体设备内存（如显卡的RAM）的一种优化处理策略。</p><p>对于这些设备来说，数据从Cache到内存转移的开销比直接访问相应的内存的开销还要高得多，所以应该尽量<em>避免过多的数据转移</em>。</p><p>例如：试想，如果一个Cache line里的字被改写了，处理器将其写回内存，紧接着<em>又一个字</em>被改写了，处理器又将该Cache line写回内存，这样就显得低效。</p><p>例如：符合这种情况的一个例子就是<em>显示屏上水平相连的像素点数据</em>。</p></li><li><p>策略：顾名思义，这种策略就是当一个Cache line里的数据一个字一个字地都被改写完了之后，才将该Cache line写回到内存中。</p></li></ul><h3 id="uc-uncacheable-不可缓存的" tabindex="-1"><a class="header-anchor" href="#uc-uncacheable-不可缓存的"><span>UC（uncacheable，不可缓存的）</span></a></h3><ul><li><p>场景：uncacheable内存是一部分特殊的内存</p><p>例如：比如PCI设备的I/O空间通过MMIO方式被映射成内存来访问。这种内存是不能缓存在Cache中的，因为设备驱动在修改这种内存时，总是期望这种改变能够尽快通过总线写回到设备内部，从而驱动设备做出相应的动作。如果放在Cache中，硬件就无法收到指令。</p></li></ul>',16)]))}const o=a(l,[["render",h],["__file","04. Cache的写策略.html.vue"]]),p=JSON.parse('{"path":"/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E4%B8%8B%E5%B1%82%E7%9B%B8%E5%85%B3/Network/%E3%80%8ANFV%E7%9A%84%E5%9F%BA%E7%9F%B3_%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADPDK%E3%80%8B/02.%20Cache%E5%92%8C%E5%86%85%E5%AD%98/04.%20Cache%E7%9A%84%E5%86%99%E7%AD%96%E7%95%A5.html","title":"Cache的写策略","lang":"zh-CN","frontmatter":{"description":"Cache的写策略 内存的数据被加载到Cache后，在某个时刻其要被写回内存，对于这个时刻的选取，有如下几个不同的策略。 通用策略 直写（write-through） 策略：直写指在处理器对Cache写入的同时，将数据写入到内存中 优点：这种策略保证了在任何时刻，内存的数据和Cache中的数据都是同步的，这种方式简单、可靠。 缺点：但由于处理器每次对C...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E4%B8%93%E9%A2%98%E6%88%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%97%E5%85%B8%E7%89%88/%E4%B8%8B%E5%B1%82%E7%9B%B8%E5%85%B3/Network/%E3%80%8ANFV%E7%9A%84%E5%9F%BA%E7%9F%B3_%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADPDK%E3%80%8B/02.%20Cache%E5%92%8C%E5%86%85%E5%AD%98/04.%20Cache%E7%9A%84%E5%86%99%E7%AD%96%E7%95%A5.html"}],["meta",{"property":"og:site_name","content":"MdNote_Public"}],["meta",{"property":"og:title","content":"Cache的写策略"}],["meta",{"property":"og:description","content":"Cache的写策略 内存的数据被加载到Cache后，在某个时刻其要被写回内存，对于这个时刻的选取，有如下几个不同的策略。 通用策略 直写（write-through） 策略：直写指在处理器对Cache写入的同时，将数据写入到内存中 优点：这种策略保证了在任何时刻，内存的数据和Cache中的数据都是同步的，这种方式简单、可靠。 缺点：但由于处理器每次对C..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-09T07:57:06.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-09T07:57:06.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Cache的写策略\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-09T07:57:06.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/MdNote_Public/\\"}]}"]]},"headers":[{"level":1,"title":"Cache的写策略","slug":"cache的写策略","link":"#cache的写策略","children":[{"level":2,"title":"通用策略","slug":"通用策略","link":"#通用策略","children":[{"level":3,"title":"直写（write-through）","slug":"直写-write-through","link":"#直写-write-through","children":[]},{"level":3,"title":"回写（write-back）","slug":"回写-write-back","link":"#回写-write-back","children":[]},{"level":3,"title":"总结、比较","slug":"总结、比较","link":"#总结、比较","children":[]}]},{"level":2,"title":"特殊的地址空间策略","slug":"特殊的地址空间策略","link":"#特殊的地址空间策略","children":[{"level":3,"title":"WC（write-combining，集合写）","slug":"wc-write-combining-集合写","link":"#wc-write-combining-集合写","children":[]},{"level":3,"title":"UC（uncacheable，不可缓存的）","slug":"uc-uncacheable-不可缓存的","link":"#uc-uncacheable-不可缓存的","children":[]}]}]}],"git":{"createdTime":1739087826000,"updatedTime":1739087826000,"contributors":[{"name":"Linc","username":"Linc","email":"762699299@qq.com","commits":1,"url":"https://github.com/Linc"}]},"readingTime":{"minutes":3.36,"words":1009},"filePathRelative":"01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/《NFV的基石_深入浅出DPDK》/02. Cache和内存/04. Cache的写策略.md","localizedDate":"2025年2月9日","excerpt":"\\n<p>内存的数据被加载到Cache后，在某个时刻其要被写回内存，对于这个时刻的选取，有如下几个不同的策略。</p>\\n<h2>通用策略</h2>\\n<h3>直写（write-through）</h3>\\n<ul>\\n<li>\\n<p>策略：直写指在处理器<em>对Cache写入的同时，将数据写入到内存中</em></p>\\n</li>\\n<li>\\n<p>优点：这种策略保证了在<em>任何时刻，内存的数据和Cache中的数据都是同步的</em>，这种方式简单、可靠。</p>\\n</li>\\n<li>\\n<p>缺点：但由于处理器每次对Cache更新时都要对内存进行写操作，因此总线工作繁忙，内存的带宽被大大占用，因此运行速度会受到影响。</p>\\n<p>假设一段程序在频繁地修改一个局部变量，尽管这个局部变量的生命周期很短，而且其他进程/线程也用不到它，CPU依然会频繁地在Cache和内存之间交换数据，造成不必要的带宽损失。</p>\\n</li>\\n</ul>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/《NFV的基石_深入浅出DPDK》/02. Cache和内存/04. Cache的写策略.md","value":{"title":"04. Cache的写策略","path":"01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 专题或子系统的字典版/下层相关/Network/《NFV的基石_深入浅出DPDK》/02. Cache和内存/04. Cache的写策略.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{o as comp,p as data};
