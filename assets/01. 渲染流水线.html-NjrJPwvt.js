import{_ as t,c as n,f as l,o as i}from"./app-FxoUaQFi.js";const r="/MdNote_Public/assets/%E6%A6%82%E5%BF%B5%E6%B5%81%E6%B0%B4%E7%BA%BF-BYr7dtkY.png",s="/MdNote_Public/assets/CopyDataToGPU-B2uFXErk.png",p="/MdNote_Public/assets/SetRenderState-BDI2jWyx.png",h="/MdNote_Public/assets/DrawCall-Bfy0lsaR.png",a="/MdNote_Public/assets/GPU%E6%B5%81%E6%B0%B4%E7%BA%BF-Wp4eROQC.png",d="/MdNote_Public/assets/VertexShaderProcess-BQOfZ7rL.png",c="/MdNote_Public/assets/Clipping-BpIsaxLl.png",o="/MdNote_Public/assets/ScreenMapping-DiHKVyDR.png",g="/MdNote_Public/assets/TriangleSetupAndTraversal-BoLaTb5L.png",m="/MdNote_Public/assets/FragmentShader-BZ0fkkFb.png",u="/MdNote_Public/assets/Stencil%20Test_Depth%20Test-Dys7Mah_.png",_="/MdNote_Public/assets/Blending-D9VbtKnn.png",y={};function B(k,e){return i(),n("div",null,e[0]||(e[0]=[l('<h1 id="unityshadow" tabindex="-1"><a class="header-anchor" href="#unityshadow"><span>UnityShadow</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="渲染流水线-流程顺序-新编并简化" tabindex="-1"><a class="header-anchor" href="#渲染流水线-流程顺序-新编并简化"><span>渲染流水线（流程顺序 - 新编并简化）</span></a></h1><p>图2.2 渲染流水线中的三个概念阶段</p><p><img src="'+r+'" alt="概念流水线.png-16.9kB" loading="lazy"></p><h2 id="应用阶段-application-stage-cpu实现" tabindex="-1"><a class="header-anchor" href="#应用阶段-application-stage-cpu实现"><span>应用阶段（<em>Application Stage</em>）（CPU实现）</span></a></h2><h3 id="准备好场景数据" tabindex="-1"><a class="header-anchor" href="#准备好场景数据"><span>准备好场景数据</span></a></h3><p>（例如：摄像机位置、视锥体、场景中包含哪些模型、使用了哪些光源等等）</p><h3 id="剔除不可见物体" tabindex="-1"><a class="header-anchor" href="#剔除不可见物体"><span>剔除不可见物体</span></a></h3><p>为了提高渲染性能，需要作一个粗粒度剔除（<em>culling</em>）工作，剔除不可见物体不提交给集合阶段</p><p>（注：这里的不可见是指被隐藏而非被遮挡而不可见）</p><h3 id="设置好每个模型的渲染状态" tabindex="-1"><a class="header-anchor" href="#设置好每个模型的渲染状态"><span>设置好每个模型的渲染状态</span></a></h3><p>需要设置好每个模型的渲染状态（例如：使用的材质（漫反射颜色、高光反射颜色）、纹理、Shader等等）</p><h2 id="从cpu过渡到gpu" tabindex="-1"><a class="header-anchor" href="#从cpu过渡到gpu"><span>从CPU过渡到GPU</span></a></h2><h3 id="把数据加载到到显存中" tabindex="-1"><a class="header-anchor" href="#把数据加载到到显存中"><span>把数据加载到到显存中</span></a></h3><p>图2.3 渲染所需的数据（两张纹理以及3个网格）从硬盘最终加载到显存中。在渲染时，GPU可以快速访问这些数据</p><p><img src="'+s+'" alt="CopyDataToGPU.png-86.5kB" loading="lazy"></p><h3 id="设置渲染状态" tabindex="-1"><a class="header-anchor" href="#设置渲染状态"><span>设置渲染状态</span></a></h3><p>图2.4 在同一状态下渲染三个网格。由于没有更改渲染状态，因此三个网格的外观看起来像是同一种材质的物体</p><p><img src="'+p+'" alt="SetRenderState.png-157.1kB" loading="lazy"></p><h3 id="调用draw-call" tabindex="-1"><a class="header-anchor" href="#调用draw-call"><span>调用Draw Call</span></a></h3><p>图2.5 CPU通过调用Draw Call来告诉GPU开始进行一个渲染过程。一个Draw Call会指向本次调用需要渲染的图元列表</p><p><img src="'+h+'" alt="DrawCall.png-59.1kB" loading="lazy"></p><h2 id="几何阶段-geometry-stage-gpu实现" tabindex="-1"><a class="header-anchor" href="#几何阶段-geometry-stage-gpu实现"><span>几何阶段（<em>Geometry Stage</em>）（GPU实现）</span></a></h2><p>图2.6 GPU的渲染流水线实现。颜色表示了不同阶段的可配置性或可编程性</p><p><img src="'+a+'" alt="GPU流水线.png-82.2kB" loading="lazy"></p><h3 id="顶点着色器-vertex-shader-可编程" tabindex="-1"><a class="header-anchor" href="#顶点着色器-vertex-shader-可编程"><span>顶点着色器（<em>Vertex Shader</em>）（可编程）</span></a></h3><ul><li>主要工作：坐标变换、逐顶点光照</li></ul><p>图2.7 GPU在每个输入的网格顶点上都会调用顶点着色器。顶点着色器必须进行顶点的坐标变换，需要时还可以计算和输出顶点的颜色。例如，我们可能需要进行逐顶点的光照</p><p><img src="'+d+'" alt="VertexShaderProcess.png-43kB" loading="lazy"></p><p>图2.8 顶点着色器会将模型顶点的位置变换到齐次裁剪坐标空间下，进行输出后再由硬件做透视除法得到NDC下的坐标</p><p>![Vertex Shader.png-34.9kB](01.%20渲染流水线.assets/Vertex Shader.png)</p><h3 id="曲面细分着色器-tessellation-shader-可编程、可选" tabindex="-1"><a class="header-anchor" href="#曲面细分着色器-tessellation-shader-可编程、可选"><span>曲面细分着色器（<em>Tessellation Shader</em>）（可编程、可选）</span></a></h3><ul><li>作用：细分图元</li></ul><h3 id="几何着色器-geometry-shader-可编程、可选" tabindex="-1"><a class="header-anchor" href="#几何着色器-geometry-shader-可编程、可选"><span>几何着色器（<em>Geometry Shader</em>）（可编程、可选）</span></a></h3><ul><li>作用：执行逐图元（<em>Per-Primitive</em>）的着色操作，或者被用于产生更多的图元</li></ul><h3 id="裁剪-clipping-可配置" tabindex="-1"><a class="header-anchor" href="#裁剪-clipping-可配置"><span>裁剪（<em>Clipping</em>）（可配置）</span></a></h3><ul><li>作用：将不在摄像机视野内的顶点裁剪掉，并剔除某些三角图元的面片</li></ul><p>图2.9 只有在单位立方体的图元才需要被继续处理。因此，完全在单位立方体外部的图元（红色三角形）被舍弃，完全在单位立方体内部的图元（绿色三角形）将被保留。和单位立方体相交的图元（黄色三角形）会被裁剪，新的顶点会被生成，原来在外部的顶点会被舍弃</p><p><img src="'+c+'" alt="Clipping.png-25.5kB" loading="lazy"></p><h3 id="屏幕映射-screen-mapping-固定" tabindex="-1"><a class="header-anchor" href="#屏幕映射-screen-mapping-固定"><span>屏幕映射（<em>Screen Mapping</em>）（固定）</span></a></h3><ul><li>作用：负责把每个图元的坐标转换到屏幕坐标系（<em>Screen Coordinates</em>）中</li></ul><p>图2.10 屏幕映射将x、y坐标从（-1, 1）范围转换到屏幕坐标系中</p><p><img src="'+o+'" alt="ScreenMapping.png-22.6kB" loading="lazy"></p><p>图2.11 OpenGL和DirectX的屏幕坐标系差异。对于一张512*512大小的图像，在OpenGL中其（0, 0）点在左下角，而在DirectX中其(0, 0)点在左上角</p><p>![Screen Mapping_OpenGL_DirectX.png-26.9kB](01.%20渲染流水线.assets/Screen Mapping_OpenGL_DirectX.png)</p><h2 id="光栅化阶段-rasterizer-stage-gpu实现" tabindex="-1"><a class="header-anchor" href="#光栅化阶段-rasterizer-stage-gpu实现"><span>光栅化阶段（<em>Rasterizer Stage</em>）（GPU实现）</span></a></h2><p>有两个重要的目标：计算每个图元覆盖了哪些像素，以及为这些像素计算它们的颜色</p><p>图2.6 GPU的渲染流水线实现。颜色表示了不同阶段的可配置性或可编程性</p><p><img src="'+a+'" alt="GPU流水线.png-82.2kB" loading="lazy"></p><h3 id="三角形设置-triangle-setup-固定" tabindex="-1"><a class="header-anchor" href="#三角形设置-triangle-setup-固定"><span>三角形设置（<em>Triangle Setup</em>）（固定）</span></a></h3><ul><li>作用：计算光栅化一个三角网格所需的信息（在此之前处理的都是图元中的点）</li></ul><h3 id="三角形遍历-triangle-traversal-固定" tabindex="-1"><a class="header-anchor" href="#三角形遍历-triangle-traversal-固定"><span>三角形遍历（<em>Triangle Traversal</em>）（固定）</span></a></h3><ul><li>作用：检查每个像素是否被一个三角网格所覆盖，这个阶段也被称为<code>扫描变换</code>（<em>Scan Conversion</em>）</li></ul><p>图2.12 三角形遍历的过程。根据几何阶段输出的顶点信息，最终得到该三角网格覆盖的像素位置。对应像素会生成一个片元，而片元中的状态是对三个顶点的信息进行插值得到的。例如，对图2.12中三个顶点的深度进行插值得到其重心位置对应的片元的深度值为-10.0</p><p><img src="'+g+'" alt="TriangleSetupAndTraversal.png-80kB" loading="lazy"></p><h3 id="片元着色器-fragment-shader-可编程、可选-这步不太懂" tabindex="-1"><a class="header-anchor" href="#片元着色器-fragment-shader-可编程、可选-这步不太懂"><span>片元着色器（<em>Fragment Shader</em>）（可编程、可选）<mark>这步不太懂</mark></span></a></h3><ul><li>作用：完成一些渲染技术（例如纹理采样）</li></ul><p>图2.12 三角形遍历的过程。根据几何阶段输出的顶点信息，最终得到该三角网格覆盖的像素位置。对应像素会生成一个片元，而片元中的状态是对三个顶点的信息进行插值得到的。例如，对图2.12中三个顶点的深度进行插值得到其重心位置对应的片元的深度值为-10.0</p><p><img src="'+m+'" alt="FragmentShader.png-42.4kB" loading="lazy"></p><h3 id="逐片元操作-per-fragment-operations-可配置" tabindex="-1"><a class="header-anchor" href="#逐片元操作-per-fragment-operations-可配置"><span>逐片元操作（<em>Per-Fragment Operations</em>）（可配置）</span></a></h3><ul><li>作用：逐片元（<em>Per-Fragment Operations</em>）的着色操作（例如修改颜色、深度缓冲、进行魂环等等）</li></ul><p>图2.14 逐片元操作阶段所做的操作。只有通过了所有的测试后，新生成的片元才能和颜色缓冲区中已经存在的像素颜色进行混合，最后再写入颜色缓冲区中</p><p>![Per-fragment Operations.png-23.1kB](01.%20渲染流水线.assets/Per-fragment Operations.png)</p><h4 id="模板测试-stencil-test" tabindex="-1"><a class="header-anchor" href="#模板测试-stencil-test"><span>模板测试（<em>Stencil Test</em>）</span></a></h4><p>图2.15 模板测试和深度测试的简化流程图</p><p><img src="'+u+'" alt="Stencil Test_Depth Test.png-93.5kB" loading="lazy"></p><h4 id="深度测试-depth-test" tabindex="-1"><a class="header-anchor" href="#深度测试-depth-test"><span>深度测试（<em>Depth Test</em>）</span></a></h4><ul><li>深度测试补充：对于被其他物体遮挡的就不需要出现在屏幕上</li></ul><h4 id="混合-blend" tabindex="-1"><a class="header-anchor" href="#混合-blend"><span>混合（<em>Blend</em>）</span></a></h4><p>图2.16 混合操作的简化流程图</p><p><img src="'+_+'" alt="Blending.png-67.6kB" loading="lazy"></p>',72)]))}const b=t(y,[["render",B],["__file","01. 渲染流水线.html.vue"]]),P=JSON.parse('{"path":"/01.%20DesignAndDevelop/3D/Render/%E3%80%8AUnityShadow%E3%80%8B/01.%20%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF.html","title":"UnityShadow","lang":"zh-CN","frontmatter":{"description":"UnityShadow 目录 渲染流水线（流程顺序 - 新编并简化） 图2.2 渲染流水线中的三个概念阶段 概念流水线.png-16.9kB 应用阶段（Application Stage）（CPU实现） 准备好场景数据 （例如：摄像机位置、视锥体、场景中包含哪些模型、使用了哪些光源等等） 剔除不可见物体 为了提高渲染性能，需要作一个粗粒度剔除（cull...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/MdNote_Public/01.%20DesignAndDevelop/3D/Render/%E3%80%8AUnityShadow%E3%80%8B/01.%20%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF.html"}],["meta",{"property":"og:site_name","content":"MdNote_Public"}],["meta",{"property":"og:title","content":"UnityShadow"}],["meta",{"property":"og:description","content":"UnityShadow 目录 渲染流水线（流程顺序 - 新编并简化） 图2.2 渲染流水线中的三个概念阶段 概念流水线.png-16.9kB 应用阶段（Application Stage）（CPU实现） 准备好场景数据 （例如：摄像机位置、视锥体、场景中包含哪些模型、使用了哪些光源等等） 剔除不可见物体 为了提高渲染性能，需要作一个粗粒度剔除（cull..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-09T07:57:06.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-09T07:57:06.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"UnityShadow\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-09T07:57:06.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/MdNote_Public/\\"}]}"]]},"headers":[{"level":1,"title":"UnityShadow","slug":"unityshadow","link":"#unityshadow","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"渲染流水线（流程顺序 - 新编并简化）","slug":"渲染流水线-流程顺序-新编并简化","link":"#渲染流水线-流程顺序-新编并简化","children":[{"level":2,"title":"应用阶段（Application Stage）（CPU实现）","slug":"应用阶段-application-stage-cpu实现","link":"#应用阶段-application-stage-cpu实现","children":[{"level":3,"title":"准备好场景数据","slug":"准备好场景数据","link":"#准备好场景数据","children":[]},{"level":3,"title":"剔除不可见物体","slug":"剔除不可见物体","link":"#剔除不可见物体","children":[]},{"level":3,"title":"设置好每个模型的渲染状态","slug":"设置好每个模型的渲染状态","link":"#设置好每个模型的渲染状态","children":[]}]},{"level":2,"title":"从CPU过渡到GPU","slug":"从cpu过渡到gpu","link":"#从cpu过渡到gpu","children":[{"level":3,"title":"把数据加载到到显存中","slug":"把数据加载到到显存中","link":"#把数据加载到到显存中","children":[]},{"level":3,"title":"设置渲染状态","slug":"设置渲染状态","link":"#设置渲染状态","children":[]},{"level":3,"title":"调用Draw Call","slug":"调用draw-call","link":"#调用draw-call","children":[]}]},{"level":2,"title":"几何阶段（Geometry Stage）（GPU实现）","slug":"几何阶段-geometry-stage-gpu实现","link":"#几何阶段-geometry-stage-gpu实现","children":[{"level":3,"title":"顶点着色器（Vertex Shader）（可编程）","slug":"顶点着色器-vertex-shader-可编程","link":"#顶点着色器-vertex-shader-可编程","children":[]},{"level":3,"title":"曲面细分着色器（Tessellation Shader）（可编程、可选）","slug":"曲面细分着色器-tessellation-shader-可编程、可选","link":"#曲面细分着色器-tessellation-shader-可编程、可选","children":[]},{"level":3,"title":"几何着色器（Geometry Shader）（可编程、可选）","slug":"几何着色器-geometry-shader-可编程、可选","link":"#几何着色器-geometry-shader-可编程、可选","children":[]},{"level":3,"title":"裁剪（Clipping）（可配置）","slug":"裁剪-clipping-可配置","link":"#裁剪-clipping-可配置","children":[]},{"level":3,"title":"屏幕映射（Screen Mapping）（固定）","slug":"屏幕映射-screen-mapping-固定","link":"#屏幕映射-screen-mapping-固定","children":[]}]},{"level":2,"title":"光栅化阶段（Rasterizer Stage）（GPU实现）","slug":"光栅化阶段-rasterizer-stage-gpu实现","link":"#光栅化阶段-rasterizer-stage-gpu实现","children":[{"level":3,"title":"三角形设置（Triangle Setup）（固定）","slug":"三角形设置-triangle-setup-固定","link":"#三角形设置-triangle-setup-固定","children":[]},{"level":3,"title":"三角形遍历（Triangle Traversal）（固定）","slug":"三角形遍历-triangle-traversal-固定","link":"#三角形遍历-triangle-traversal-固定","children":[]},{"level":3,"title":"片元着色器（Fragment Shader）（可编程、可选）这步不太懂","slug":"片元着色器-fragment-shader-可编程、可选-这步不太懂","link":"#片元着色器-fragment-shader-可编程、可选-这步不太懂","children":[]},{"level":3,"title":"逐片元操作（Per-Fragment Operations）（可配置）","slug":"逐片元操作-per-fragment-operations-可配置","link":"#逐片元操作-per-fragment-operations-可配置","children":[{"level":4,"title":"模板测试（Stencil Test）","slug":"模板测试-stencil-test","link":"#模板测试-stencil-test","children":[]},{"level":4,"title":"深度测试（Depth Test）","slug":"深度测试-depth-test","link":"#深度测试-depth-test","children":[]},{"level":4,"title":"混合（Blend）","slug":"混合-blend","link":"#混合-blend","children":[]}]}]}]}],"git":{"createdTime":1739087826000,"updatedTime":1739087826000,"contributors":[{"name":"Linc","username":"Linc","email":"762699299@qq.com","commits":1,"url":"https://github.com/Linc"}]},"readingTime":{"minutes":5.38,"words":1614},"filePathRelative":"01. DesignAndDevelop/3D/Render/《UnityShadow》/01. 渲染流水线.md","localizedDate":"2025年2月9日","excerpt":"\\n<h1>目录</h1>\\n<h1>渲染流水线（流程顺序 - 新编并简化）</h1>\\n<p>图2.2 渲染流水线中的三个概念阶段</p>\\n<p></p>\\n<h2>应用阶段（<em>Application Stage</em>）（CPU实现）</h2>\\n<h3>准备好场景数据</h3>\\n<p>（例如：摄像机位置、视锥体、场景中包含哪些模型、使用了哪些光源等等）</p>\\n<h3>剔除不可见物体</h3>\\n<p>为了提高渲染性能，需要作一个粗粒度剔除（<em>culling</em>）工作，剔除不可见物体不提交给集合阶段</p>\\n<p>（注：这里的不可见是指被隐藏而非被遮挡而不可见）</p>\\n<h3>设置好每个模型的渲染状态</h3>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"01. DesignAndDevelop/3D/Render/《UnityShadow》/01. 渲染流水线.md","value":{"title":"01. 渲染流水线","path":"01. DesignAndDevelop/3D/Render/《UnityShadow》/01. 渲染流水线.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{b as comp,P as data};
