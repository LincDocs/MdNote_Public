import{_ as l,c as t,e as a,o as i}from"./app-Z3IVicAk.js";const n={};function d(r,e){return i(),t("div",null,e[0]||(e[0]=[a(`<h1 id="面试八股文" tabindex="-1"><a class="header-anchor" href="#面试八股文"><span>面试八股文</span></a></h1><h2 id="语言相关" tabindex="-1"><a class="header-anchor" href="#语言相关"><span>语言相关</span></a></h2><p>5道C++语言相关的面试题</p><ol><li>malloc、free和new、delete区别</li><li>虚函数表和虚函数表指针的创建时机</li><li>C++什么时候生成默认拷贝构造函数</li><li>面向对象的三大特征及特性</li><li>设计模式</li></ol><h3 id="_01-malloc、free和new、delete" tabindex="-1"><a class="header-anchor" href="#_01-malloc、free和new、delete"><span>01. malloc、free和new、delete</span></a></h3><h4 id="区别" tabindex="-1"><a class="header-anchor" href="#区别"><span>区别</span></a></h4><p>new &amp; malloc</p><table><thead><tr><th></th><th>new</th><th>malloc</th></tr></thead><tbody><tr><td>使用时</td><td>自动计算分配内存大小</td><td>手动计算</td></tr><tr><td>返回值</td><td>对象指针</td><td><code>void*</code></td></tr><tr><td>失败</td><td>抛出异常</td><td>返回NULL</td></tr><tr><td>分配在哪</td><td>freeStore (自由存储区)<br>一般在虚拟内存上的堆<br><br>也有可能在自己定义的其他地方</td><td>&lt;128通过break系统调用 (可能会先有内存池)，在虚拟内存上的堆<br>&gt;128通过mmap系统调用，或在文件映射区</td></tr><tr><td>隐藏操作</td><td>1. operator new<br>2. 申请空间<br>3. 调用构造函数和初始化成员</td><td>无。注意不会进行初始化，分配后不一定有物理内存</td></tr></tbody></table><p>delete &amp; free</p><table><thead><tr><th></th><th>delete</th><th>free</th></tr></thead><tbody><tr><td>使用参数</td><td>对象指针</td><td><code>void*</code></td></tr><tr><td>隐藏操作</td><td>1. 调用析构函数<br>2. operator delete<br>3. 释放空间</td><td>无</td></tr></tbody></table><p>补充：</p><ul><li>虚拟内存和物理内存有一个映射关系，虚拟内存的一个页对应物理内存的一个页，初始化时才会去对应</li><li>所以说malloc分配后不一定有物理内存，new后会初始化，则会有对应的物理内存</li></ul><h4 id="faq" tabindex="-1"><a class="header-anchor" href="#faq"><span>FAQ</span></a></h4><ul><li>malloc 是怎么分配空间的？答：两种大小的两种分配区域</li><li>malloc 分配的物理内存还是虚拟内存？答：物理内存和虚拟内存的映射方式</li><li>malloc 调用后是否立刻得到物理内存？否，要初始化才有</li><li>free(p) 怎么知道该释放多大空间？malloc会额外<strong>多申请16Byte</strong></li><li>free(p) 释放内存后，内存还在吗？如果通过内存池释放，则内存回内存池。如果通过mmap分配，则会马上释放</li></ul><h4 id="深入" tabindex="-1"><a class="header-anchor" href="#深入"><span>深入</span></a></h4><h3 id="虚函数表和虚函数表指针" tabindex="-1"><a class="header-anchor" href="#虚函数表和虚函数表指针"><span>虚函数表和虚函数表指针</span></a></h3><ul><li><p>创建时机</p><ul><li><p>虚函数表创建时机：当某类有virutal函数，编译器编译时就会生成</p></li><li><p>虚函数表指针创建时机：类对象构造时，把类的虚函数表地址赋值给vptr（没有构造函数也会有默认构造函数）</p><p>需要注意继承时，先调用基类构造函数并将基类虚函数表地址给vptr，再调用子类构造函数并将子类虚函数表地址给vptr（总感觉不太对，不至于这么笨赋值两次吧）</p></li></ul></li><li><p>虚函数表和虚函数表指针的关系？</p><ul><li>答：虚函数表指针指向虚函数表。一个类对应一个虚函数表，类的多个对象对应多个虚函数表指针地址不同，但均指向虚函数表</li></ul></li><li><p>为什么需要虚函数指针？用来实现多态</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>A* p = new B();
p-&gt;func(); // 调用的B类的方法。因为能通过p对象的vptr找到B的虚函数表
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h4 id="可执行文件的磁盘组成" tabindex="-1"><a class="header-anchor" href="#可执行文件的磁盘组成"><span>可执行文件的磁盘组成</span></a></h4><ul><li>……</li><li>.bss，存放未初始化或初始化为零的全局或静态变量</li><li>.data，已初始化的全局或静态变量</li><li>.rodata，(readOnlyData)，只读数据段，虚函数表在里面</li><li>.text，代码段</li><li>……</li></ul><h4 id="虚拟内存组成" tabindex="-1"><a class="header-anchor" href="#虚拟内存组成"><span>虚拟内存组成</span></a></h4><ul><li>内核空间</li><li>栈区</li><li>文件映射区</li><li>堆区</li><li>数据区（静态存储区，已初始化和未初始化。映射 .bass、.data）</li><li>代码区（映射代码.text、.rodata(虚函数表)）</li></ul><h4 id="深入、编译器工作" tabindex="-1"><a class="header-anchor" href="#深入、编译器工作"><span>深入、编译器工作</span></a></h4><h3 id="默认拷贝构造函数" tabindex="-1"><a class="header-anchor" href="#默认拷贝构造函数"><span>默认拷贝构造函数</span></a></h3><ul><li>背景：如果不提供，则位拷贝</li><li>位拷贝危险 (浅拷贝危险) <ul><li>堆上的资源</li><li>文件句柄，socket</li><li>虚函数表指针缺失</li></ul></li><li>触发时机 <ul><li>赋值</li><li>函数传参 (形参为类对象)、返回值 (不一定，返回值可能会有个编译器优化，优先用C++11的移动构造函数/自动给你移动构造)</li></ul></li><li>什么时候生成。当不得不生成时 <ul><li>继承/包含一个类A，类A包含默认拷贝构造函数</li><li>类成员有虚函数（自己有或基类有）</li></ul></li></ul><h2 id="其他" tabindex="-1"><a class="header-anchor" href="#其他"><span>其他</span></a></h2><h3 id="写文件时进程宕机-数据会丢失吗" tabindex="-1"><a class="header-anchor" href="#写文件时进程宕机-数据会丢失吗"><span>写文件时进程宕机，数据会丢失吗</span></a></h3><h3 id="什么是mtu、mss以及为什么要有mss" tabindex="-1"><a class="header-anchor" href="#什么是mtu、mss以及为什么要有mss"><span>什么是MTU、MSS以及为什么要有MSS</span></a></h3><h3 id="什么是连接半打开-半关闭状态" tabindex="-1"><a class="header-anchor" href="#什么是连接半打开-半关闭状态"><span>什么是连接半打开，半关闭状态</span></a></h3><h2 id="c" tabindex="-1"><a class="header-anchor" href="#c"><span>C</span></a></h2><ul><li>标准库 stl、boost</li><li>C++11/14/17/20</li><li>面向对象</li><li>设计模式</li></ul>`,30)]))}const s=l(n,[["render",d],["__file","01. 语言相关.html.vue"]]),c=JSON.parse('{"path":"/01.%20DesignAndDevelop/Develop/10.%20%E9%9D%A2%E8%AF%95/C__%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/01.%20%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3.html","title":"面试八股文","lang":"zh-CN","frontmatter":{"description":"面试八股文 语言相关 5道C++语言相关的面试题 malloc、free和new、delete区别 虚函数表和虚函数表指针的创建时机 C++什么时候生成默认拷贝构造函数 面向对象的三大特征及特性 设计模式 01. malloc、free和new、delete 区别 new & malloc delete & free 补充： 虚拟内存和物理内存有一个映...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/10.%20%E9%9D%A2%E8%AF%95/C__%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/01.%20%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3.html"}],["meta",{"property":"og:site_name","content":"MdNote_Public"}],["meta",{"property":"og:title","content":"面试八股文"}],["meta",{"property":"og:description","content":"面试八股文 语言相关 5道C++语言相关的面试题 malloc、free和new、delete区别 虚函数表和虚函数表指针的创建时机 C++什么时候生成默认拷贝构造函数 面向对象的三大特征及特性 设计模式 01. malloc、free和new、delete 区别 new & malloc delete & free 补充： 虚拟内存和物理内存有一个映..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-01-23T15:48:39.000Z"}],["meta",{"property":"article:author","content":"LincDocs"}],["meta",{"property":"article:modified_time","content":"2025-01-23T15:48:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"面试八股文\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-01-23T15:48:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/MdNote_Public/\\"}]}"]]},"headers":[{"level":1,"title":"面试八股文","slug":"面试八股文","link":"#面试八股文","children":[{"level":2,"title":"语言相关","slug":"语言相关","link":"#语言相关","children":[{"level":3,"title":"01. malloc、free和new、delete","slug":"_01-malloc、free和new、delete","link":"#_01-malloc、free和new、delete","children":[{"level":4,"title":"区别","slug":"区别","link":"#区别","children":[]},{"level":4,"title":"FAQ","slug":"faq","link":"#faq","children":[]},{"level":4,"title":"深入","slug":"深入","link":"#深入","children":[]}]},{"level":3,"title":"虚函数表和虚函数表指针","slug":"虚函数表和虚函数表指针","link":"#虚函数表和虚函数表指针","children":[{"level":4,"title":"可执行文件的磁盘组成","slug":"可执行文件的磁盘组成","link":"#可执行文件的磁盘组成","children":[]},{"level":4,"title":"虚拟内存组成","slug":"虚拟内存组成","link":"#虚拟内存组成","children":[]},{"level":4,"title":"深入、编译器工作","slug":"深入、编译器工作","link":"#深入、编译器工作","children":[]}]},{"level":3,"title":"默认拷贝构造函数","slug":"默认拷贝构造函数","link":"#默认拷贝构造函数","children":[]}]},{"level":2,"title":"其他","slug":"其他","link":"#其他","children":[{"level":3,"title":"写文件时进程宕机，数据会丢失吗","slug":"写文件时进程宕机-数据会丢失吗","link":"#写文件时进程宕机-数据会丢失吗","children":[]},{"level":3,"title":"什么是MTU、MSS以及为什么要有MSS","slug":"什么是mtu、mss以及为什么要有mss","link":"#什么是mtu、mss以及为什么要有mss","children":[]},{"level":3,"title":"什么是连接半打开，半关闭状态","slug":"什么是连接半打开-半关闭状态","link":"#什么是连接半打开-半关闭状态","children":[]}]},{"level":2,"title":"C","slug":"c","link":"#c","children":[]}]}],"git":{"createdTime":1737647319000,"updatedTime":1737647319000,"contributors":[{"name":"Linc","email":"762699299@qq.com","commits":1}]},"readingTime":{"minutes":3.67,"words":1102},"filePathRelative":"01. DesignAndDevelop/Develop/10. 面试/C++面试八股文/01. 语言相关.md","localizedDate":"2025年1月23日","excerpt":"\\n<h2>语言相关</h2>\\n<p>5道C++语言相关的面试题</p>\\n<ol>\\n<li>malloc、free和new、delete区别</li>\\n<li>虚函数表和虚函数表指针的创建时机</li>\\n<li>C++什么时候生成默认拷贝构造函数</li>\\n<li>面向对象的三大特征及特性</li>\\n<li>设计模式</li>\\n</ol>\\n<h3>01. malloc、free和new、delete</h3>\\n<h4>区别</h4>\\n<p>new &amp; malloc</p>\\n<table>\\n<thead>\\n<tr>\\n<th></th>\\n<th>new</th>\\n<th>malloc</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>使用时</td>\\n<td>自动计算分配内存大小</td>\\n<td>手动计算</td>\\n</tr>\\n<tr>\\n<td>返回值</td>\\n<td>对象指针</td>\\n<td><code>void*</code></td>\\n</tr>\\n<tr>\\n<td>失败</td>\\n<td>抛出异常</td>\\n<td>返回NULL</td>\\n</tr>\\n<tr>\\n<td>分配在哪</td>\\n<td>freeStore (自由存储区)<br>一般在虚拟内存上的堆<br><br>也有可能在自己定义的其他地方</td>\\n<td>&lt;128通过break系统调用 (可能会先有内存池)，在虚拟内存上的堆<br>&gt;128通过mmap系统调用，或在文件映射区</td>\\n</tr>\\n<tr>\\n<td>隐藏操作</td>\\n<td>1. operator new<br>2. 申请空间<br>3. 调用构造函数和初始化成员</td>\\n<td>无。注意不会进行初始化，分配后不一定有物理内存</td>\\n</tr>\\n</tbody>\\n</table>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"01. DesignAndDevelop/Develop/10. 面试/C++面试八股文/01. 语言相关.md","value":{"title":"01. 语言相关","path":"01. DesignAndDevelop/Develop/10. 面试/C++面试八股文/01. 语言相关.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{s as comp,c as data};
