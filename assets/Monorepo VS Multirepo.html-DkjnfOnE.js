import{_ as i,c as p,e as t,a as e,b as o,d as l,o as a,r}from"./app-Dt9PEj-q.js";const u={},d={href:"https://www.cythilya.tw/2023/01/28/monolith-vs-multi-repo-vs-mono-repo/",target:"_blank",rel:"noopener noreferrer"},v={href:"https://www.cythilya.tw/2023/01/28/monolith-vs-multi-repo-vs-mono-repo/#Monolith",target:"_blank",rel:"noopener noreferrer"},m={href:"https://www.cythilya.tw/2023/01/28/monolith-vs-multi-repo-vs-mono-repo/#Multi-Repo",target:"_blank",rel:"noopener noreferrer"},c={href:"https://www.cythilya.tw/2023/01/28/monolith-vs-multi-repo-vs-mono-repo/#Monorepo",target:"_blank",rel:"noopener noreferrer"},b={href:"https://www.cythilya.tw/2023/01/28/monolith-vs-multi-repo-vs-mono-repo/#%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B",target:"_blank",rel:"noopener noreferrer"},k={href:"https://www.cythilya.tw/2023/01/28/monolith-vs-multi-repo-vs-mono-repo/#%E7%B8%BD%E7%B5%90",target:"_blank",rel:"noopener noreferrer"},g={href:"https://stackoverflow.com/questions/62598858/git-submodule-vs-npm-package/62605719",target:"_blank",rel:"noopener noreferrer"},M={href:"http://shachiku.life/posts/difference-between-subtree-and-submodule/",target:"_blank",rel:"noopener noreferrer"},h={href:"https://blog.darkthread.net/blog/git-subtree-notes/https://blog.puckwang.com/posts/2020/git-submodule-vs-subtree/",target:"_blank",rel:"noopener noreferrer"},f={href:"https://github.blog/2022-06-29-improve-git-monorepo-performance-with-a-file-system-monitor/",target:"_blank",rel:"noopener noreferrer"},E={href:"https://www.netlify.com/",target:"_blank",rel:"noopener noreferrer"},w={href:"https://www.netlify.com/blog/2020/04/21/deploying-nx-monorepos-to-netlify/",target:"_blank",rel:"noopener noreferrer"},j={href:"https://www.jonathancreamer.com/inside-the-pain-of-monorepos-and-hoisting/",target:"_blank",rel:"noopener noreferrer"},y={href:"https://blog.errorbaker.tw/posts/cwc329/monorepo/",target:"_blank",rel:"noopener noreferrer"},B={href:"https://www.youtube.com/watch?v=VUyBY72mwrQ",target:"_blank",rel:"noopener noreferrer"},A={href:"https://levelup.gitconnected.com/different-monorepo-solutions-in-2021-1d6f5e5fb95b#1de3",target:"_blank",rel:"noopener noreferrer"},D={href:"https://github.com/nrwl/react-module-federation",target:"_blank",rel:"noopener noreferrer"},q={href:"https://vercel.com/templates/next.js/monorepo-nx",target:"_blank",rel:"noopener noreferrer"},R={href:"https://www.cythilya.tw/2023/01/28/monolith-vs-multi-repo-vs-mono-repo/#%E5%82%99%E8%A8%BB",target:"_blank",rel:"noopener noreferrer"},x={href:"https://www.netlify.com/blog/2020/04/21/deploying-nx-monorepos-to-netlify/",target:"_blank",rel:"noopener noreferrer"},N={href:"https://juejin.cn/post/6949882490324516894",target:"_blank",rel:"noopener noreferrer"},S={href:"https://medium.com/@neatcoding/monorepo%E4%B8%8Emultirepo%E5%8C%BA%E5%88%AB%E4%BD%95%E5%9C%A8-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%A7%E5%85%AC%E5%8F%B8%E5%83%8F%E8%B0%B7%E6%AD%8C-%E5%BE%AE%E8%BD%AF-%E4%BC%98%E6%AD%A5-neflix-nike%E9%83%BD%E5%9C%A8monorepo-416a04d8b03b",target:"_blank",rel:"noopener noreferrer"},C={href:"https://zhuanlan.zhihu.com/p/31289463",target:"_blank",rel:"noopener noreferrer"},V={href:"https://www.51cto.com/article/709468.html",target:"_blank",rel:"noopener noreferrer"};function T(P,n){const s=r("ExternalLinkIcon");return a(),p("div",null,[n[62]||(n[62]=t('<h1 id="monorepo-vs-multirepo" tabindex="-1"><a class="header-anchor" href="#monorepo-vs-multirepo"><span>Monorepo VS Multirepo</span></a></h1><h2 id="三种架构模式" tabindex="-1"><a class="header-anchor" href="#三种架构模式"><span>三种架构模式</span></a></h2><h3 id="monolith-单架构" tabindex="-1"><a class="header-anchor" href="#monolith-单架构"><span>Monolith (单架构)</span></a></h3><h3 id="monorepo-单仓库" tabindex="-1"><a class="header-anchor" href="#monorepo-单仓库"><span>Monorepo (单仓库)</span></a></h3><p>Monorepo 是一种代码管理策略，把所有的项目代码都放在一个仓库里，每一个项目、每一个服务或者是每一个包就是这个仓库的一个子目录。</p><p>&quot;Monorepo&quot; 这个词是 “Monolithic Repository” 的缩写, 中文可以翻译为&quot;单体仓库&quot;。</p><p>一般对比另一种策略 -- Multirepo（多仓库），每一个项目或者包都使用一个独立的仓库进行管理。</p><p>在Monorepo的代码管理方式下：</p><ol><li>共享代码非常方便：由于所有项目都在同一个仓库下，它们可以直接引用其他项目的代码，而不需要发布和维护各种共享库。</li><li>一致性：所有的项目都可以统一使用相同的构建工具和配置，所有人都在一份代码库上工作，大大提高了开发效率。</li><li>协同开发更简单：无需在多个仓库之间切换，项目之间的协作更为方便。</li><li>对整个项目的更改可以很容易看到，在提交代码时可以很容易地看到哪些服务或者包可能会受到影响。</li></ol><p>但是Monorepo也不是没有缺点的，因为所有的代码都在一个仓库里，所以这个仓库的规模可能会变得很大，对于资源和权限的管理可能会带来一些挑战。</p><p>谷歌、Facebook、微软和Twitter等大公司都在使用 Monorepo 管理他们的代码库。</p><h3 id="multirepo-多仓库" tabindex="-1"><a class="header-anchor" href="#multirepo-多仓库"><span>Multirepo (多仓库)</span></a></h3><h2 id="简单总结" tabindex="-1"><a class="header-anchor" href="#简单总结"><span>简单总结</span></a></h2><h3 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景"><span>使用场景</span></a></h3><p>以前msy公司recorder项目还在用svn时，就属于单仓库，后来迁移到git后，就使用多仓库管理了</p><h3 id="比较" tabindex="-1"><a class="header-anchor" href="#比较"><span>比较</span></a></h3><p>Monorepo 和 Multirepo 是两种不同的代码存储库管理结构，各有自己的优点和缺点。</p><ul><li><p>Monorepo（单仓库）</p><ul><li><p>优点</p><ul><li>代码共享和重用：在单一存储库中，所有项目和代码都处于同一位置，使得代码共享和重用变得更简单</li><li>协作：开发者可以更容易地跨项目协作</li><li>简化构建和测试过程：构建工具可以在整个项目中运行，提供全局测试和构建</li><li>统一版本：Monorepo 用一个存储库来存储所有代码，所有的变更都有统一的版本历史</li></ul></li><li><p>缺点</p><ul><li>规模问题：随着项目和代码行数的增加，Monorepo 的大小会越大，可能会导致性能问题</li><li>权限管理和安全性：在一个大型的仓库中，正确地设置代码的访问权限可能会更加复杂</li></ul></li></ul></li><li><p>Multirepo（多仓库）</p><ul><li>优点 <ul><li>简单性：每个项目都有自己的仓库，可以独立地管理和运行它，使得结构和管理变得更简单</li><li>适用于小型团队：如果团队或项目较小，多仓库的方式更适合</li><li>独立性：变更不会影响到其他项目</li></ul></li><li>缺点 <ul><li>重复性工作：例如，如果需要更改或更新所有项目的某个公共库，可能需要在所有仓库中手动进行</li><li>分散管理：需要在多个仓库中进行代码审查和合并</li><li>版本管理：可能需要在多个仓库中跟踪和管理版本，同时需要更多的工具和流程来维护版本一致性</li></ul></li></ul></li></ul><p>总的来说，选择使用哪种方式主要取决于项目的具体需求和团队的喜好</p><h3 id="gpt简单调研" tabindex="-1"><a class="header-anchor" href="#gpt简单调研"><span>GPT简单调研</span></a></h3><p>Q：从各种项目的语言、框架来看，分别哪种比较受欢迎？比如Cpp、java、python、node.js的npm</p><hr><p>选择Monorepo还是Multirepo并不完全取决于使用的编程语言或框架，而是取决于团队的协作方式、项目规模、开发流程等因素。但是，有些语言和框架的生态系统，可能使一种方式更受欢迎。</p><ul><li><p>C++</p><ul><li>Monorepo：C++的构建系统（如Bazel和Buck等）在Monorepo体系中表现出色，谷歌和Facebook等公司都采用了这种方案。</li><li>Multirepo：但以C++为主的一些开源项目（如LLVM）还是采用多个仓库来组织代码。</li></ul></li><li><p>Java</p><ul><li>Monorepo：像谷歌和Twitter这样的大公司倾向于使用Monorepo来管理他们的Java项目。</li><li>Multirepo：然而，Java的包管理工具（如Maven和Gradle）在多仓库环境中也能很好地工作。</li></ul></li><li><p>Python</p><ul><li>Multirepo：在Python社区中，Multirepo似乎更受欢迎，主要原因可能是Python的包管理工具（如pip）在多仓库环境中工作得更好。</li></ul></li><li><p>Node.js的npm</p><ul><li><p>Multirepo：由于npm的设计方式，Node.js社区倾向于选择Multirepo。每个npm包都有其自己独立的版本号和依赖关系，这可以在Multirepo中很好地管理。</p></li><li><p>Monorepo：但是最近在一些大型项目中（包括一些使用JavaScript和Node.js的项目），Monorepo正在变得更加流行，工具像Lerna就是为此而设计的。</p></li></ul></li></ul><p>总的来说，对于大部分语言和框架来说，两者都是可行的，并且都有成功的实践案例。所以选择哪种方式更多地取决于项目的特性和团队的喜好。</p><h2 id="【转】该用-monorepo-吗-比较-monolith-vs-multi-repo-vs-monorepo" tabindex="-1"><a class="header-anchor" href="#【转】该用-monorepo-吗-比较-monolith-vs-multi-repo-vs-monorepo"><span>【转】该用 Monorepo 吗？比较 Monolith vs Multi-Repo vs Monorepo</span></a></h2>',26)),e("p",null,[n[1]||(n[1]=o("转自：")),e("a",d,[n[0]||(n[0]=o("该用 Monorepo 吗？比较 Monolith vs Multi-Repo vs Monorepo")),l(s)]),n[2]||(n[2]=o("，并进行了繁体转简体"))]),n[63]||(n[63]=e("p",null,"专案随著开发时间愈长，伴随而来的除了体积和复杂度增加之外，也产生难以扩充、缺乏弹性以及打包和部署时间长、效率差等问题。这时候就会开始考虑切分专案。",-1)),n[64]||(n[64]=e("p",null,"在这里来聊聊三种管理专案的架构",-1)),e("ul",null,[e("li",null,[e("a",v,[n[3]||(n[3]=o("Monolith")),l(s)])]),e("li",null,[e("a",m,[n[4]||(n[4]=o("Multi-Repo")),l(s)])]),e("li",null,[e("a",c,[n[5]||(n[5]=o("Monorepo")),l(s)])])]),e("p",null,[n[8]||(n[8]=o("这篇文章会谈到过去在建置专案时遇到的问题，以及根据不同情境而选用的解法，并在最后推荐工具与提供利用 Module Federation 达成 Micro Frontends 的范例来")),e("a",b,[n[6]||(n[6]=o("快速上手")),l(s)]),n[9]||(n[9]=o("和")),e("a",k,[n[7]||(n[7]=o("总结比较")),l(s)]),n[10]||(n[10]=o("。"))]),n[65]||(n[65]=t(`<p>![Monolith vs Multi-Repo vs Monorepo 示意圖](Monorepo VS Multirepo.assets/monolith-vs-multi-repo-vs-mono-repo.png)</p><p>![image-20231022152926033](Monorepo VS Multirepo.assets/image-20231022152926033.png)</p><h3 id="monolith-单架构-1" tabindex="-1"><a class="header-anchor" href="#monolith-单架构-1"><span>Monolith (单架构)</span></a></h3><p>![Monolith](Monorepo VS Multirepo.assets/monolith.png)</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>├── assets
├── components
│   ├── Button<span class="token punctuation">.</span>js
│   ├── Modal<span class="token punctuation">.</span>js
│   └── <span class="token operator">...</span>
├── node_modules
├── pages
│   ├── Chat			<span class="token comment">// Chat 聊天模块</span>
│   │   ├── Contact<span class="token punctuation">.</span>js
│   │   ├── Message<span class="token punctuation">.</span>js
│   │   └── <span class="token operator">...</span>
│   ├── Mall			<span class="token comment">// Mall 购物模块</span>
│   │   ├── Cart<span class="token punctuation">.</span>js
│   │   ├── Product<span class="token punctuation">.</span>js
│   │   └── <span class="token operator">...</span>
│   ├── News			<span class="token comment">// News 新闻/推荐模块</span>
│   │   ├── Article<span class="token punctuation">.</span>js
│   │   ├── Topic<span class="token punctuation">.</span>js
│   │   └── <span class="token operator">...</span>
├── utils
├── <span class="token keyword">package</span><span class="token punctuation">.</span>json
├── jest<span class="token punctuation">.</span>config<span class="token punctuation">.</span>js
├── webpack<span class="token punctuation">.</span>config<span class="token punctuation">.</span>js
├── yarn<span class="token punctuation">.</span>lock
└── <span class="token constant">README</span><span class="token punctuation">.</span>md
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>模式</p><blockquote><p>过去在建置专案时，大多选用 <code>Single-Repo Monolith</code> 的架构，意即将所有的功能都统一放在同一个 repository (简称 repo) 底下。</p><p>如上图所示，在 WebGether 这个产品的 repo 底下，包含 News、Mall 和 Chat 功能。</p></blockquote><p>优点</p><blockquote><p>这在产品开发初期或非大型规模专案，的确是个简单方便的好方法。</p></blockquote><p>缺点</p><blockquote><ul><li><p>在团队与产品不断扩张的状况下，这个 repo 变得超级<strong>大</strong>，导致打包和部署<strong>时间长</strong>、<strong>效率差</strong></p></li><li><p>不同团队可能会用到<strong>不同的环境建置与技术栈</strong> (tech stack) 而造成 <strong>相依管理困难</strong> (dependency management) 、<strong>难以扩充</strong>、<strong>缺乏弹性</strong>。</p><ul><li><p>场景举例：</p><p>WebGether 原本统一使用 React v15 作为前端开发框架，并且用 Redux 作为状态管理工具、</p><p>但某天 News 团队希望改用潮到出水的 Vue，Mall 团队希望能用 useReducer + useContext 取代 Redux，Chat 团队无法接受 React 升版 v16.8 导致某最爱的 package 失效。</p><p>这时候就要考虑分家了，将不同功能切分为不同专案，切分方式可分为两种：Multi-Repo、Monorepo</p></li></ul></li></ul></blockquote><h3 id="multirepo-多仓库-1" tabindex="-1"><a class="header-anchor" href="#multirepo-多仓库-1"><span>MultiRepo (多仓库)</span></a></h3><p>![Multi-Repo](Monorepo VS Multirepo.assets/multi-repo.png)</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// Chat 聊天模块</span>
├── assets
├── components
│   ├── Button<span class="token punctuation">.</span>js
│   ├── Modal<span class="token punctuation">.</span>js
│   └── <span class="token operator">...</span>
├── node_modules
├── pages
│   ├── Contact<span class="token punctuation">.</span>js
│   ├── Message<span class="token punctuation">.</span>js
│   └── <span class="token operator">...</span>
├── utils
├── <span class="token keyword">package</span><span class="token punctuation">.</span>json
├── jest<span class="token punctuation">.</span>config<span class="token punctuation">.</span>js
├── webpack<span class="token punctuation">.</span>config<span class="token punctuation">.</span>js
├── yarn<span class="token punctuation">.</span>lock
└── <span class="token constant">README</span><span class="token punctuation">.</span>md

<span class="token comment">// Mall 购物模块</span>
├── assets
├── components
│   ├── Button<span class="token punctuation">.</span>js
│   ├── Modal<span class="token punctuation">.</span>js
│   └── <span class="token operator">...</span>
├── node_modules
├── pages
│   ├── Cart<span class="token punctuation">.</span>js
│   ├── Product<span class="token punctuation">.</span>js
│   └── <span class="token operator">...</span>
├── utils
├── <span class="token keyword">package</span><span class="token punctuation">.</span>json
├── jest<span class="token punctuation">.</span>config<span class="token punctuation">.</span>js
├── webpack<span class="token punctuation">.</span>config<span class="token punctuation">.</span>js
├── yarn<span class="token punctuation">.</span>lock
└── <span class="token constant">README</span><span class="token punctuation">.</span>md

<span class="token comment">// News 新闻/推荐模块</span>
├── assets
├── components
│   ├── Button<span class="token punctuation">.</span>js
│   ├── Modal<span class="token punctuation">.</span>js
│   └── <span class="token operator">...</span>
├── node_modules
├── pages
│   ├── Article<span class="token punctuation">.</span>js
│   ├── Topic<span class="token punctuation">.</span>js
│   └── <span class="token operator">...</span>
├── utils
├── <span class="token keyword">package</span><span class="token punctuation">.</span>json
├── jest<span class="token punctuation">.</span>config<span class="token punctuation">.</span>js
├── webpack<span class="token punctuation">.</span>config<span class="token punctuation">.</span>js
├── yarn<span class="token punctuation">.</span>lock
└── <span class="token constant">README</span><span class="token punctuation">.</span>md
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>模式</p><blockquote><p>Multi-Repo (或称 Polyrepo、Many-repo) 是指将个别功能放在不同 repo 底下，如前面的例子，在拆分 News、Mall 和 Chat 后，这三个功能便拥有各自独立的 repo，同时也能拥有各自的环境和工具的设定档与技术线。</p></blockquote><p>优点</p><blockquote><ul><li><p>专案体积小、高效率开发、技术栈独立</p></li><li><p>相依管理简单、高弹性，因此权责切分干净、不同框架时更显优点</p><ul><li><p>场景举例：</p><p>这里解决就前面说到的问题。News 果真改用 Vue 来做前端开发的框架，Mall 不再需要迁就 Chat 的守旧而能快乐使用 React Hooks 以及 Chat 可以继续使用他们最爱的恐龙级 package，皆大欢喜 ヽ(●´∀\`●)ﾉ</p></li></ul></li></ul></blockquote><p>缺点（缺点就是优点的反面）</p>`,19)),e("blockquote",null,[e("ul",null,[e("li",null,[n[15]||(n[15]=e("p",null,"不易共享，像是环境与设定档重复配置 (CI/CD、webpack、test suite 等)、资源难以共用。",-1)),e("ul",null,[e("li",null,[n[14]||(n[14]=e("p",null,"场景举例：",-1)),e("p",null,[n[12]||(n[12]=o("某天 News 团队开发了一个很棒的 sticker footer 元件，过去在 Monolith 时各团队只要引入这个元件即可共用，但现在可能要请 News 团队将这个元件打包成 NPM package 或抽到共用的元件的 repo 再用 Git Submodule 再引用的方式才能共用，共用的困难度增加。关于选 NPM package 还是 Git Submodule，个人经验来说差异为打包、发布和更新上的不同，端看团队用起来谁比较顺手就好，这个")),e("a",g,[n[11]||(n[11]=o("讨论")),l(s)]),n[13]||(n[13]=o("也许能提供一些参考"))])])])]),n[16]||(n[16]=e("li",null,[e("p",null,"当资源更新时，个别 repo 难以被通知而及时更新")],-1)),n[17]||(n[17]=e("li",null,[e("p",null,"修 bug 或是 i18n 字串更新时若涉及多个 repo，处理与测试的困难度也会变高。")],-1)),n[18]||(n[18]=e("li",null,[e("p",null,"建构、测试与发布流程上甚至是 rollback 都较困难。")],-1))])]),n[66]||(n[66]=e("p",null,"其他补充",-1)),e("blockquote",null,[e("p",null,[n[21]||(n[21]=o("与 Multi-Repo 这个概念的相似解法，可参考 ")),e("a",M,[n[19]||(n[19]=o("Git Submodule")),l(s)]),n[22]||(n[22]=o(" 或 ")),e("a",h,[n[20]||(n[20]=o("Git Subtree")),l(s)])]),n[23]||(n[23]=e("ul",null,[e("li",null,"Git Submodule 是指建立 main repo 与 sub repo 的 HEAD commit 连结"),e("li",null,"Git Subtree 是指将 main repo 包含 commit log 全部 copy 到新的 repo 中")],-1)),n[24]||(n[24]=e("p",null,[o("看完 Multi-Repo，有没有什么能同时 "),e("strong",null,"兼顾弹性与共用"),o(" 的解法呢？接下来看 Monorepo")],-1))]),n[67]||(n[67]=t(`<h3 id="monorepo-单仓库-1" tabindex="-1"><a class="header-anchor" href="#monorepo-单仓库-1"><span>MonoRepo (单仓库)</span></a></h3><p>![Monorepo](Monorepo VS Multirepo.assets/mono-repo.png)</p><p>档案配置示意如下</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>├── shared					<span class="token comment">// 共享部分</span>
│   ├── assets
│   ├── components
│   │   ├── Button<span class="token punctuation">.</span>js
│   │   ├── Modal<span class="token punctuation">.</span>js
│   │   └── <span class="token operator">...</span>
│   ├── utils
│   └── <span class="token operator">...</span>
├── apps
│   ├── chat				<span class="token comment">// Chat 聊天模块</span>
│   │   ├── components
│   │   ├── pages
│   │   │   ├── Contact<span class="token punctuation">.</span>js
│   │   │   ├── Message<span class="token punctuation">.</span>js
│   │   ├── utils
│   │   └── <span class="token operator">...</span>
│   ├── chat<span class="token operator">-</span>e2e
│   ├── mall				<span class="token comment">// Mall 购物模块</span>
│   │   ├── components
│   │   ├── pages
│   │   │   ├── Cart<span class="token punctuation">.</span>js
│   │   │   ├── Product<span class="token punctuation">.</span>js
│   │   ├── utils
│   │   └── <span class="token operator">...</span>
│   ├── mall<span class="token operator">-</span>e2e
│   ├── news				<span class="token comment">// News 新闻/推荐模块</span>
│   │   ├── components
│   │   ├── pages
│   │   │  ├── Article<span class="token punctuation">.</span>js
│   │   │  ├── Topic<span class="token punctuation">.</span>js
│   │   ├── utils
│   │   └── <span class="token operator">...</span>
│   └── news<span class="token operator">-</span>e2e
├── node_modules
├── <span class="token keyword">package</span><span class="token punctuation">.</span>json
├── jest<span class="token punctuation">.</span>config<span class="token punctuation">.</span>js
├── webpack<span class="token punctuation">.</span>config<span class="token punctuation">.</span>js
├── yarn<span class="token punctuation">.</span>lock
└── <span class="token constant">README</span><span class="token punctuation">.</span>md
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>模式</p><blockquote><p>Monorepo 将个别功能放在同一 repo 的不同 package 底下，如前面的例子，在拆分 News、Mall 和 Chat 后，这三个功能虽然仍在同一个 repo 底下，但放置于不同的 pacakge 资料夹</p><p>个人知识盲区，补充一下：</p><blockquote><p><code>e2e</code> 是一个用于进行端到端测试（End-to-End Testing）的文件或文件夹。在软件开发中，端到端测试用于确保整个应用程序流程（从开始到结束）都可以正常工作。这种测试覆盖了所有的交互路径，包括外部系统和接口。这有助于验证系统和其组件是否能在实际环境中——从开始到结束——正常工作。</p><p>e2e测试的定义并不是最初的字符&quot;E&quot;和最后的字符“E”代表一个客户端和服务端，而是指的是对整个应用程序，从开始到结束（end-to-end）的一个完整流程，将所有相关组件串联在一起进行的测试。</p><p>&quot;端对端&quot;这个词是从&quot;end to end&quot;直接翻译过来的，原意是“从一端到另一端”，在这里是指整个软件系统从起始到结束，涵盖所有的交互过程和组件。所以，即使只有一个客户端或服务端，但只要测试覆盖了所有的用户场景和交互流程，仍然可以被称之为e2e测试。</p><p>翻译为&quot;端对端测试&quot;是为了准确表达其测试整个流程的含义，不能理解为只测试两个&quot;端&quot;（如客户端和服务端）之间的通信。在e2e测试中，&quot;端（end）&quot;应理解为流程的起始点和结束点，而不仅仅是物理设备或者是一个客户端/服务端。</p></blockquote></blockquote><p>优点</p><blockquote><ul><li>能<strong>共享资源</strong>，在<strong>同框架</strong>时更显优势</li><li>能<strong>共享配置</strong>，像是共享环境设定和 config 档，不需每个 app 再自建一套。这在建构、测试与发布流程上甚至是 rollback 是很方便的。</li><li>当资源更新时，个别 app 能够<strong>及时被通知而更新</strong></li></ul></blockquote><p>缺点</p>`,9)),e("blockquote",null,[e("ul",null,[e("li",null,[e("p",null,[n[26]||(n[26]=e("strong",null,"体积大",-1)),n[27]||(n[27]=o("，跟 Monolith 同样有 repo 庞大的问题，这在 codebase 很大的状况下很可能造成 Git 效能差 (细节和解法参考")),e("a",f,[n[25]||(n[25]=o("这里")),l(s)]),n[28]||(n[28]=o(")、SourceTree 当掉；"))]),e("p",null,[n[31]||(n[31]=o("虽然说开发人员可自行设定 filter 来侦测 repo 更新和决定部署哪个 package，但开发平台像是 ")),e("a",E,[n[29]||(n[29]=o("Netlify")),l(s)]),n[32]||(n[32]=o(" 不会判断是哪个 app 有更新，只要 repo 有 change 就会 trigger deploy，repo 愈大开发与部署成本愈高，对这个议题和解法有兴趣的可参考")),e("a",w,[n[30]||(n[30]=o("那里")),l(s)]),n[33]||(n[33]=o("。"))])]),e("li",null,[n[37]||(n[37]=e("p",null,"是否共用要切分清楚，由于太容易共用了，在开发上需要制定明确规范。",-1)),e("p",null,[n[35]||(n[35]=o("例如：利用 linter or dependency graph 限制共用元件或工具必须放在 shared package，不属于自身 package 的 app 不能共用。这在开发和 PR review 时需要多多留心 codebase 的更新状况和是否修改在适当的范围之内。同样的，对于专属自身 app 想要安装使用的东西就放在自家 package.json 里面，记得注意 ")),e("a",j,[n[34]||(n[34]=o("package version hoist")),l(s)]),n[36]||(n[36]=o(" 的状况。"))])]),n[38]||(n[38]=t("<li><p>在<strong>开发人员众多</strong>时<strong>紊乱</strong>、<strong>难以控管</strong>档案<strong>权限</strong></p><ul><li>无法针对 package 来限制谁能浏览或编辑</li><li>同时也会反应到开 <strong>issue</strong>、<strong>回复 PR</strong> 和<strong>通知</strong>过于紊乱的问题上。</li></ul></li>",1))])]),n[68]||(n[68]=e("p",null,"其他 - 前后端问题",-1)),e("blockquote",null,[n[42]||(n[42]=e("p",null,"顺道一提，有些专案是将前后端一同整合至 Monorepo 上，这样的考量点可能是前后端的开发成员是同一批人、使用同一种语言或便于 Ops 统一管理与版控",-1)),n[43]||(n[43]=e("ul",null,[e("li",null,"优点：能做到有效的资源共享、前后端整合是很便利的"),e("li",null,"缺点：复杂度变高，一旦 repo 出现问题前后端都会受影响等")],-1)),e("p",null,[n[40]||(n[40]=o("关于这个议题")),e("a",y,[n[39]||(n[39]=o("这篇文章")),l(s)]),n[41]||(n[41]=o("提到不错的观点与说明。个人经验来说，由于大多待在前后端分离的团队，开发人员、语言和环境差异甚大 (React vs Go)，并且专案规模庞大，因此都是在这样的配置下选择此架构来达成 Micro Frontends。"))])]),n[69]||(n[69]=e("h3",{id:"快速上手",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#快速上手"},[e("span",null,"快速上手")])],-1)),e("p",null,[n[49]||(n[49]=o("最后，在管理 Monorepo 的工具方面，推荐可用 PNPM、Lerna、Bit、")),e("a",B,[n[44]||(n[44]=o("NX")),l(s)]),n[50]||(n[50]=o(" 等，有选择困难症的这里有")),e("a",A,[n[45]||(n[45]=o("重点整理和比较")),l(s)]),n[51]||(n[51]=o("；而 NX 提供了很棒的 ")),e("a",D,[n[46]||(n[46]=o("Webpack Module Federation 范例")),l(s)]),n[52]||(n[52]=o("，加上 Vercel 对 NX 支援也很友善 (")),e("a",q,[n[47]||(n[47]=o("还提供样板")),l(s)]),n[53]||(n[53]=o(") (")),e("a",R,[n[48]||(n[48]=o("注 1")),l(s)]),n[54]||(n[54]=o(")，可以参考看看。"))]),n[70]||(n[70]=t('<h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>选用</p><blockquote><p>就个人开发经验来说，会依据专案的团队成员组成、实作细节与维运的复杂度来决定要选用 Multirepo 还是 Monorepo 的架构。简单来说：</p><ul><li>需要<strong>高度共用</strong>、<strong>紧密合作</strong>的状况下会选用 Monorep</li><li>若功能<strong>差异大</strong>、彼此没什么交集、不想被彼此影响，就会选用 Multirepo</li></ul><p>其中 Monorepo 在易于分享配置与资源的同时，也能拥有各自想要的弹性，可说是共享与独立兼顾。</p></blockquote><p>比较 Monolith、Multi-Repo 与 Monorepo 如下表。</p><table><thead><tr><th>＃</th><th>Monolith</th><th>Multi-Repo</th><th>Monorepo</th></tr></thead><tbody><tr><td>特色</td><td>将所有的功能放在单一 repo</td><td>将个别功能放在不同 repo</td><td>将个别功能放在同一 repo 的不同 package</td></tr><tr><td>优点</td><td>简单方便</td><td>1. 专案体积小、高效开发；2. 技术线独立、相依管理简单、高弹性</td><td>共享与独立兼顾</td></tr><tr><td>缺点</td><td>1. 专案过于庞大，开发低效；2. 相依管理困难、难以扩充、缺乏弹性</td><td>共享不易</td><td>repo 庞大、开发需明确规范、档案权限难以控管、Git 效能差</td></tr><tr><td>工具</td><td>-</td><td>-</td><td>PNPM Lerna Bit NX 等</td></tr><tr><td>适用情境</td><td>产品开发初期或非大型规模专案</td><td>切分大型专案、相依和共享状况少</td><td>切分大型专案、相依和共享状况多</td></tr><tr><td>相似解法</td><td>-</td><td>Git Submodules 或 Git Subtree</td><td>-</td></tr></tbody></table><p>这些架构都有各自适用的状况，评估后选用适合的解法即可 <code>(๑•̀ㅂ•́)و✧</code></p><h3 id="备注" tabindex="-1"><a class="header-anchor" href="#备注"><span>备注</span></a></h3>',7)),e("ul",null,[e("li",null,[n[56]||(n[56]=o("注 1：部署 Monorepo 到 Netlify (同理 Vercel) 的设定可参考")),e("a",x,[n[55]||(n[55]=o("这篇文章")),l(s)]),n[57]||(n[57]=o("。"))])]),n[71]||(n[71]=e("h2",{id:"深入选型",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#深入选型"},[e("span",null,"深入选型")])],-1)),n[72]||(n[72]=e("p",null,"参考：",-1)),e("ul",null,[e("li",null,[e("a",N,[n[58]||(n[58]=o('【稀土掘金】"分"与"合"的哲学碰撞，Monorepo vs Multirepo')),l(s)])]),e("li",null,[e("a",S,[n[59]||(n[59]=o("Monorepo与multirepo区别何在？为什么大公司像谷歌.微软.优步.Neflix.Nike都在Monorepo?")),l(s)])]),e("li",null,[e("a",C,[n[60]||(n[60]=o("【知乎】REPO 风格之争：MONO VS MULTI")),l(s)])]),e("li",null,[e("a",V,[n[61]||(n[61]=o("【51CTO】2022 了，你还不知道 Multi-repo 和 Mono-repo 的区别么？")),l(s)])])])])}const F=i(u,[["render",T],["__file","Monorepo VS Multirepo.html.vue"]]),L=JSON.parse('{"path":"/01.%20DesignAndDevelop/Develop/03.%20Tools/02.%20%E7%AE%A1%E7%90%86%E5%B1%82/03.%20%E5%A4%9A%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/02.%20%E5%AD%90%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F/%E5%89%8D%E7%AB%AF/Monorepo%20VS%20Multirepo.html","title":"Monorepo VS Multirepo","lang":"zh-CN","frontmatter":{"description":"Monorepo VS Multirepo 三种架构模式 Monolith (单架构) Monorepo (单仓库) Monorepo 是一种代码管理策略，把所有的项目代码都放在一个仓库里，每一个项目、每一个服务或者是每一个包就是这个仓库的一个子目录。 \\"Monorepo\\" 这个词是 “Monolithic Repository” 的缩写, 中文可以翻...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/03.%20Tools/02.%20%E7%AE%A1%E7%90%86%E5%B1%82/03.%20%E5%A4%9A%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/02.%20%E5%AD%90%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F/%E5%89%8D%E7%AB%AF/Monorepo%20VS%20Multirepo.html"}],["meta",{"property":"og:site_name","content":"MdNote_Public"}],["meta",{"property":"og:title","content":"Monorepo VS Multirepo"}],["meta",{"property":"og:description","content":"Monorepo VS Multirepo 三种架构模式 Monolith (单架构) Monorepo (单仓库) Monorepo 是一种代码管理策略，把所有的项目代码都放在一个仓库里，每一个项目、每一个服务或者是每一个包就是这个仓库的一个子目录。 \\"Monorepo\\" 这个词是 “Monolithic Repository” 的缩写, 中文可以翻..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-01-19T07:08:37.000Z"}],["meta",{"property":"article:author","content":"LincDocs"}],["meta",{"property":"article:modified_time","content":"2025-01-19T07:08:37.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Monorepo VS Multirepo\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-01-19T07:08:37.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/MdNote_Public/\\"}]}"]]},"headers":[{"level":1,"title":"Monorepo VS Multirepo","slug":"monorepo-vs-multirepo","link":"#monorepo-vs-multirepo","children":[{"level":2,"title":"三种架构模式","slug":"三种架构模式","link":"#三种架构模式","children":[{"level":3,"title":"Monolith (单架构)","slug":"monolith-单架构","link":"#monolith-单架构","children":[]},{"level":3,"title":"Monorepo (单仓库)","slug":"monorepo-单仓库","link":"#monorepo-单仓库","children":[]},{"level":3,"title":"Multirepo (多仓库)","slug":"multirepo-多仓库","link":"#multirepo-多仓库","children":[]}]},{"level":2,"title":"简单总结","slug":"简单总结","link":"#简单总结","children":[{"level":3,"title":"使用场景","slug":"使用场景","link":"#使用场景","children":[]},{"level":3,"title":"比较","slug":"比较","link":"#比较","children":[]},{"level":3,"title":"GPT简单调研","slug":"gpt简单调研","link":"#gpt简单调研","children":[]}]},{"level":2,"title":"【转】该用 Monorepo 吗？比较 Monolith vs Multi-Repo vs Monorepo","slug":"【转】该用-monorepo-吗-比较-monolith-vs-multi-repo-vs-monorepo","link":"#【转】该用-monorepo-吗-比较-monolith-vs-multi-repo-vs-monorepo","children":[{"level":3,"title":"Monolith (单架构)","slug":"monolith-单架构-1","link":"#monolith-单架构-1","children":[]},{"level":3,"title":"MultiRepo (多仓库)","slug":"multirepo-多仓库-1","link":"#multirepo-多仓库-1","children":[]},{"level":3,"title":"MonoRepo (单仓库)","slug":"monorepo-单仓库-1","link":"#monorepo-单仓库-1","children":[]},{"level":3,"title":"快速上手","slug":"快速上手","link":"#快速上手","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":3,"title":"备注","slug":"备注","link":"#备注","children":[]}]},{"level":2,"title":"深入选型","slug":"深入选型","link":"#深入选型","children":[]}]}],"git":{"createdTime":1737270517000,"updatedTime":1737270517000,"contributors":[{"name":"Linc","email":"762699299@qq.com","commits":1}]},"readingTime":{"minutes":14.56,"words":4368},"filePathRelative":"01. DesignAndDevelop/Develop/03. Tools/02. 管理层/03. 多项目管理/02. 子项目构建系统/前端/Monorepo VS Multirepo.md","localizedDate":"2025年1月19日","excerpt":"\\n<h2>三种架构模式</h2>\\n<h3>Monolith (单架构)</h3>\\n<h3>Monorepo (单仓库)</h3>\\n<p>Monorepo 是一种代码管理策略，把所有的项目代码都放在一个仓库里，每一个项目、每一个服务或者是每一个包就是这个仓库的一个子目录。</p>\\n<p>\\"Monorepo\\" 这个词是 “Monolithic Repository” 的缩写, 中文可以翻译为\\"单体仓库\\"。</p>\\n<p>一般对比另一种策略 -- Multirepo（多仓库），每一个项目或者包都使用一个独立的仓库进行管理。</p>\\n<p>在Monorepo的代码管理方式下：</p>\\n<ol>\\n<li>共享代码非常方便：由于所有项目都在同一个仓库下，它们可以直接引用其他项目的代码，而不需要发布和维护各种共享库。</li>\\n<li>一致性：所有的项目都可以统一使用相同的构建工具和配置，所有人都在一份代码库上工作，大大提高了开发效率。</li>\\n<li>协同开发更简单：无需在多个仓库之间切换，项目之间的协作更为方便。</li>\\n<li>对整个项目的更改可以很容易看到，在提交代码时可以很容易地看到哪些服务或者包可能会受到影响。</li>\\n</ol>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"package.json 子项目问题","link":"01. DesignAndDevelop/Develop/03. Tools/02. 管理层/03. 多项目管理/02. 子项目构建系统/前端/package.json 子项目问题.html"}],"localMap":{"nodes":[{"id":"01. DesignAndDevelop/Develop/03. Tools/02. 管理层/03. 多项目管理/02. 子项目构建系统/前端/Monorepo VS Multirepo.md","value":{"title":"Monorepo VS Multirepo","path":"01. DesignAndDevelop/Develop/03. Tools/02. 管理层/03. 多项目管理/02. 子项目构建系统/前端/Monorepo VS Multirepo.md","outlink":[],"backlink":["01. DesignAndDevelop/Develop/03. Tools/02. 管理层/03. 多项目管理/02. 子项目构建系统/前端/package.json 子项目问题.md"]}},{"id":"01. DesignAndDevelop/Develop/03. Tools/02. 管理层/03. 多项目管理/02. 子项目构建系统/前端/package.json 子项目问题.md","value":{"title":"package.json 子项目问题","path":"01. DesignAndDevelop/Develop/03. Tools/02. 管理层/03. 多项目管理/02. 子项目构建系统/前端/package.json 子项目问题.md","outlink":[],"backlink":[]}}],"links":[{"source":"01. DesignAndDevelop/Develop/03. Tools/02. 管理层/03. 多项目管理/02. 子项目构建系统/前端/package.json 子项目问题.md","target":"01. DesignAndDevelop/Develop/03. Tools/02. 管理层/03. 多项目管理/02. 子项目构建系统/前端/Monorepo VS Multirepo.md"}]}}}');export{F as comp,L as data};
