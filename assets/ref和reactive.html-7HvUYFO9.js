import{_ as s,c as e,b as t,o as a}from"./app-BRS5ycQ2.js";const l={};function n(d,i){return a(),e("div",null,[...i[0]||(i[0]=[t(`<h1 id="ref和reactive" tabindex="-1">ref和reactive</h1><p>Vue 中的 reactive 和 ref 有什么区别？好像都是响应式对象</p><h2 id="基本差异" tabindex="-1">基本差异</h2><ul><li>数据类型处理 <ul><li><code>ref</code>: 可以包装任何数据类型（包括原始类型如 string、number、boolean）</li><li><code>reactive</code>: 只能用于对象类型（对象、数组、Map、Set等）</li></ul></li><li>访问方式 <ul><li><code>ref</code>: 需要通过 <code>.value</code> 属性访问或修改值</li><li><code>reactive</code>: 直接访问和修改属性，不需要 <code>.value</code></li></ul></li><li>响应式原理 <ul><li><code>ref</code>: 基于类的 getter/setter 实现</li><li><code>reactive</code>: 基于 ES6 的 Proxy 实现</li></ul></li><li>选用 <ul><li><code>ref</code>: <ul><li>处理基本类型数据（字符串、数字、布尔值等）时</li><li>需要保持对响应式对象的引用但可能完全替换它时</li><li>单一值的响应式状态时</li></ul></li><li><code>reactive</code>: <ul><li>处理复杂的对象结构时</li><li>多个相关属性需要一起管理时</li><li>不需要替换整个对象时</li></ul></li></ul></li></ul><div class="language-ts line-numbers-mode" data-highlighter="shiki" data-ext="ts" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-ts"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ref</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">reactive</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;vue&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// ref 示例</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> count</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> ref</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 0</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">value</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">++</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 1</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// reactive 示例</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> state</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> reactive</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">({</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  count</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  name</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;Vue&#39;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">})</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">state</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 0</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">state</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">count</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">++</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">state</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其他注意事项：</p><ul><li><code>ref</code> 在模板中会自动解包，不需要使用 <code>.value</code></li><li>解构问题: <ul><li>解构 <code>reactive</code> 对象会丢失响应性</li><li>可以使用 <code>toRefs</code> 将 <code>reactive</code> 对象的属性转换为 <code>ref</code> 以保持响应性</li></ul></li></ul><h2 id="使用建议总结" tabindex="-1">使用建议总结</h2><table><thead><tr><th>场景</th><th>推荐 API</th><th>原因</th></tr></thead><tbody><tr><td>管理对象/数组状态</td><td><code>reactive</code></td><td>直接操作属性，语法更自然</td></tr><tr><td>管理原始值（字符串、数字等）</td><td><code>ref</code></td><td>唯一选择</td></tr><tr><td>组件状态聚合</td><td><code>reactive</code> + <code>toRefs</code></td><td>解构时用 <code>toRefs</code> 保持响应性（如：<code>const { x, y } = toRefs(state)</code>）</td></tr><tr><td>灵活引用（可能替换整个值）</td><td><code>ref</code></td><td>通过 <code>.value</code> 替换不会丢失响应性</td></tr></tbody></table><h2 id="响应性原理差异" tabindex="-1">响应性原理差异</h2><table><thead><tr><th></th><th><code>reactive</code></th><th><code>ref</code></th></tr></thead><tbody><tr><td><strong>实现方式</strong></td><td>使用 <code>Proxy</code> 代理整个对象</td><td>包装对象：<code>{ value: ... }</code> + <code>Proxy</code></td></tr><tr><td>深层响应</td><td>✅ 默认深度响应</td><td>✅ 深度响应（对象类型内部自动用 <code>reactive</code> 转换）</td></tr><tr><td>原始值处理</td><td>❌ 无法处理原始值（String/Number 等）</td><td>✅ 可包装原始值</td></tr></tbody></table><ul><li>Q：reactive 不需要 <code>.value</code> 的原理上也是自动解包吗？</li><li>A：否。<code>reactive</code> 本身就是代理对象（Proxy），而不是包装器。</li></ul>`,12)])])}const r=s(l,[["render",n]]),k=JSON.parse('{"path":"/01.%20DesignAndDevelop/Develop/04.%20Project/Platform/Web/02.%20%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue/Other/ref%E5%92%8Creactive.html","title":"ref和reactive","lang":"zh-CN","frontmatter":{"description":"ref和reactive Vue 中的 reactive 和 ref 有什么区别？好像都是响应式对象 基本差异 数据类型处理 ref: 可以包装任何数据类型（包括原始类型如 string、number、boolean） reactive: 只能用于对象类型（对象、数组、Map、Set等） 访问方式 ref: 需要通过 .value 属性访问或修改值 r...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"ref和reactive\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-12-17T15:21:13.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://LincDocs.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/04.%20Project/Platform/Web/02.%20%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue/Other/ref%E5%92%8Creactive.html"}],["meta",{"property":"og:site_name","content":"MdNote_Public"}],["meta",{"property":"og:title","content":"ref和reactive"}],["meta",{"property":"og:description","content":"ref和reactive Vue 中的 reactive 和 ref 有什么区别？好像都是响应式对象 基本差异 数据类型处理 ref: 可以包装任何数据类型（包括原始类型如 string、number、boolean） reactive: 只能用于对象类型（对象、数组、Map、Set等） 访问方式 ref: 需要通过 .value 属性访问或修改值 r..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-17T15:21:13.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-17T15:21:13.000Z"}]]},"git":{"createdTime":1765984873000,"updatedTime":1765984873000,"contributors":[{"name":"Linc","username":"Linc","email":"762699299@qq.com","commits":1,"url":"https://github.com/Linc"}]},"readingTime":{"minutes":1.73,"words":520},"filePathRelative":"01. DesignAndDevelop/Develop/04. Project/Platform/Web/02. 前端框架/Vue/Other/ref和reactive.md","excerpt":"\\n<p>Vue 中的 reactive 和 ref 有什么区别？好像都是响应式对象</p>\\n<h2>基本差异</h2>\\n<ul>\\n<li>数据类型处理\\n<ul>\\n<li><code>ref</code>: 可以包装任何数据类型（包括原始类型如 string、number、boolean）</li>\\n<li><code>reactive</code>: 只能用于对象类型（对象、数组、Map、Set等）</li>\\n</ul>\\n</li>\\n<li>访问方式\\n<ul>\\n<li><code>ref</code>: 需要通过 <code>.value</code> 属性访问或修改值</li>\\n<li><code>reactive</code>: 直接访问和修改属性，不需要 <code>.value</code></li>\\n</ul>\\n</li>\\n<li>响应式原理\\n<ul>\\n<li><code>ref</code>: 基于类的 getter/setter 实现</li>\\n<li><code>reactive</code>: 基于 ES6 的 Proxy 实现</li>\\n</ul>\\n</li>\\n<li>选用\\n<ul>\\n<li><code>ref</code>:\\n<ul>\\n<li>处理基本类型数据（字符串、数字、布尔值等）时</li>\\n<li>需要保持对响应式对象的引用但可能完全替换它时</li>\\n<li>单一值的响应式状态时</li>\\n</ul>\\n</li>\\n<li><code>reactive</code>:\\n<ul>\\n<li>处理复杂的对象结构时</li>\\n<li>多个相关属性需要一起管理时</li>\\n<li>不需要替换整个对象时</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"01. DesignAndDevelop/Develop/04. Project/Platform/Web/02. 前端框架/Vue/Other/ref和reactive.md","value":{"title":"ref和reactive","path":"01. DesignAndDevelop/Develop/04. Project/Platform/Web/02. 前端框架/Vue/Other/ref和reactive.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{r as comp,k as data};
