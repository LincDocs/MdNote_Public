import{_ as t,c as e,a as s,f as a,b as l,d as h,r as k,o as p}from"./app-DX7xGyNT.js";const d={};function r(A,i){const n=k("VPIcon");return p(),e("div",null,[s("ol",null,[s("li",null,[i[6]||(i[6]=l("C++11: ")),s("ol",null,[i[2]||(i[2]=s("li",null,"(1) 可变参数模板：可以使模板函数接受任意数量的参数。",-1)),s("li",null,[i[0]||(i[0]=l("(2) 智能指针：std")),h(n,{icon:"unique_ptr、std"}),i[1]||(i[1]=l("shared_ptr和std::weak_ptr。"))]),i[3]||(i[3]=s("li",null,"(3) 移动语义：可以更有效地使用内存和处理器资源。",-1)),i[4]||(i[4]=s("li",null,"(4) lambda函数：提供了一种更加简洁和高效的方式来定义本地函数。",-1)),i[5]||(i[5]=s("li",null,"(5) 并行算法：可以在多核处理器上更有效地运行算法。",-1))])]),i[7]||(i[7]=a("<li>C++14: <ol><li>(1) 泛型lambda：可以使用模板参数的lambda函数。</li><li>(2) 可选参数和可变参数模板：可以更灵活地定义函数的参数。</li><li>(3) 常量表达式：可以使用常量值来定义对象。</li><li>(4) 初始化列表的繁琐：可以简化初始化列表的语法。</li></ol></li><li>C++17: <ol><li>(1) 新的for循环：可以使用新的范围for循环以更简洁的方式遍历容器。</li><li>(2) 泛型算法：可以使用泛型算法来完成更复杂的任务。</li><li>(3) 并发库：提供了一组API来支持并发编程。</li><li>(4) 面向对象编程：引入了一组新的特性，如虚函数、抽象类、继承等，来支持面向对象编程。</li></ol></li><li>C++20: <ol><li>(1) 运算符重载：可以重载运算符以定义类型的新操作。</li><li>(2) 模板字面量：可以定义模板字面量来表示常量值。</li><li>(3) 模板别名：可以使用简单的语法来定义模板别名。</li><li>(4) 模板参数包：可以使用参数包来传递任意数量的参数。</li><li>(5) 内联变量：可以定义内联变量，其值可以在编译时被确定。</li></ol></li>",3))]),i[8]||(i[8]=a(`<hr><p>Q：用代码示例说明模板元编程和模板编程的区别</p><p>A：下面是一个简单的代码示例，演示了模板编程和模板元编程的区别：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;iostream&gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;type_traits&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 模板编程示例</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">template</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">typename</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> T</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">T</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">T</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">T</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> b</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> b;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 模板元编程示例</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">template</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> N</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">struct</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> factorial</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> constexpr</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> value </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> N </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> factorial&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">N</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> -</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;::value;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">template</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;&gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">struct</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> factorial</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> constexpr</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> value </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 模板编程示例</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    std::cout </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::endl;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    std::cout </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1.0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2.0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::endl;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 模板元编程示例</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    std::cout </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> factorial&lt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;::value </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::endl;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    std::cout </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> factorial&lt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;::value </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::endl;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    std::cout </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> factorial&lt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;::value </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::endl;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // std::cout &lt;&lt; factorial&lt;-1&gt;::value &lt;&lt; std::endl; // 编译时错误：无法实例化负数的阶乘</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述代码中，<code>add</code> 是一个模板函数，可以接受任意类型的参数。这个函数主要关注于代码的通用性和重用性，通过模板实现了对不同类型的支持。</p><p>而 <code>factorial</code> 是一个模板类，用于计算阶乘。在这个模板类中，使用了递归和静态成员变量的方式来计算阶乘。这个模板类的计算是在编译期间完成的，因此可以在运行时节省计算时间。这个示例主要关注于在编译期间进行元编程和优化。</p><p>因此，模板编程和模板元编程的区别在于：模板编程主要关注代码的通用性和重用性，而模板元编程则更注重在编译期间对程序进行优化和计算。</p><hr>`,8))])}const B=t(d,[["render",r],["__file","C__11~23.html.vue"]]),o=JSON.parse('{"path":"/01.%20DesignAndDevelop/Develop/01.%20Language/C__/08.%20%E6%96%B0%E7%89%B9%E6%80%A7/C__11~23.html","title":"C__11~23","lang":"zh-CN","frontmatter":{"description":"C++11: (1) 可变参数模板：可以使模板函数接受任意数量的参数。 (2) 智能指针：std (3) 移动语义：可以更有效地使用内存和处理器资源。 (4) lambda函数：提供了一种更加简洁和高效的方式来定义本地函数。 (5) 并行算法：可以在多核处理器上更有效地运行算法。 C++14: (1) 泛型lambda：可以使用模板参数的lambda函...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/01.%20Language/C__/08.%20%E6%96%B0%E7%89%B9%E6%80%A7/C__11~23.html"}],["meta",{"property":"og:site_name","content":"MdNote_Public"}],["meta",{"property":"og:description","content":"C++11: (1) 可变参数模板：可以使模板函数接受任意数量的参数。 (2) 智能指针：std (3) 移动语义：可以更有效地使用内存和处理器资源。 (4) lambda函数：提供了一种更加简洁和高效的方式来定义本地函数。 (5) 并行算法：可以在多核处理器上更有效地运行算法。 C++14: (1) 泛型lambda：可以使用模板参数的lambda函..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-09T07:57:06.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-09T07:57:06.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-09T07:57:06.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/MdNote_Public/\\"}]}"]]},"headers":[],"git":{"createdTime":1739087826000,"updatedTime":1739087826000,"contributors":[{"name":"Linc","username":"Linc","email":"762699299@qq.com","commits":1,"url":"https://github.com/Linc"}]},"readingTime":{"minutes":2.74,"words":823},"filePathRelative":"01. DesignAndDevelop/Develop/01. Language/C++/08. 新特性/C++11~23.md","localizedDate":"2025年2月9日","excerpt":"<ol>\\n<li>C++11:\\n<ol>\\n<li>(1) 可变参数模板：可以使模板函数接受任意数量的参数。</li>\\n<li>(2) 智能指针：std</li>\\n<li>(3) 移动语义：可以更有效地使用内存和处理器资源。</li>\\n<li>(4) lambda函数：提供了一种更加简洁和高效的方式来定义本地函数。</li>\\n<li>(5) 并行算法：可以在多核处理器上更有效地运行算法。</li>\\n</ol>\\n</li>\\n<li>C++14:\\n<ol>\\n<li>(1) 泛型lambda：可以使用模板参数的lambda函数。</li>\\n<li>(2) 可选参数和可变参数模板：可以更灵活地定义函数的参数。</li>\\n<li>(3) 常量表达式：可以使用常量值来定义对象。</li>\\n<li>(4) 初始化列表的繁琐：可以简化初始化列表的语法。</li>\\n</ol>\\n</li>\\n<li>C++17:\\n<ol>\\n<li>(1) 新的for循环：可以使用新的范围for循环以更简洁的方式遍历容器。</li>\\n<li>(2) 泛型算法：可以使用泛型算法来完成更复杂的任务。</li>\\n<li>(3) 并发库：提供了一组API来支持并发编程。</li>\\n<li>(4) 面向对象编程：引入了一组新的特性，如虚函数、抽象类、继承等，来支持面向对象编程。</li>\\n</ol>\\n</li>\\n<li>C++20:\\n<ol>\\n<li>(1) 运算符重载：可以重载运算符以定义类型的新操作。</li>\\n<li>(2) 模板字面量：可以定义模板字面量来表示常量值。</li>\\n<li>(3) 模板别名：可以使用简单的语法来定义模板别名。</li>\\n<li>(4) 模板参数包：可以使用参数包来传递任意数量的参数。</li>\\n<li>(5) 内联变量：可以定义内联变量，其值可以在编译时被确定。</li>\\n</ol>\\n</li>\\n</ol>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"01. DesignAndDevelop/Develop/01. Language/C++/08. 新特性/C++11~23.md","value":{"title":"C++11~23","path":"01. DesignAndDevelop/Develop/01. Language/C++/08. 新特性/C++11~23.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{B as comp,o as data};
