import{_ as t,c as o,b as l,o as d}from"./app-dmK2pm5z.js";const n={};function i(r,e){return d(),o("div",null,[...e[0]||(e[0]=[l('<h1 id="rust心得2025-11" tabindex="-1">Rust心得2025-11</h1><h2 id="字符串相关" tabindex="-1">字符串相关</h2><p>记忆建议（快速决策与助记法）</p><ul><li>五个关键词帮你快速选签名：Borrow / Owned / Mutate / Generic / FFI <ul><li>Borrow（只读） <ul><li>&amp;str（最常用）</li><li>&amp;&#39;static str (如果是字面量)</li></ul></li><li>Owned（要所有权） <ul><li>String</li><li>或 <code>Into&lt;String&gt;</code>（若想接收 &amp;str/ String 两种输入用 Into）。</li></ul></li><li>Mutate（就地修改） <ul><li>&amp;mut String</li><li>如果“可能要变为 owned”用 <code>Cow&lt;&#39;a, str&gt;</code>。</li></ul></li><li>Generic（更通用） <ul><li><code>AsRef&lt;str&gt;</code>（只读通用）</li><li><code>Borrow&lt;str&gt;</code>（集合用）</li><li>Display（只需格式化）</li></ul></li><li>FFI（跨语言或非 UTF） <ul><li>CStr/CString</li><li><code>&amp;[u8]/Vec&lt;u8]</code></li></ul></li></ul></li><li>快速选型表（一句话版） <ul><li>只读且想最简单 | <code>&amp;str</code>（或 <code>impl AsRef&lt;str&gt;</code> 用于更通用）</li><li>需要拥有并存储/返回 | <code>String</code> 或 <code>S: Into&lt;String&gt;</code></li><li>大多数只读，少数需修改 | <code>Cow&lt;&#39;a, str&gt;</code></li><li>就地修改现有 String | <code>&amp;mut String</code></li><li>多人共享同一个字符串 | <code>Rc&lt;String&gt; / Arc&lt;String&gt;</code></li><li>与 C 交互或非 UTF | <code>CStr/CString</code> 或 <code>&amp;[u8]/Vec&lt;u8]</code></li><li>需要接受任意可打印类型 | <code>T: Display</code></li></ul></li></ul><h2 id="option-result解包函数的记法" tabindex="-1">Option/Result解包函数的记法</h2><p>你感觉功能和函数名不是很对应，这很正常。关键在于要把它们理解为 <strong>“短语”</strong> 而不是孤立的单词。</p><h3 id="分类-1-取值或提供备选-getting-the-value-or-alternatives" tabindex="-1">分类 1：取值或提供备选 (Getting the Value or Alternatives)</h3><p>这类函数的目标是：从容器中取出值。如果取不出，就用一个备用方案。</p><ul><li><p><code>unwrap()</code></p><ul><li><strong>Unwrap</strong> it, <em>or panic</em>.</li><li><strong>解包</strong>，<em>否则就让程序崩溃</em>。</li><li>最直接、最“暴力”的取值方式。它假设你 100% 确定里面有值</li></ul></li><li><p><code>expect(&quot;message&quot;)</code></p><ul><li>I <strong>expect</strong> a value, <em>or panic with this &quot;message&quot;</em>.</li><li>我<strong>期望</strong>一个值，<em>否则用这条“消息”来崩溃</em>。</li><li><code>unwrap()</code> 的友好版，让你在程序崩溃时知道是“哪个期望”落空了</li></ul></li><li><p><code>unwrap_or(default_value)</code></p><ul><li><strong>Unwrap</strong> it, <strong>or</strong> use this <code>default_value</code>.</li><li><strong>解包</strong>，<strong>或者</strong>使用这个 <code>默认值</code>。</li><li>最常用的备用方案。<code>or</code> 后面直接跟一个现成的值。</li></ul></li><li><p><code>unwrap_or_else(fallback_fn)</code></p><ul><li><strong>Unwrap</strong> it, <strong>or else</strong> execute this <code>fallback_fn</code> to get a value.</li><li><strong>解包</strong>，<strong>否则就</strong>执行这个 <code>备用函数</code> 来获取一个值。</li><li><code>else</code> 在这里暗示了“如果前面的条件不成立，就做这件事”。它接受一个函数（闭包），只在需要备用值时才执行，避免了不必要的开销（惰性求值）。</li></ul></li><li><p><code>unwrap_or_default()</code></p><ul><li><strong>Unwrap</strong> it, <strong>or</strong> use the type&#39;s <strong>default</strong> value.</li><li><strong>解包</strong>，<strong>或者</strong>使用该类型的<strong>默认值</strong>。</li><li><code>unwrap_or</code> 的一个特例，专门用于那些实现了 <code>Default</code> trait 的类型。</li></ul></li></ul><h3 id="分类-2-转换内部的值-mapping-the-inner-value" tabindex="-1">分类 2：转换内部的值 (Mapping the Inner Value)</h3><p>这类函数的目标是：在不破坏容器（<code>Option</code>/<code>Result</code>）的前提下，对内部的值进行转换。</p><ul><li><p><code>map(|v| ...)</code></p><ul><li><strong>Map</strong> the inner value <code>v</code> to a new one.</li><li><strong>映射</strong>内部的值 <code>v</code> 变成一个新值。</li><li>“映射”是核心。<code>Some(1)</code> -&gt; <code>map(|v| v+1)</code> -&gt; <code>Some(2)</code>。<code>None</code> 保持 <code>None</code>。<code>Result</code> 同理。</li></ul></li><li><p><code>map_or(default, |v| ...)</code></p><ul><li><strong>Map</strong> the inner value <code>v</code>, <strong>or</strong> return the <code>default</code>.</li><li><strong>映射</strong>内部的值 <code>v</code>，<strong>或者</strong>直接返回这个 <code>default</code> 值。</li><li>结合了 <code>map</code> 和 <code>unwrap_or</code> 的思想。注意，它的返回值不再是 <code>Option</code>/<code>Result</code>，而是一个普通的值。</li></ul></li><li><p><code>map_or_else(default_fn, |v| ...)</code></p><ul><li><strong>Map</strong> the inner value <code>v</code>, <strong>or else</strong> execute <code>default_fn</code> to get a return value.</li><li><strong>映射</strong>内部的值 <code>v</code>，<strong>否则就</strong>执行 <code>default_fn</code> 来获取一个返回值。</li><li><code>map_or</code> 的惰性版本。<code>else</code> 再次暗示了“执行一个函数”。</li></ul></li><li><p><code>map_err(|e| ...)</code> (<code>Result</code> 专用)</p><ul><li><strong>Map</strong> the <strong>error</strong> value <code>e</code> to a new one.</li><li><strong>映射****错误</strong>值 <code>e</code> 变成一个新值。</li><li><code>map</code> 只处理 <code>Ok</code> 的情况，而 <code>map_err</code> 只处理 <code>Err</code> 的情况。函数名清晰地表达了它的意图。</li></ul></li></ul><h3 id="分类-3-链式操作-chaining-operations" tabindex="-1">分类 3：链式操作 (Chaining Operations)</h3><p>这类函数的目标是：执行一个操作，该操作的返回值本身又是一个 <code>Option</code> 或 <code>Result</code>。</p><ul><li><p><code>and_then(|v| ...)</code></p><ul><li>If it&#39;s <code>Ok</code>/<code>Some</code>, <strong>and then</strong> execute this operation.</li><li>如果它是 <code>Ok</code>/<code>Some</code>，<strong>然后就</strong>执行这个操作。</li><li><code>and</code> 体现了“成功路径”的延续。用于将多个可能失败的操作串联起来。例如：先解析用户ID，<strong>然后就</strong>用ID去数据库查找用户。</li></ul></li><li><p><code>or_else(|e| ...)</code></p><ul><li>If it&#39;s <code>Err</code>/<code>None</code>, <strong>or else</strong> try this alternative operation.</li><li>如果它是 <code>Err</code>/<code>None</code>，<strong>否则就</strong>试试这个备用操作。</li><li><code>or else</code> 体现了“失败路径”的备用方案。用于在一个操作失败后，尝试另一个可能成功的操作。例如：先尝试从缓存读取数据，<strong>否则就</strong>去数据库里读。</li></ul></li><li><p><code>and(opt_b)</code></p><ul><li>If the first is <code>Some</code>, <strong>and</strong> the second is <code>Some</code>, return the second.</li><li>如果第一个是 <code>Some</code>，<strong>并且</strong>第二个是 <code>Some</code>，则返回第二个。</li><li>逻辑“与”操作。只有两者都“成功”(<code>Some</code>)时，才算成功，并取第二个的值。任何一个 <code>None</code> 都会导致结果是 <code>None</code>。</li></ul></li><li><p><code>or(opt_b)</code></p><ul><li>Return the first if it&#39;s <code>Some</code>, <strong>or</strong> return the second.</li><li>如果第一个是 <code>Some</code> 就返回它，<strong>或者</strong>返回第二个。</li><li>逻辑“或”操作。只要有一个“成功”(<code>Some</code>)，就返回第一个成功的值。</li></ul></li></ul><h3 id="分类-4-类型转换-type-conversion" tabindex="-1">分类 4：类型转换 (Type Conversion)</h3><p>这类函数的目标是：在 <code>Option</code> 和 <code>Result</code> 之间互相转换。</p><ul><li><p><code>ok_or(err_value)</code> (<code>Option</code> 专用)</p><ul><li>Make it &quot;<strong>Ok</strong>&quot;, <strong>or</strong> provide this <code>err_value</code>.</li><li>把它变成 &quot;<strong>Ok</strong>&quot;，<strong>或者</strong>（在它是<code>None</code>时）提供这个 <code>err_value</code>。</li><li><code>Some(v)</code> -&gt; <code>Ok(v)</code>，<code>None</code> -&gt; <code>Err(err_value)</code>。这是将“有无”问题升级为“成败”问题的标准方法。</li></ul></li><li><p><code>ok_or_else(err_fn)</code> (<code>Option</code> 专用)</p><ul><li>Make it &quot;<strong>Ok</strong>&quot;, <strong>or else</strong> execute <code>err_fn</code> to create an error.</li><li>把它变成 &quot;<strong>Ok</strong>&quot;，<strong>否则就</strong>执行 <code>err_fn</code> 来创建一个错误。</li><li><code>ok_or</code> 的惰性版本。</li></ul></li><li><p><code>ok()</code> (<code>Result</code> 专用)</p><ul><li>Keep only the &quot;<strong>Ok</strong>&quot; value (as <code>Some</code>), discard any <code>Err</code>.</li><li>只保留 &quot;<strong>Ok</strong>&quot; 的值（并包装为 <code>Some</code>），丢弃所有 <code>Err</code>。</li><li><code>Ok(v)</code> -&gt; <code>Some(v)</code>，<code>Err(e)</code> -&gt; <code>None</code>。当你不再关心失败的具体原因时使用。</li></ul></li><li><p><code>err()</code> (<code>Result</code> 专用)</p><ul><li>Keep only the &quot;<strong>Err</strong>&quot; value (as <code>Some</code>), discard any <code>Ok</code>.</li><li>只保留 &quot;<strong>Err</strong>&quot; 的值（并包装为 <code>Some</code>），丢弃所有 <code>Ok</code>。</li><li><code>Err(e)</code> -&gt; <code>Some(e)</code>，<code>Ok(v)</code> -&gt; <code>None</code>。当你只关心失败，并想对失败原因进行处理时使用。</li></ul></li></ul><h3 id="总结表格" tabindex="-1">总结表格</h3><table><thead><tr><th style="text-align:left;">函数名</th><th style="text-align:left;">关键助记词</th><th style="text-align:left;">意图</th></tr></thead><tbody><tr><td style="text-align:left;"><code>unwrap_or</code></td><td style="text-align:left;"><strong>or</strong> (或者)</td><td style="text-align:left;">提供一个<strong>值</strong>作为备选</td></tr><tr><td style="text-align:left;"><code>unwrap_or_else</code></td><td style="text-align:left;"><strong>or else</strong> (否则就)</td><td style="text-align:left;">提供一个<strong>函数</strong>来计算备选值</td></tr><tr><td style="text-align:left;"><code>map</code></td><td style="text-align:left;"><strong>map</strong> (映射)</td><td style="text-align:left;">转换容器<strong>内部</strong>的值</td></tr><tr><td style="text-align:left;"><code>map_or</code></td><td style="text-align:left;"><strong>map or</strong> (映射或者)</td><td style="text-align:left;">转换内部值，或提供一个<strong>值</strong>作为备选</td></tr><tr><td style="text-align:left;"><code>map_or_else</code></td><td style="text-align:left;"><strong>map or else</strong> (映射否则就)</td><td style="text-align:left;">转换内部值，或提供一个<strong>函数</strong>计算备选</td></tr><tr><td style="text-align:left;"><code>and_then</code></td><td style="text-align:left;"><strong>and then</strong> (然后就)</td><td style="text-align:left;">成功后的<strong>链式操作</strong></td></tr><tr><td style="text-align:left;"><code>or_else</code></td><td style="text-align:left;"><strong>or else</strong> (否则就)</td><td style="text-align:left;">失败后的<strong>备选操作</strong></td></tr><tr><td style="text-align:left;"><code>ok_or</code></td><td style="text-align:left;"><strong>ok or</strong> (Ok或者)</td><td style="text-align:left;"><code>Option</code> 转 <code>Result</code>，<code>None</code>时提供错误<strong>值</strong></td></tr><tr><td style="text-align:left;"><code>ok_or_else</code></td><td style="text-align:left;"><strong>ok or else</strong> (Ok否则就)</td><td style="text-align:left;"><code>Option</code> 转 <code>Result</code>，<code>None</code>时调用<strong>函数</strong></td></tr></tbody></table><p>希望这个详细的“翻译”列表能帮你建立起对这些函数名的直觉，从而彻底告别混淆！</p>',21)])])}const s=t(n,[["render",i]]),g=JSON.parse(`{"path":"/03.%20SkillAndProduction/%E6%9C%AA%E5%88%86%E7%B1%BB/Rust%E5%BF%83%E5%BE%9711.html","title":"Rust心得2025-11","lang":"zh-CN","frontmatter":{"create_date":"2025-11-05T00:00:00.000Z","last_date":"2025-11-05T00:00:00.000Z","author":"LincZero","description":"Rust心得2025-11 字符串相关 记忆建议（快速决策与助记法） 五个关键词帮你快速选签名：Borrow / Owned / Mutate / Generic / FFI Borrow（只读） &str（最常用） &'static str (如果是字面量) Owned（要所有权） String 或 Into<String>（若想接收 &str/ S...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Rust心得2025-11\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-12-13T16:40:43.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincZero\\"}]}"],["meta",{"property":"og:url","content":"https://LincDocs.github.io/MdNote_Public/03.%20SkillAndProduction/%E6%9C%AA%E5%88%86%E7%B1%BB/Rust%E5%BF%83%E5%BE%9711.html"}],["meta",{"property":"og:site_name","content":"MdNote_Public"}],["meta",{"property":"og:title","content":"Rust心得2025-11"}],["meta",{"property":"og:description","content":"Rust心得2025-11 字符串相关 记忆建议（快速决策与助记法） 五个关键词帮你快速选签名：Borrow / Owned / Mutate / Generic / FFI Borrow（只读） &str（最常用） &'static str (如果是字面量) Owned（要所有权） String 或 Into<String>（若想接收 &str/ S..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-13T16:40:43.000Z"}],["meta",{"property":"article:author","content":"LincZero"}],["meta",{"property":"article:modified_time","content":"2025-12-13T16:40:43.000Z"}]]},"git":{"createdTime":1765644043000,"updatedTime":1765644043000,"contributors":[{"name":"Linc","username":"Linc","email":"762699299@qq.com","commits":1,"url":"https://github.com/Linc"}]},"readingTime":{"minutes":5.41,"words":1624},"filePathRelative":"03. SkillAndProduction/未分类/Rust心得11.md","excerpt":"\\n<h2>字符串相关</h2>\\n<p>记忆建议（快速决策与助记法）</p>\\n<ul>\\n<li>五个关键词帮你快速选签名：Borrow / Owned / Mutate / Generic / FFI\\n<ul>\\n<li>Borrow（只读）\\n<ul>\\n<li>&amp;str（最常用）</li>\\n<li>&amp;'static str (如果是字面量)</li>\\n</ul>\\n</li>\\n<li>Owned（要所有权）\\n<ul>\\n<li>String</li>\\n<li>或 <code>Into&lt;String&gt;</code>（若想接收 &amp;str/ String 两种输入用 Into）。</li>\\n</ul>\\n</li>\\n<li>Mutate（就地修改）\\n<ul>\\n<li>&amp;mut String</li>\\n<li>如果“可能要变为 owned”用 <code>Cow&lt;'a, str&gt;</code>。</li>\\n</ul>\\n</li>\\n<li>Generic（更通用）\\n<ul>\\n<li><code>AsRef&lt;str&gt;</code>（只读通用）</li>\\n<li><code>Borrow&lt;str&gt;</code>（集合用）</li>\\n<li>Display（只需格式化）</li>\\n</ul>\\n</li>\\n<li>FFI（跨语言或非 UTF）\\n<ul>\\n<li>CStr/CString</li>\\n<li><code>&amp;[u8]/Vec&lt;u8]</code></li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>快速选型表（一句话版）\\n<ul>\\n<li>只读且想最简单 | <code>&amp;str</code>（或 <code>impl AsRef&lt;str&gt;</code> 用于更通用）</li>\\n<li>需要拥有并存储/返回 | <code>String</code> 或 <code>S: Into&lt;String&gt;</code></li>\\n<li>大多数只读，少数需修改 | <code>Cow&lt;'a, str&gt;</code></li>\\n<li>就地修改现有 String | <code>&amp;mut String</code></li>\\n<li>多人共享同一个字符串 | <code>Rc&lt;String&gt; / Arc&lt;String&gt;</code></li>\\n<li>与 C 交互或非 UTF | <code>CStr/CString</code> 或 <code>&amp;[u8]/Vec&lt;u8]</code></li>\\n<li>需要接受任意可打印类型 | <code>T: Display</code></li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"03. SkillAndProduction/未分类/Rust心得11.md","value":{"title":"Rust心得11","path":"03. SkillAndProduction/未分类/Rust心得11.md","outlink":[],"backlink":[]}}],"links":[]}}}`);export{s as comp,g as data};
