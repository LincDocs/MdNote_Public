import{_ as l,c as e,b as t,o}from"./app-hiXU-NgH.js";const a="/MdNote_Public/assets/image-20220516065258452-D2R0_Q5E.png",n="/MdNote_Public/assets/image-20220516065924737-DgHEmSpM.png",p="/MdNote_Public/assets/image-20220516070721003-BkVtP-Sv.png",d="/MdNote_Public/assets/image-20220516071101842-CUp8z5d-.png",s="/MdNote_Public/assets/image-20220516071219028-CzrJqMI3.png",r={};function c(b,i){return o(),e("div",null,[...i[0]||(i[0]=[t('<h1 id="编程通识" tabindex="-1">编程通识</h1><h1 id="目录" tabindex="-1">目录</h1><h1 id="编程通识-1" tabindex="-1">编程通识</h1><p>参考：<a href="https://www.bilibili.com/video/BV123411p7rf" target="_blank" rel="noopener noreferrer">https://www.bilibili.com/video/BV123411p7rf</a></p><h2 id="通用计算机" tabindex="-1">通用计算机</h2><p>各种计算机语言通用的东西：</p><ul><li><strong>通用性</strong>：专用计算机、通用计算机（图灵完备）</li><li><strong>通用计算机模型（实现方法）</strong>：图灵机、Lambda演算法系统、元胞计算机、递归、面向对象 等等 <ul><li><strong>相同点和区别</strong><ul><li>相同点：解决问题的能力等价，都是图灵完备的<br> 并且这几个模型都是可以互相虚拟的</li><li>不同点：对问题的拆解、建模，把问题投射到数据模型上，有区别</li></ul></li><li><strong>图灵完备</strong><ul><li>图灵机、Lambda演算法系统、元胞计算机都是图灵完备的</li><li><code>邱奇-图灵猜想</code>：“任何可以用算法实现的计算，都可以用图灵机实现”，没有更完备的了</li><li>也叫<code>图灵完备</code>：代表和图灵机有相同处理能力。图灵机、Lambda演算法系统、元胞计算机都是图灵完备</li></ul></li><li><strong>超越图灵机？</strong><ul><li>比图灵机更完备的：可能量子计算机、大脑、宇宙能吧，反正搞不来。例如宇宙还有 &quot;真·随机&quot;、自我指涉</li></ul></li><li><strong>图灵完备的局限性</strong><ul><li>不是所有东西都能解决。比如不能解决<code>停机问题</code>：&quot;设计一个程序来判断，另一个图灵机程序是否可以在有限时间内完成&quot;</li><li><code>哥德尔不完备定理</code>：理想系统不存在。<code>自我指涉</code>的逻辑悖论</li></ul></li></ul></li><li><strong>计算机的内存结构</strong>：冯诺依曼结构、哈佛结构</li></ul><h3 id="图灵机" tabindex="-1">图灵机</h3><h4 id="计算机语言的特性-拆分方法" tabindex="-1">计算机语言的特性（拆分方法）</h4><p><code>程序 = 数据 + 指令</code></p><p>现在基本都是用的图灵机，计算机语言也基本都满足这个特性</p><h4 id="优点" tabindex="-1">优点</h4><p>（为什么现在都用的图灵机而不用图灵完备的其他模型呢）</p><ul><li>是最直观、最容易工程实现的方案</li><li>图灵机可以让问题的拆解和解构更容易<br> 图灵机的基础模块就是 “数据+指令“（将实际问题拆成数据和指令就很容易建模了、方便程序设计）<br> 数据类型：类似于物理中的量纲</li></ul><h3 id="lambda演算法-λ演算法" tabindex="-1">Lambda演算法（λ演算法）</h3><p>图灵的老师 —— 邱奇提出来的</p><p>Lambda演算法</p><p>又分无类型lambda演算和有类型的。例如LISP只有两种数据结构，原子（atom）和表（list）</p><h4 id="计算机语言的特性-拆分方法-1" tabindex="-1">计算机语言的特性（拆分方法）</h4><p>核心概念：<code>函数</code><br> 图灵机中的 数据或指令 在这里都可以用函数来表示<br> Lambda演算法中的符号不重要，重要的是符号和符号之间的关系<br><strong>一个lambda表达式通过另一个lambda表达式可以变成一个新的lambda表达式</strong>，能把一种关系变成另一种关系</p><p>表示方法如图</p><p><img src="'+a+`" alt="image-20220516065258452" loading="lazy"></p><h4 id="相关语言" tabindex="-1">相关语言</h4><p>（这种函数式编程语言基于Lambda演算法，不过现在用的都是在图灵机上进行了lmabda演算的虚拟）</p><ul><li><p>Haskell</p></li><li><p>LISP<br> （就是那个偷火箭LISP代码的笑话）</p><blockquote><p>LISP是一种通用高级计算机程序语言，长期以来垄断人工智能领域的应用。<br> LISP作为应用人工智能而设计的语言，是第一个<code>声明式系内函数式</code>程序设计语言（最早的函数式编程语言），<br> 有别于<code>命令式系内过程式</code>的C、Fortran和面向对象的Java、C#等结构化程序设计语言</p><p>LISP名称源自列表处理（LISt Processing）的英语缩写，由来自麻省理工学院的人工智能研究先驱约翰·麦卡锡（John McCarthy）在1958年基于λ演算所创造，采用抽象数据列表与递归作符号演算来衍生人工智能</p><div class="language-lisp line-numbers-mode" data-highlighter="shiki" data-ext="lisp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-lisp"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">DEFUN</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> HELLO</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ()</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  &quot;HELLO WORLD&quot;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li></li></ul></blockquote></li></ul><h4 id="使用lambda演算法虚拟出图灵机" tabindex="-1">使用lambda演算法虚拟出图灵机</h4><ul><li><p>虚拟 图灵机中的 “数据”</p><p><img src="`+n+'" alt="image-20220516065924737" loading="lazy"></p></li><li><p>虚拟 自然数</p><p><img src="'+p+'" alt="image-20220516070721003" loading="lazy"></p></li><li><p>后继函数（可以理解成 x+=1 的意思）</p><p><img src="'+d+'" alt="image-20220516071101842" loading="lazy"></p></li><li><p>加法函数</p><p><img src="'+s+'" alt="image-20220516071219028" loading="lazy"></p></li></ul><h4 id="与函数式编程" tabindex="-1">与函数式编程</h4><ul><li><p>函数式编程来源于Lambda演算法</p><ul><li><p>柯里化、闭包、匿名函数等，都来源与lambda演算法</p></li><li><p>lambda演算法中的函数都是匿名函数</p><p>（js中的匿名函数又能写成箭头函数）</p></li></ul></li></ul><h4 id="区别与优点-对比图灵机" tabindex="-1">区别与优点（对比图灵机）</h4><ul><li>定义上的区别 <ul><li>图灵机：操作可以自由定义，往往特事特办，当面对特殊情况、无法预料的情况时处理不了</li><li>Lambda演算法：操作不是被定义出来的，而是定义数据后找规律，把操作给找出来<br> 函数式编程会有更少的bug。这也是强类型所导致的，lambda的数据类型非常强</li><li>图灵机要求你清楚所有情况再定义，lambda是定义规律</li></ul></li><li>相关程序设计语言 <ul><li>图灵机：<code>声明式系内函数式</code>程序设计语言（函数式编程语言）</li><li>Lambda演算法：<code>命令式系内过程式</code>程序设计语言</li></ul></li><li>应用 <ul><li>图灵机：擅长解决工程问题<br> 更像是工程师</li><li>Lambda演算法：LISP：最开始就与AI开发有关、与自然语言处理 (非AI 纯靠逻辑的那种) 有关<br> 更像是数学家物理学家</li></ul></li></ul><h3 id="元胞自动机" tabindex="-1">元胞自动机</h3><p>最早由冯诺依曼提出，但没重视，跑去弄冯诺依曼结构了</p><h4 id="计算机语言的特性-拆分方法-2" tabindex="-1">计算机语言的特性（拆分方法）</h4><p>核心：元胞</p><p>不能拆成指令和数据，和图灵机或Lambda演算法的范式有着本质不同</p><h4 id="相关-语言" tabindex="-1">相关“语言”</h4><p>没有针对它的计算机编程语言，没有编程方案，</p><p>但是有元胞计算机相关的东西：《生命的游戏》</p><blockquote><p>《生命的游戏》</p><p>四条规则：</p><p>一个元胞周围的元胞数为 0：死亡<br> 一个元胞周围的细胞数为 2/3：适应<br> 一个元胞周围的细胞 &gt;4：拥挤、消失<br> 一个空格周围有3个元胞：重生</p><p>产生情况：</p><p>不变<br> 周期<br> 移动（飞船，移动速度最快为2回合一格，有点光速的感觉）<br> 复制（高斯帕机枪）</p><p>还可以用生命游戏模拟生命游戏</p></blockquote><h4 id="图灵完备性" tabindex="-1">图灵完备性</h4><p>《生命的游戏》中，</p><p>飞船相撞：相当于非运算</p><h4 id="区别和优点" tabindex="-1">区别和优点</h4><blockquote><h5 id="吃豆游戏中的遗传算法" tabindex="-1">吃豆游戏中的遗传算法</h5></blockquote><p>约翰霍兰德，用计算机做的一个实验</p><p>当时霍兰德研究的是进化策略，他的这篇开山之作叫《自然与人工系统中的适应》，研究的内容，可以简单的描述为吃豆游戏<br> [吃豆游戏中的遗传算法](<a href="https://sq.sf.163.com/blog/article/197481681108668416" target="_blank" rel="noopener noreferrer">https://sq.sf.163.com/blog/article/197481681108668416</a>)</p><p>这种的最优方法没有规律，图灵机和Lambda演算法不好弄，Lambda演算法没法发现规律，用元胞计算机这种群体的自动演算会好一点</p><blockquote><h5 id="冯诺依曼瓶颈" tabindex="-1">冯诺依曼瓶颈</h5></blockquote><p>图灵机有<code>冯诺依曼瓶颈</code>：内存读写性能拖累cpu，cpu毕竟只能线性读写</p><p>元胞计算机没有，没有cpu。模型运算是群体涌现出来的</p><p>有点像脑神经元，但应该也没超越图灵完备</p><p>文小刚，凝聚态理论里的大佬，理论物理最高奖狄拉克奖的获奖者</p><blockquote><h5 id="深度学习、神经网络、元胞自动机、类脑芯片" tabindex="-1">深度学习、神经网络、元胞自动机、类脑芯片</h5></blockquote><p>可以在计算机中虚拟神经网络，但硬件结构还是有限制，于是<code>类脑芯片</code>的概念被提出来了</p><p>类脑芯片，由许多的<code>存算一体单元</code>组成。或者用门电路和电容实现、<br> 或者用<code>忆组器</code> (特殊电阻，可以对之前留过它的电流形成记忆，类似于使用较多的神经元会变粗) 实现</p><p>区别</p><ul><li>传统芯片 <ul><li>基本范式：门电路</li><li>使用方式：编程，数据+指令</li></ul></li><li>忆阻芯片 <ul><li>基本范式：电流和电阻之间的关系</li><li>使用方式：学习、自适应。没法有目的地修改</li></ul></li></ul>',58)])])}const m=l(r,[["render",c]]),u=JSON.parse('{"path":"/01.%20DesignAndDevelop/Develop/03.%20Tools/01.%20%E7%9F%A5%E8%AF%86%E5%B1%82/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/%E7%BC%96%E7%A8%8B%E9%80%9A%E8%AF%86.html","title":"编程通识","lang":"zh-CN","frontmatter":{"description":"编程通识 目录 编程通识 参考：https://www.bilibili.com/video/BV123411p7rf 通用计算机 各种计算机语言通用的东西： 通用性：专用计算机、通用计算机（图灵完备） 通用计算机模型（实现方法）：图灵机、Lambda演算法系统、元胞计算机、递归、面向对象 等等 相同点和区别 相同点：解决问题的能力等价，都是图灵完备的...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"编程通识\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-10-20T22:18:42.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://LincDocs.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/03.%20Tools/01.%20%E7%9F%A5%E8%AF%86%E5%B1%82/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/%E7%BC%96%E7%A8%8B%E9%80%9A%E8%AF%86.html"}],["meta",{"property":"og:site_name","content":"MdNote_Public"}],["meta",{"property":"og:title","content":"编程通识"}],["meta",{"property":"og:description","content":"编程通识 目录 编程通识 参考：https://www.bilibili.com/video/BV123411p7rf 通用计算机 各种计算机语言通用的东西： 通用性：专用计算机、通用计算机（图灵完备） 通用计算机模型（实现方法）：图灵机、Lambda演算法系统、元胞计算机、递归、面向对象 等等 相同点和区别 相同点：解决问题的能力等价，都是图灵完备的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-20T22:18:42.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-20T22:18:42.000Z"}]]},"git":{"createdTime":1760998722000,"updatedTime":1760998722000,"contributors":[{"name":"Linc","username":"Linc","email":"762699299@qq.com","commits":1,"url":"https://github.com/Linc"}]},"readingTime":{"minutes":6.72,"words":2015},"filePathRelative":"01. DesignAndDevelop/Develop/03. Tools/01. 知识层/程序员的自我修养/编程通识.md","excerpt":"\\n<h1>目录</h1>\\n<h1>编程通识</h1>\\n<p>参考：<a href=\\"https://www.bilibili.com/video/BV123411p7rf\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://www.bilibili.com/video/BV123411p7rf</a></p>\\n<h2>通用计算机</h2>\\n<p>各种计算机语言通用的东西：</p>\\n<ul>\\n<li><strong>通用性</strong>：专用计算机、通用计算机（图灵完备）</li>\\n<li><strong>通用计算机模型（实现方法）</strong>：图灵机、Lambda演算法系统、元胞计算机、递归、面向对象 等等\\n<ul>\\n<li><strong>相同点和区别</strong>\\n<ul>\\n<li>相同点：解决问题的能力等价，都是图灵完备的<br>\\n并且这几个模型都是可以互相虚拟的</li>\\n<li>不同点：对问题的拆解、建模，把问题投射到数据模型上，有区别</li>\\n</ul>\\n</li>\\n<li><strong>图灵完备</strong>\\n<ul>\\n<li>图灵机、Lambda演算法系统、元胞计算机都是图灵完备的</li>\\n<li><code>邱奇-图灵猜想</code>：“任何可以用算法实现的计算，都可以用图灵机实现”，没有更完备的了</li>\\n<li>也叫<code>图灵完备</code>：代表和图灵机有相同处理能力。图灵机、Lambda演算法系统、元胞计算机都是图灵完备</li>\\n</ul>\\n</li>\\n<li><strong>超越图灵机？</strong>\\n<ul>\\n<li>比图灵机更完备的：可能量子计算机、大脑、宇宙能吧，反正搞不来。例如宇宙还有 \\"真·随机\\"、自我指涉</li>\\n</ul>\\n</li>\\n<li><strong>图灵完备的局限性</strong>\\n<ul>\\n<li>不是所有东西都能解决。比如不能解决<code>停机问题</code>：\\"设计一个程序来判断，另一个图灵机程序是否可以在有限时间内完成\\"</li>\\n<li><code>哥德尔不完备定理</code>：理想系统不存在。<code>自我指涉</code>的逻辑悖论</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li><strong>计算机的内存结构</strong>：冯诺依曼结构、哈佛结构</li>\\n</ul>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"01. DesignAndDevelop/Develop/03. Tools/01. 知识层/程序员的自我修养/编程通识.md","value":{"title":"编程通识","path":"01. DesignAndDevelop/Develop/03. Tools/01. 知识层/程序员的自我修养/编程通识.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{m as comp,u as data};
