import{_ as l,c as n,f as e,a as s,b as t,d as h,r as p,o as r}from"./app-BpMPCgQm.js";const k={};function d(o,i){const a=p("VPIcon");return r(),n("div",null,[i[2]||(i[2]=e(`<h1 id="qt" tabindex="-1"><a class="header-anchor" href="#qt"><span>Qt</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="qt元对象和属性系统" tabindex="-1"><a class="header-anchor" href="#qt元对象和属性系统"><span>Qt元对象和属性系统</span></a></h1><p>参考</p><ul><li><a href="http://c.biancheng.net/view/1826.html" target="_blank" rel="noopener noreferrer">【C语言中文网】Qt元对象和属性系统详解</a></li></ul><h2 id="qt-的元对象系统-meta-object-system" tabindex="-1"><a class="header-anchor" href="#qt-的元对象系统-meta-object-system"><span>Qt 的元对象系统（Meta-Object System）</span></a></h2><h3 id="组成" tabindex="-1"><a class="header-anchor" href="#组成"><span>组成</span></a></h3><p>组成： 元对象系统由以下三个基础组成：</p><ol><li>QObject 类是所有使用元对象系统的类的基类。</li><li>在一个类的 private 部分声明 Q_OBJECT宏，使得类可以使用元对象的特性，如<strong>动态属性、信号与槽</strong></li><li>MOC（元对象编译器）为每个 <strong>QObject 的子类</strong>提供必要的代码来实现元对象系统的特性。 构建项目时，MOC 工具读取 C++ 源文件，当它发现类的定义里有 Q_OBJECT 宏时，它就会为这个类生成另外一个包含有元对象支持代码的 C++ 源文件，这个生成的源文件连同类的实现文件一起被编译和连接。</li></ol><h3 id="作用" tabindex="-1"><a class="header-anchor" href="#作用"><span>作用</span></a></h3><p>作用（基本作用）：Qt 的元对象系统（Meta-Object System）提供了</p><ul><li>对象之间通信的信号与槽机制</li><li>运行时类型信息</li><li>动态属性系统</li></ul><p>作用（函数的具体表现）：除了信号与槽机制外，元对象还提供如下一些功能：</p><ul><li><p><code>QObject::metaObject()</code> 函数返回类关联的元对象，元对象类 QMetaObject 包含了访问元对象的一些接口函数，例如 QMetaObject::className() 函数可在运行时返回类的名称字符串。</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">QObject </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">obj </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> QPushButton;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">obj</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">metaObject</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()-&gt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">className</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ();</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> //返回&quot;QPushButton&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>QMetaObject::newInstance()</code> 函数创建类的一个新的实例。</p></li><li><p><code>QObject::inherits(const char *className)</code> 函数判断一个对象实例是否是名称为 className 的类或 QObject 的子类的实例。例如：</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">QTimer </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">timer </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> QTimer;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // QTimer 是 QObject 的子类</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">timer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">inherits</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;QTimer&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 返回 true</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">timer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">inherits</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;QObject&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 返回 true</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">timer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">inherits</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;QAbstractButton&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//返回 false,不是 QAbstractButton 的子类</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>QObject::tr() 和 QObject::trUtf8()</code> 函数可翻译字符串，用于多语言界面设计，后续章会专门介绍多语言界面设计。</p></li><li><p><code>QObject::setProperty() 和 QObject::property()</code> 函数用于通过属性名称动态设置和获取属性值。</p></li></ul><h3 id="其他" tabindex="-1"><a class="header-anchor" href="#其他"><span>其他</span></a></h3><p>对于 QObject 及其子类，还可以使用 qobject_cast() 函数进行动态投射（dynamic cast）。例如，假设 QMyWidget 是 QWidget 的子类并且在类定义中声明了 Q_OBJECT 宏。创建实例使用下面的语句：</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">QObject </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">obj </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> QMyWidget;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>变量 obj 定义为 QObject 指针，但它实际指向 QMyWidget 类，所以可以正确投射为 QWidget，即：</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">QWidget </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">widget </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> qobject_cast</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">QWidget</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;(obj);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>从 QObject 到 QWidget 的投射是成功的，因为 obj 实际是 QMyWidget 类，是 QWidget 的子类。也可以将其成功投射为 QMyWidget，即：</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">QMyWidget </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">myWidget </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> qobject_cast</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">QMyWidget</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;(obj);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>投射为 QMyWidget 是成功的，因为 qobject_cast() 并不区分 Qt 内建的类型和用户自定义类型。但是，若要将 obj 投射为 QLabel 则是失败的，即：</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">QLabel </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> label </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">-</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> qobject_cast</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">QLabel</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;(obj);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这样投射是失败的，返回指针 label 为 NULL，因为 QMyWidget 不是 QLabel 的子类。</p><p>使用动态投射，使得程序可以在运行时对不同的对象做不同的处理。</p><h2 id="属性系统" tabindex="-1"><a class="header-anchor" href="#属性系统"><span>属性系统</span></a></h2><h3 id="属性定义" tabindex="-1"><a class="header-anchor" href="#属性定义"><span>属性定义</span></a></h3><p>Qt 提供一个 Q_PROPERTY() 宏可以定义属性，它也是基于元对象系统实现的。Qt 的属性系统与 C++ 编译器无关，可以用任何标准的 C++ 编译器编译定义了属性的 Qt C++ 程序。</p><p>在 QObject 的子类中，用宏 Q_PROPERTY() 定义属性，其使用格式如下：</p><p>Q_PROPERTY(type name (READ getFunction [WRITE setFunction] | MEMBER meznberName [(READ getFunction | WRITE setFunction)]) [RESET resetFunction] [NOTIFY notifySignal] [REVISION int] [DESIGNABLE bool] [SCRIPTABLE bool] [STORED bool] [USER bool] [CONSTANT] [FINAL])</p><p>Q_PROPERTY 宏定义一个返回值类型为 type，名称为 name 的属性，用 READ、WRITE 关键字定义属性的读取、写入函数，还有其他的一些关键字定义属性的一些操作特性。属性的类型可以是 QVariant 支持的任何类型，也可以用户自定义类型。</p><p>Q_PROPERTY 宏定义属性的一些主要关键字的意义如下：</p><ul><li>READ 指定一个读取属性值的函数，没有 MEMBER 关键字时必须设置 READ。</li><li>WRITE 指定一个设定属性值的函数，只读属性没有 WRITE 设置。</li><li>MEMBER 指定一个成员变量与属性关联，成为可读可写的属性，无需再设置 READ 和 WRITE。</li><li>RESET 是可选的，用于指定一个设置属性缺省值的函数。</li><li>NOTIFY 是可选的，用于设置一个信号，当属性值变化时发射此信号。</li><li>DESIGNABLE 表示属性是否在 Qt Designer 里可见，缺省为 true。</li><li>CONSTANT 表示属性值是一个常数，对于一个对象实例，READ 指定的函数返回值是常数，但是每个实例的返回值可以不一样。具有 CONSTANT 关键字的属性不能有 WRITE 和 NOTIFY 关键字。</li><li>FINAL 表示所定义的属性不能被子类重载。</li></ul><p>QWidget 类定义属性的一些例子如下：</p><p>Q_PROPERTY(bool focus READ hasFocus) Q_PROPERTY(bool enabled READ isEnabled WRITE setEnabled) Q_PROPERTY(QCursor cursor READ cursor WRITE setCursor RESET unsetCursor)</p><h3 id="属性的使用" tabindex="-1"><a class="header-anchor" href="#属性的使用"><span>属性的使用</span></a></h3>`,36)),s("p",null,[i[0]||(i[0]=t("不管是否用 READ 和 WRITE 定义了接口函数，只要知道属性名称，就可以通过 QObject")),h(a,{icon:"property() 读取属性值，并通过 QObject"}),i[1]||(i[1]=t("setProperty() 设置属性值。例如："))]),i[3]||(i[3]=s("p",null,'QPushButton *button = new QPushButton; QObject *object = button； object->setProperty("flat", true); bool isFlat= object->property ("flat");',-1)),i[4]||(i[4]=s("h3",{id:"动态属性",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#动态属性"},[s("span",null,"动态属性")])],-1)),i[5]||(i[5]=s("p",null,"QObject::setProperty() 函数可以在运行时为类定义一个新的属性，称之为动态属性。动态属性是针对类的实例定义的。",-1)),i[6]||(i[6]=s("p",null,"动态属性可以使用 QObject::property() 查询，就如在类定义里用 Q_PROPERTY 宏定义的属性一样。",-1)),i[7]||(i[7]=s("p",null,"例如，在数据表编辑界面上，一些字段是必填字段，就可以在初始化界面时为这些字段的关联显示组件定义一个新的 required 属性，并设置值为“true”，如：",-1)),i[8]||(i[8]=s("p",null,'editName->setProperty("required", "true"); comboSex->setProperty("required", "true"); checkAgree->setProperty("required", "true");',-1)),i[9]||(i[9]=s("p",null,"然后，可以应用下面的样式定义将这种必填字段的背景颜色设置为亮绿色。",-1)),i[10]||(i[10]=s("p",{"background-color:lime":""},'*[required="true"]',-1)),i[11]||(i[11]=e(`<h3 id="类的附加信息" tabindex="-1"><a class="header-anchor" href="#类的附加信息"><span>类的附加信息</span></a></h3><p>属性系统还有一个宏 Q_CLASSINFO()，可以为类的元对象定义“名称——值”信息，如：</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> QMyClass</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> QObject</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    Q_OBJECT</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    Q_CLASSINFO</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;author&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Wang&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    Q_CLASSINFO</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;company&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;UPC&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    Q_CLASSINFO</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;version &quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;3.0.1&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  public:</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    ...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>用 Q_CLASSINFO() 宏定义附加类信息后，可以通过元对象的一些函数获取类的附加信息，如 classlnfo(int) 获取某个附加信息，函数原型定义如下：</p><p>QMetaClassInfo QMetaObject::classInfo(int index) const</p><p>返回值是 QMetaClassInfo 类型，有 name() 和 value() 两个函数，可获得类附加信息的名称和值。</p><h2 id="跨工程问题——moc相关报错" tabindex="-1"><a class="header-anchor" href="#跨工程问题——moc相关报错"><span>跨工程问题——moc相关报错</span></a></h2><p>这里的跨工程指不同时编译的两个工程，会引发moc相关报错</p><h3 id="存在问题举例" tabindex="-1"><a class="header-anchor" href="#存在问题举例"><span>存在问题举例</span></a></h3><p>例如： 插件接口在工程A，插件使用了Q_OBJECT声明启用了元对象系统。 插件实现在工程B，工程B使用工程A的插件接口文件。</p><p>则报错：</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">error: </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">LNK2001: 无法解析的外部符号 </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;public: virtual struct QMetaObject const * __cdecl PluginInterface::metaObject(void)const &quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">metaObject@PluginInterface@@UEBAPEBUQMetaObject@@XZ)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">LNK1120</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 4</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 个无法解析的外部命令</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="结合moc编译原理分析原因" tabindex="-1"><a class="header-anchor" href="#结合moc编译原理分析原因"><span>结合moc编译原理分析原因</span></a></h3><p>似乎是因为pro文件不知道使用了那个元文件，<strong>没有使用moc工具编译</strong>一次工程A的插件<strong>接口文件</strong></p><h3 id="解决方法" tabindex="-1"><a class="header-anchor" href="#解决方法"><span>解决方法</span></a></h3><p>两个工程各有一个拷贝</p><p>或者 “添加现有文件” 的方式，主要目的是在pro文件中的HEADERS中添加指定文件，加入moc编译列表中</p>`,17))])}const A=l(k,[["render",d],["__file","04. Qt元对象和属性系统.html.vue"]]),g=JSON.parse('{"path":"/01.%20DesignAndDevelop/Develop/04.%20Project/Platform/Multi/QT%EF%BC%88Cpp%EF%BC%89/01.%20%E7%AE%80%E6%A6%82/03.%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/04.%20Qt%E5%85%83%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%B1%9E%E6%80%A7%E7%B3%BB%E7%BB%9F.html","title":"Qt","lang":"zh-CN","frontmatter":{"description":"Qt 目录 Qt元对象和属性系统 参考 【C语言中文网】Qt元对象和属性系统详解 Qt 的元对象系统（Meta-Object System） 组成 组成： 元对象系统由以下三个基础组成： QObject 类是所有使用元对象系统的类的基类。 在一个类的 private 部分声明 Q_OBJECT宏，使得类可以使用元对象的特性，如动态属性、信号与槽 MOC...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/04.%20Project/Platform/Multi/QT%EF%BC%88Cpp%EF%BC%89/01.%20%E7%AE%80%E6%A6%82/03.%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/04.%20Qt%E5%85%83%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%B1%9E%E6%80%A7%E7%B3%BB%E7%BB%9F.html"}],["meta",{"property":"og:site_name","content":"MdNote_Public"}],["meta",{"property":"og:title","content":"Qt"}],["meta",{"property":"og:description","content":"Qt 目录 Qt元对象和属性系统 参考 【C语言中文网】Qt元对象和属性系统详解 Qt 的元对象系统（Meta-Object System） 组成 组成： 元对象系统由以下三个基础组成： QObject 类是所有使用元对象系统的类的基类。 在一个类的 private 部分声明 Q_OBJECT宏，使得类可以使用元对象的特性，如动态属性、信号与槽 MOC..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-05T16:08:48.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-05T16:08:48.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Qt\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-05T16:08:48.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/MdNote_Public/\\"}]}"]]},"headers":[{"level":1,"title":"Qt","slug":"qt","link":"#qt","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"Qt元对象和属性系统","slug":"qt元对象和属性系统","link":"#qt元对象和属性系统","children":[{"level":2,"title":"Qt 的元对象系统（Meta-Object System）","slug":"qt-的元对象系统-meta-object-system","link":"#qt-的元对象系统-meta-object-system","children":[{"level":3,"title":"组成","slug":"组成","link":"#组成","children":[]},{"level":3,"title":"作用","slug":"作用","link":"#作用","children":[]},{"level":3,"title":"其他","slug":"其他","link":"#其他","children":[]}]},{"level":2,"title":"属性系统","slug":"属性系统","link":"#属性系统","children":[{"level":3,"title":"属性定义","slug":"属性定义","link":"#属性定义","children":[]},{"level":3,"title":"属性的使用","slug":"属性的使用","link":"#属性的使用","children":[]},{"level":3,"title":"动态属性","slug":"动态属性","link":"#动态属性","children":[]},{"level":3,"title":"类的附加信息","slug":"类的附加信息","link":"#类的附加信息","children":[]}]},{"level":2,"title":"跨工程问题——moc相关报错","slug":"跨工程问题——moc相关报错","link":"#跨工程问题——moc相关报错","children":[{"level":3,"title":"存在问题举例","slug":"存在问题举例","link":"#存在问题举例","children":[]},{"level":3,"title":"结合moc编译原理分析原因","slug":"结合moc编译原理分析原因","link":"#结合moc编译原理分析原因","children":[]},{"level":3,"title":"解决方法","slug":"解决方法","link":"#解决方法","children":[]}]}]}],"git":{"createdTime":1738771728000,"updatedTime":1738771728000,"contributors":[{"name":"Linc","username":"Linc","email":"762699299@qq.com","commits":1,"url":"https://github.com/Linc"}]},"readingTime":{"minutes":6.17,"words":1851},"filePathRelative":"01. DesignAndDevelop/Develop/04. Project/Platform/Multi/QT（Cpp）/01. 简概/03. 基础知识点/04. Qt元对象和属性系统.md","localizedDate":"2025年2月5日","excerpt":"\\n<h1>目录</h1>\\n<h1>Qt元对象和属性系统</h1>\\n<p>参考</p>\\n<ul>\\n<li><a href=\\"http://c.biancheng.net/view/1826.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">【C语言中文网】Qt元对象和属性系统详解</a></li>\\n</ul>\\n<h2>Qt 的元对象系统（Meta-Object System）</h2>\\n<h3>组成</h3>\\n<p>组成： 元对象系统由以下三个基础组成：</p>\\n<ol>\\n<li>QObject 类是所有使用元对象系统的类的基类。</li>\\n<li>在一个类的 private 部分声明 Q_OBJECT宏，使得类可以使用元对象的特性，如<strong>动态属性、信号与槽</strong></li>\\n<li>MOC（元对象编译器）为每个 <strong>QObject 的子类</strong>提供必要的代码来实现元对象系统的特性。\\n构建项目时，MOC 工具读取 C++ 源文件，当它发现类的定义里有 Q_OBJECT 宏时，它就会为这个类生成另外一个包含有元对象支持代码的 C++ 源文件，这个生成的源文件连同类的实现文件一起被编译和连接。</li>\\n</ol>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"01. DesignAndDevelop/Develop/04. Project/Platform/Multi/QT（Cpp）/01. 简概/03. 基础知识点/04. Qt元对象和属性系统.md","value":{"title":"04. Qt元对象和属性系统","path":"01. DesignAndDevelop/Develop/04. Project/Platform/Multi/QT（Cpp）/01. 简概/03. 基础知识点/04. Qt元对象和属性系统.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{A as comp,g as data};
