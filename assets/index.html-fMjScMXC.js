import{_ as t,c as o,e as i,o as n}from"./app-vjeVIT9l.js";const a={};function l(c,e){return n(),o("div",null,e[0]||(e[0]=[i('<h1 id="web服务器实战-多线程web服务器" tabindex="-1">Web服务器实战：多线程Web服务器</h1><p>一般来说，现代化的 web 服务器往往都基于更加轻量级的协程或 async/await 等模式实现，但是基于本章的内容，我们还是采取较为传统的多线程的方式来实现，即：一个请求连接分配一个线程去独立处理，当然还有升级版的线程池。</p><p>在本章中你将了解：</p><ol><li>学习一点 TCP 和 HTTP</li><li>在套接字 socket 上监听进入的 TCP 连接</li><li>解析 HTTP 请求</li><li>创建合适的 HTTP 应答</li><li>使用线程池来提升 web 服务器的吞吐量</li></ol><blockquote><p>本章的实现方法并不是在 Rust 中实现 Web 服务器的最佳方法，后续章节的 async/await 会更加适合!</p></blockquote>',5)]))}const s=t(a,[["render",l]]),r=JSON.parse('{"path":"/01.%20DesignAndDevelop/Develop/01.%20Language/Rust/%E5%AD%A6%E4%B9%A0/08.%20%E5%8A%9F%E8%83%BD%E7%B1%BB/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/","title":"Web服务器实战：多线程Web服务器","lang":"zh-CN","frontmatter":{"description":"Web服务器实战：多线程Web服务器 一般来说，现代化的 web 服务器往往都基于更加轻量级的协程或 async/await 等模式实现，但是基于本章的内容，我们还是采取较为传统的多线程的方式来实现，即：一个请求连接分配一个线程去独立处理，当然还有升级版的线程池。 在本章中你将了解： 学习一点 TCP 和 HTTP 在套接字 socket 上监听进入的...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Web服务器实战：多线程Web服务器\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-06-27T15:03:03.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://LincDocs.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/01.%20Language/Rust/%E5%AD%A6%E4%B9%A0/08.%20%E5%8A%9F%E8%83%BD%E7%B1%BB/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],["meta",{"property":"og:site_name","content":"MdNote_Public"}],["meta",{"property":"og:title","content":"Web服务器实战：多线程Web服务器"}],["meta",{"property":"og:description","content":"Web服务器实战：多线程Web服务器 一般来说，现代化的 web 服务器往往都基于更加轻量级的协程或 async/await 等模式实现，但是基于本章的内容，我们还是采取较为传统的多线程的方式来实现，即：一个请求连接分配一个线程去独立处理，当然还有升级版的线程池。 在本章中你将了解： 学习一点 TCP 和 HTTP 在套接字 socket 上监听进入的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-27T15:03:03.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-27T15:03:03.000Z"}]]},"git":{"createdTime":1751036583000,"updatedTime":1751036583000,"contributors":[{"name":"Linc","username":"Linc","email":"762699299@qq.com","commits":1,"url":"https://github.com/Linc"}]},"readingTime":{"minutes":0.67,"words":201},"filePathRelative":"01. DesignAndDevelop/Develop/01. Language/Rust/学习/08. 功能类/Web服务器/README.md","excerpt":"\\n<p>一般来说，现代化的 web 服务器往往都基于更加轻量级的协程或 async/await 等模式实现，但是基于本章的内容，我们还是采取较为传统的多线程的方式来实现，即：一个请求连接分配一个线程去独立处理，当然还有升级版的线程池。</p>\\n<p>在本章中你将了解：</p>\\n<ol>\\n<li>学习一点 TCP 和 HTTP</li>\\n<li>在套接字 socket 上监听进入的 TCP 连接</li>\\n<li>解析 HTTP 请求</li>\\n<li>创建合适的 HTTP 应答</li>\\n<li>使用线程池来提升 web 服务器的吞吐量</li>\\n</ol>\\n<blockquote>\\n<p>本章的实现方法并不是在 Rust 中实现 Web 服务器的最佳方法，后续章节的 async/await 会更加适合!</p>\\n</blockquote>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"01. DesignAndDevelop/Develop/01. Language/Rust/学习/08. 功能类/Web服务器/README.md","value":{"title":"08. 功能类/","path":"01. DesignAndDevelop/Develop/01. Language/Rust/学习/08. 功能类/Web服务器/README.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{s as comp,r as data};
