import{_ as e,c as l,f as n,o as s}from"./app-CZ3290nv.js";const a="/MdNote_Public/assets/I_O%E8%BD%AF%E4%BB%B6%E5%88%86%E5%B1%82-Cv_d35w5.png",t="/MdNote_Public/assets/ae4363a7c56c01613089ff67270b9a21-BxsMa072.png",o="/MdNote_Public/assets/2f4550ee9e8461a237c1adc5bd6a0775-XnKYSJJp.png",r={};function p(h,i){return s(),l("div",null,i[0]||(i[0]=[n('<h1 id="通用块层" tabindex="-1"><a class="header-anchor" href="#通用块层"><span>通用块层</span></a></h1><h2 id="提前总结" tabindex="-1"><a class="header-anchor" href="#提前总结"><span>提前总结</span></a></h2><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>通用块层</p><ul><li>总作用 <ul><li>管理块设备。为了减少不同块设备的差异带来的影响，Linux 通过一个统一的 通用块层，来管理不同的块设备。</li></ul></li><li>具体功能 <ol><li>提供访问块设备的标准接口</li><li>IO调度</li></ol></li></ul><h3 id="架构图" tabindex="-1"><a class="header-anchor" href="#架构图"><span>架构图</span></a></h3><p>通用块层是 <strong>处于文件系统和磁盘驱动中间的一个块设备抽象层</strong></p><p><img src="'+a+`" alt="img" loading="lazy"></p><h2 id="功能" tabindex="-1"><a class="header-anchor" href="#功能"><span>功能</span></a></h2><p>它主要有两个功能：</p><ol><li><p>提供标准接口</p><ul><li>向上为文件系统和应用程序，提供访问块设备的标准接口，向下把各种<strong>不同的磁盘设备抽象为统一的块设备</strong>，并在内核层面，提供一个框架来管理这些设备的驱动程序；</li></ul></li><li><p>IO调度</p><ul><li>通用层还会给文件系统和应用程序发来的 I/O 请求排队，接着会对队列重新排序、请求合并等方式，也就是 <strong>I/O 调度</strong>，主要目的是为了<strong>提高磁盘读写的效率</strong>。</li><li>（但话说 “存储系统分层图” 里不是还有个块设备IO调度层嘛？不应该是那个负责的才对吗？）</li></ul></li></ol><h2 id="_5-种-i-o-调度算法" tabindex="-1"><a class="header-anchor" href="#_5-种-i-o-调度算法"><span>5 种 I/O 调度算法</span></a></h2><p>Linc：《小林图解里对这部分的描述不和很详细》，此处可以另外找资料补充下。</p><p>另参考：</p><ul><li><a href="https://www.cnblogs.com/liushuhe1990/articles/11141172.html" target="_blank" rel="noopener noreferrer">Linux IO Scheduler（Linux IO 调度器） </a></li><li><a href="https://www.cnblogs.com/sky-heaven/p/16423372.html" target="_blank" rel="noopener noreferrer">io调度算法【转】</a></li></ul><h3 id="_5种io调度算法" tabindex="-1"><a class="header-anchor" href="#_5种io调度算法"><span>5种IO调度算法</span></a></h3><p>Linux 内存支持 5 种 I/O 调度算法，分别是：</p><ol><li><strong>没有</strong>调度算法 (NOOP, No Operation，又称电梯调度算法) <ul><li>原理：不对文件系统和应用程序的 I/O 做任何处理</li><li>适用：<em>虚拟机 I/O</em> 比较常用，此时磁盘 I/O 调度算法交由物理机系统负责</li></ul></li><li><strong>先入先出</strong>调度算法 <ul><li>原理：先进入 I/O 调度队列的 I/O 请求先发生</li><li>优点：这是最简单的 I/O 调度算法</li></ul></li><li><strong>完全公平</strong>调度算法 (CFQ, Completely Fair Queuing，完全公平排队) <ul><li>原理：它为每个进程维护了一个 I/O 调度队列，并按照时间片来均匀分布每个进程的 I/O 请求</li><li>适用：<em>大部分系统</em> 都把这个算法作为默认的 I/O 调度器</li></ul></li><li><strong>优先级</strong>调度算法 <ul><li>原理：顾名思义，优先级高的 I/O 请求先发生</li><li>适用：<em>运行大量进程的系统</em>（像是桌面环境、多媒体应用等）（我记得桌面系统往往会有意将显示IO的优先级调高/低，避免画面卡死/降帧优化性能）</li></ul></li><li><strong>最终期限</strong>调度算法 <ul><li>原理：分别为读、写请求创建了不同的 I/O 队列</li><li>优点：这样可以提高机械磁盘的吞吐量，并确保达到最终期限的请求被优先处理</li><li>适用：<em>I/O 压力比较大的场景</em>（比如数据库等）</li></ul></li></ol><h3 id="io调度器" tabindex="-1"><a class="header-anchor" href="#io调度器"><span>IO调度器</span></a></h3><ol><li>NOOP</li><li>CFQ (Completely Fair Queuing，完全公平排队)</li><li>DEADLINE：在CFQ基础上接触IO饿死问题</li><li>Anticipatory</li></ol><h3 id="修改io调度算法" tabindex="-1"><a class="header-anchor" href="#修改io调度算法"><span>修改IO调度算法</span></a></h3><p>在RHEL5/OEL5以及之后的版本中（比如RHEL6和RHEL7），可以针对每块磁盘制定I/O Scheduler，修改完毕立刻生效，比如：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">$</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> cat</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /sys/block/sda1/queue/scheduler</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[noop] anticipatory deadline cfq</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">#修改为cfq</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">$</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> echo</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;cfq&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">/sys/block/sda1/queue/scheduler</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">#立刻生效</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">$</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> cat</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /sys/block/sda1/queue/scheduler</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">noop</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> anticipatory</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> deadline</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [cfq]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+t+'" alt="image" loading="lazy"></p><p><img src="'+o+'" alt="image" loading="lazy"></p>',25)]))}const c=e(r,[["render",p],["__file","04. 通用块层、IO调度算法.html.vue"]]),g=JSON.parse('{"path":"/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E3%80%8A%E5%B0%8F%E6%9E%97coding_%E5%9B%BE%E8%A7%A3%E7%B3%BB%E5%88%97%E3%80%8B/01.%20%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/08.%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/04.%20%E9%80%9A%E7%94%A8%E5%9D%97%E5%B1%82%E3%80%81IO%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.html","title":"通用块层","lang":"zh-CN","frontmatter":{"description":"通用块层 提前总结 总结 通用块层 总作用 管理块设备。为了减少不同块设备的差异带来的影响，Linux 通过一个统一的 通用块层，来管理不同的块设备。 具体功能 提供访问块设备的标准接口 IO调度 架构图 通用块层是 处于文件系统和磁盘驱动中间的一个块设备抽象层 img 功能 它主要有两个功能： 提供标准接口 向上为文件系统和应用程序，提供访问块设备的...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Computer/03.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20-%20%E7%BA%BF%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%89%88/%E3%80%8A%E5%B0%8F%E6%9E%97coding_%E5%9B%BE%E8%A7%A3%E7%B3%BB%E5%88%97%E3%80%8B/01.%20%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/08.%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/04.%20%E9%80%9A%E7%94%A8%E5%9D%97%E5%B1%82%E3%80%81IO%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.html"}],["meta",{"property":"og:site_name","content":"MdNote_Public"}],["meta",{"property":"og:title","content":"通用块层"}],["meta",{"property":"og:description","content":"通用块层 提前总结 总结 通用块层 总作用 管理块设备。为了减少不同块设备的差异带来的影响，Linux 通过一个统一的 通用块层，来管理不同的块设备。 具体功能 提供访问块设备的标准接口 IO调度 架构图 通用块层是 处于文件系统和磁盘驱动中间的一个块设备抽象层 img 功能 它主要有两个功能： 提供标准接口 向上为文件系统和应用程序，提供访问块设备的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-01-28T10:12:49.000Z"}],["meta",{"property":"article:modified_time","content":"2025-01-28T10:12:49.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"通用块层\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-01-28T10:12:49.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/MdNote_Public/\\"}]}"]]},"headers":[{"level":1,"title":"通用块层","slug":"通用块层","link":"#通用块层","children":[{"level":2,"title":"提前总结","slug":"提前总结","link":"#提前总结","children":[{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":3,"title":"架构图","slug":"架构图","link":"#架构图","children":[]}]},{"level":2,"title":"功能","slug":"功能","link":"#功能","children":[]},{"level":2,"title":"5 种 I/O 调度算法","slug":"_5-种-i-o-调度算法","link":"#_5-种-i-o-调度算法","children":[{"level":3,"title":"5种IO调度算法","slug":"_5种io调度算法","link":"#_5种io调度算法","children":[]},{"level":3,"title":"IO调度器","slug":"io调度器","link":"#io调度器","children":[]},{"level":3,"title":"修改IO调度算法","slug":"修改io调度算法","link":"#修改io调度算法","children":[]}]}]}],"git":{"createdTime":1738059169000,"updatedTime":1738059169000,"contributors":[{"name":"Linc","username":"Linc","email":"762699299@qq.com","commits":1,"url":"https://github.com/Linc"}]},"readingTime":{"minutes":2.88,"words":865},"filePathRelative":"01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/01. 图解系统/08. 设备管理/04. 通用块层、IO调度算法.md","localizedDate":"2025年1月28日","excerpt":"\\n<h2>提前总结</h2>\\n<h3>总结</h3>\\n<p>通用块层</p>\\n<ul>\\n<li>总作用\\n<ul>\\n<li>管理块设备。为了减少不同块设备的差异带来的影响，Linux 通过一个统一的 通用块层，来管理不同的块设备。</li>\\n</ul>\\n</li>\\n<li>具体功能\\n<ol>\\n<li>提供访问块设备的标准接口</li>\\n<li>IO调度</li>\\n</ol>\\n</li>\\n</ul>\\n<h3>架构图</h3>\\n<p>通用块层是 <strong>处于文件系统和磁盘驱动中间的一个块设备抽象层</strong></p>\\n<p></p>\\n<h2>功能</h2>\\n<p>它主要有两个功能：</p>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"04. IO调度算法","link":"01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/01. 图解系统/06. 调度算法/04. IO调度算法.html"}],"localMap":{"nodes":[{"id":"01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/01. 图解系统/08. 设备管理/04. 通用块层、IO调度算法.md","value":{"title":"04. 通用块层、IO调度算法","path":"01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/01. 图解系统/08. 设备管理/04. 通用块层、IO调度算法.md","outlink":[],"backlink":["01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/01. 图解系统/06. 调度算法/04. IO调度算法.md"]}},{"id":"01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/01. 图解系统/06. 调度算法/04. IO调度算法.md","value":{"title":"04. IO调度算法","path":"01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/01. 图解系统/06. 调度算法/04. IO调度算法.md","outlink":[],"backlink":[]}}],"links":[{"source":"01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/01. 图解系统/06. 调度算法/04. IO调度算法.md","target":"01. DesignAndDevelop/Develop/02. Theory/Computer/03. 计算机系统 - 线性学习版/《小林coding_图解系列》/01. 图解系统/08. 设备管理/04. 通用块层、IO调度算法.md"}]}}}');export{c as comp,g as data};
