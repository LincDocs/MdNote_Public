import{_ as n,c as p,a as e,b as o,o as E}from"./app-DviKfT4E.js";const i={};function a(l,t){return E(),p("div",null,t[0]||(t[0]=[e("h1",{id:"前端的面向对象",tabindex:"-1"},"前端的面向对象",-1),e("h2",{id:"面向对象-在前端的实现",tabindex:"-1"},"面向对象，在前端的实现",-1),e("p",null,"不同的组件看作不同的类",-1),e("h3",{id:"继承",tabindex:"-1"},"继承",-1),e("h3",{id:"指针引用",tabindex:"-1"},"指针引用",-1),e("p",null,"这里一方面，得先看组件间的互相方法。方法有很多，但都比较绕。",-1),e("p",null,"比较符合后端习惯的一个方法是（不符合前端习惯），数据传递有一个方法就是直接修改props中的对象 (只能是对象，props的值不可被修改)。但是这种方式修改不一定会被数据驱动给捕获到。",-1),e("p",null,[o("例如 vue-flow，通常还要更新完之后执行一下 "),e("code",null,"updateNodesData"),o(" 方法。基于数据驱动的东西才能捕获到这种变化")],-1)]))}const A=n(i,[["render",a]]),s=JSON.parse('{"path":"/01.%20DesignAndDevelop/Develop/03.%20Tools/03.%20%E7%AE%A1%E7%90%86%E5%B1%82/01.%20%E5%A4%9A%E7%B1%BB%E7%AE%A1%E7%90%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%B7%A8%E6%8A%80%E6%9C%AF%E6%A0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%89%8D%E7%AB%AF%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html","title":"前端的面向对象","lang":"zh-CN","frontmatter":{"description":"前端的面向对象 面向对象，在前端的实现 不同的组件看作不同的类 继承 指针引用 这里一方面，得先看组件间的互相方法。方法有很多，但都比较绕。 比较符合后端习惯的一个方法是（不符合前端习惯），数据传递有一个方法就是直接修改props中的对象 (只能是对象，props的值不可被修改)。但是这种方式修改不一定会被数据驱动给捕获到。 例如 vue-flow，通...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"前端的面向对象\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-07-31T15:27:19.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://LincDocs.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/03.%20Tools/03.%20%E7%AE%A1%E7%90%86%E5%B1%82/01.%20%E5%A4%9A%E7%B1%BB%E7%AE%A1%E7%90%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%B7%A8%E6%8A%80%E6%9C%AF%E6%A0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%89%8D%E7%AB%AF%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html"}],["meta",{"property":"og:site_name","content":"MdNote_Public"}],["meta",{"property":"og:title","content":"前端的面向对象"}],["meta",{"property":"og:description","content":"前端的面向对象 面向对象，在前端的实现 不同的组件看作不同的类 继承 指针引用 这里一方面，得先看组件间的互相方法。方法有很多，但都比较绕。 比较符合后端习惯的一个方法是（不符合前端习惯），数据传递有一个方法就是直接修改props中的对象 (只能是对象，props的值不可被修改)。但是这种方式修改不一定会被数据驱动给捕获到。 例如 vue-flow，通..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-31T15:27:19.000Z"}],["meta",{"property":"article:modified_time","content":"2025-07-31T15:27:19.000Z"}]]},"git":{"createdTime":1753975639000,"updatedTime":1753975639000,"contributors":[{"name":"Linc","username":"Linc","email":"762699299@qq.com","commits":1,"url":"https://github.com/Linc"}]},"readingTime":{"minutes":0.58,"words":173},"filePathRelative":"01. DesignAndDevelop/Develop/03. Tools/03. 管理层/01. 多类管理/设计模式/跨技术栈设计模式/前端的面向对象.md","excerpt":"\\n<h2>面向对象，在前端的实现</h2>\\n<p>不同的组件看作不同的类</p>\\n<h3>继承</h3>\\n<h3>指针引用</h3>\\n<p>这里一方面，得先看组件间的互相方法。方法有很多，但都比较绕。</p>\\n<p>比较符合后端习惯的一个方法是（不符合前端习惯），数据传递有一个方法就是直接修改props中的对象 (只能是对象，props的值不可被修改)。但是这种方式修改不一定会被数据驱动给捕获到。</p>\\n<p>例如 vue-flow，通常还要更新完之后执行一下 <code>updateNodesData</code> 方法。基于数据驱动的东西才能捕获到这种变化</p>\\n","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"01. DesignAndDevelop/Develop/03. Tools/03. 管理层/01. 多类管理/设计模式/跨技术栈设计模式/前端的面向对象.md","value":{"title":"前端的面向对象","path":"01. DesignAndDevelop/Develop/03. Tools/03. 管理层/01. 多类管理/设计模式/跨技术栈设计模式/前端的面向对象.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{A as comp,s as data};
