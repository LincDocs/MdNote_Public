import{_ as l,c as t,f as i,o as n}from"./app-CfmvdVmg.js";const o={};function c(p,e){return n(),t("div",null,e[0]||(e[0]=[i('<h1 id="qt" tabindex="-1"><a class="header-anchor" href="#qt"><span>Qt</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="对象树和拥有权" tabindex="-1"><a class="header-anchor" href="#对象树和拥有权"><span>对象树和拥有权</span></a></h1><h2 id="对象模型-对象树" tabindex="-1"><a class="header-anchor" href="#对象模型-对象树"><span>对象模型（对象树）</span></a></h2><p>parent-child机制</p><ul><li><p>作用</p><ul><li>介绍Qt时提到一点：一定程度简化垃圾回收机制，就是这个 —— 对象树机制</li><li>这意味着类与类为包含关系时，被包含的类可以使用new方式声明而不用在析构中销毁</li></ul></li><li><p>简概</p><ul><li>Qt中创建对象时会提供一个Parent对象指针</li><li>注意，对象树不等于继承树</li></ul></li><li><p>原理</p><ul><li><p>当创建一个<code>QObject</code>对象时，其构造函数接受一个<code>QObject</code>指针作为参数，这个参数是<code>parent</code>，也就是<code>父对象指针</code>（不是父类）</p><ul><li><p>可以通过构造函数传入<code>父对象指针</code>，也可以后期通过<code>setParent()</code>函数修改<code>父对象指针</code>，一般为this</p></li><li><p>这个QObject对象会自动添加到<strong>父对象的<code>children()</code>列表</strong></p></li></ul></li><li><p>当<code>父对象</code>析构时，这个列表中的所有对象也会被析构</p></li><li><p>这种机制在GUI程序设计中相当有用</p></li><li><p>即：<mark>不需要delete QObject对象及其后代类</mark></p></li></ul></li><li><p>补充</p><ul><li>这里的设计可能有点反直觉：父对象指针为参，但目的是要调用*parent里面的addChildren()??方法来修改的是父对象中的children()列表</li><li>之所以这样设计 <ul><li>一是方便于为组件指定的父对象（如控件所属哪个窗口）</li><li>二是以便与在构造QObject对象时完成所有操作（而不是把QObject对象传入到包含它的类的方法参数里）</li><li>三是将children放在父对象中，当销毁父对象的时候不需要遍历所有对象，就能直接找到要销毁的子对象</li></ul></li></ul></li></ul>',6)]))}const r=l(o,[["render",c],["__file","03. 对象树和拥有权.html.vue"]]),d=JSON.parse('{"path":"/01.%20DesignAndDevelop/Develop/04.%20Project/Platform/Multi/QT%EF%BC%88Cpp%EF%BC%89/01.%20%E7%AE%80%E6%A6%82/03.%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/03.%20%E5%AF%B9%E8%B1%A1%E6%A0%91%E5%92%8C%E6%8B%A5%E6%9C%89%E6%9D%83.html","title":"Qt","lang":"zh-CN","frontmatter":{"description":"Qt 目录 对象树和拥有权 对象模型（对象树） parent-child机制 作用 介绍Qt时提到一点：一定程度简化垃圾回收机制，就是这个 —— 对象树机制 这意味着类与类为包含关系时，被包含的类可以使用new方式声明而不用在析构中销毁 简概 Qt中创建对象时会提供一个Parent对象指针 注意，对象树不等于继承树 原理 当创建一个QObject对象时...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/04.%20Project/Platform/Multi/QT%EF%BC%88Cpp%EF%BC%89/01.%20%E7%AE%80%E6%A6%82/03.%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/03.%20%E5%AF%B9%E8%B1%A1%E6%A0%91%E5%92%8C%E6%8B%A5%E6%9C%89%E6%9D%83.html"}],["meta",{"property":"og:site_name","content":"MdNote_Public"}],["meta",{"property":"og:title","content":"Qt"}],["meta",{"property":"og:description","content":"Qt 目录 对象树和拥有权 对象模型（对象树） parent-child机制 作用 介绍Qt时提到一点：一定程度简化垃圾回收机制，就是这个 —— 对象树机制 这意味着类与类为包含关系时，被包含的类可以使用new方式声明而不用在析构中销毁 简概 Qt中创建对象时会提供一个Parent对象指针 注意，对象树不等于继承树 原理 当创建一个QObject对象时..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-05T05:13:59.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-05T05:13:59.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Qt\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-05T05:13:59.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/MdNote_Public/\\"}]}"]]},"headers":[{"level":1,"title":"Qt","slug":"qt","link":"#qt","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"对象树和拥有权","slug":"对象树和拥有权","link":"#对象树和拥有权","children":[{"level":2,"title":"对象模型（对象树）","slug":"对象模型-对象树","link":"#对象模型-对象树","children":[]}]}],"git":{"createdTime":1738732439000,"updatedTime":1738732439000,"contributors":[{"name":"Linc","username":"Linc","email":"762699299@qq.com","commits":1,"url":"https://github.com/Linc"}]},"readingTime":{"minutes":1.42,"words":425},"filePathRelative":"01. DesignAndDevelop/Develop/04. Project/Platform/Multi/QT（Cpp）/01. 简概/03. 基础知识点/03. 对象树和拥有权.md","localizedDate":"2025年2月5日","excerpt":"\\n<h1>目录</h1>\\n<h1>对象树和拥有权</h1>\\n<h2>对象模型（对象树）</h2>\\n<p>parent-child机制</p>\\n<ul>\\n<li>\\n<p>作用</p>\\n<ul>\\n<li>介绍Qt时提到一点：一定程度简化垃圾回收机制，就是这个 —— 对象树机制</li>\\n<li>这意味着类与类为包含关系时，被包含的类可以使用new方式声明而不用在析构中销毁</li>\\n</ul>\\n</li>\\n<li>\\n<p>简概</p>\\n<ul>\\n<li>Qt中创建对象时会提供一个Parent对象指针</li>\\n<li>注意，对象树不等于继承树</li>\\n</ul>\\n</li>\\n<li>\\n<p>原理</p>\\n<ul>\\n<li>\\n<p>当创建一个<code>QObject</code>对象时，其构造函数接受一个<code>QObject</code>指针作为参数，这个参数是<code>parent</code>，也就是<code>父对象指针</code>（不是父类）</p>\\n<ul>\\n<li>\\n<p>可以通过构造函数传入<code>父对象指针</code>，也可以后期通过<code>setParent()</code>函数修改<code>父对象指针</code>，一般为this</p>\\n</li>\\n<li>\\n<p>这个QObject对象会自动添加到<strong>父对象的<code>children()</code>列表</strong></p>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>当<code>父对象</code>析构时，这个列表中的所有对象也会被析构</p>\\n</li>\\n<li>\\n<p>这种机制在GUI程序设计中相当有用</p>\\n</li>\\n<li>\\n<p>即：<mark>不需要delete QObject对象及其后代类</mark></p>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>补充</p>\\n<ul>\\n<li>这里的设计可能有点反直觉：父对象指针为参，但目的是要调用*parent里面的addChildren()??方法来修改的是父对象中的children()列表</li>\\n<li>之所以这样设计\\n<ul>\\n<li>一是方便于为组件指定的父对象（如控件所属哪个窗口）</li>\\n<li>二是以便与在构造QObject对象时完成所有操作（而不是把QObject对象传入到包含它的类的方法参数里）</li>\\n<li>三是将children放在父对象中，当销毁父对象的时候不需要遍历所有对象，就能直接找到要销毁的子对象</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"01. DesignAndDevelop/Develop/04. Project/Platform/Multi/QT（Cpp）/01. 简概/03. 基础知识点/03. 对象树和拥有权.md","value":{"title":"03. 对象树和拥有权","path":"01. DesignAndDevelop/Develop/04. Project/Platform/Multi/QT（Cpp）/01. 简概/03. 基础知识点/03. 对象树和拥有权.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{r as comp,d as data};
