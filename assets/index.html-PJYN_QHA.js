import{_ as o,c as l,a as s,b as a,d as t,e as p,o as i,r as c}from"./app-D56eNcZZ.js";const r={},u={href:"https://imzlp.com/posts/6362/",target:"_blank",rel:"noopener noreferrer"},d={href:"https://img.imzlp.com/imgs/zlp/blog/posts/16643/",target:"_blank",rel:"noopener noreferrer"},k={href:"https://imzlp.com/posts/20425/",target:"_blank",rel:"noopener noreferrer"},m={href:"https://imzlp.com/posts/15049/",target:"_blank",rel:"noopener noreferrer"},v={href:"https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Classes/Specifiers",target:"_blank",rel:"noopener noreferrer"},g={href:"https://docs.unrealengine.com/en-US/ProgrammingAndScripting/GameplayArchitecture/Structs/Specifiers/index.html",target:"_blank",rel:"noopener noreferrer"},b={href:"https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Reference/Functions/Specifiers",target:"_blank",rel:"noopener noreferrer"},f={href:"https://docs.unrealengine.com/en-US/ProgrammingAndScripting/GameplayArchitecture/Properties/Specifiers/index.html",target:"_blank",rel:"noopener noreferrer"},U={href:"https://docs.unrealengine.com/en-US/ProgrammingAndScripting/GameplayArchitecture/Metadata/index.html",target:"_blank",rel:"noopener noreferrer"},E={href:"https://imzlp.com/posts/27615/",target:"_blank",rel:"noopener noreferrer"};function y(C,n){const e=c("ExternalLinkIcon");return i(),l("div",null,[n[14]||(n[14]=s("h1",{id:"readme",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#readme"},[s("span",null,"README")])],-1)),n[15]||(n[15]=s("p",null,"原文：https://ue5wiki.com/wiki/12624/",-1)),n[16]||(n[16]=s("h2",{id:"ue-反射实现分析-基础概念",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#ue-反射实现分析-基础概念"},[s("span",null,"UE 反射实现分析：基础概念")])],-1)),n[17]||(n[17]=s("p",null,[s("strong",null,"反射"),a("，是指程序在运行时进行自检的的能力，在编辑器的属性面板、序列化、GC 等方面非常有用。但是 C++ 语言本身不支持反射特性，UE 在 C++ 的语法基础上通过 UHT 实现了反射信息的生成，从而实现了运行时的反射的目的。")],-1)),n[18]||(n[18]=s("p",null,"在之前的文章中，有一些涉及到 UE 的构建系统和反射相关的内容。",-1)),n[19]||(n[19]=s("p",null,"涉及了 UE 的构建系统文章：",-1)),s("ul",null,[s("li",null,[s("a",u,[n[0]||(n[0]=a("Build flow of the Unreal Engine4 project")),t(e)])]),s("li",null,[s("a",d,[n[1]||(n[1]=a("UE4 Build System: Target and Module")),t(e)])]),s("li",null,[s("a",k,[n[2]||(n[2]=a("UEC++ 与标准 C++ 的区别与联系")),t(e)])])]),n[20]||(n[20]=s("p",null,"基于 UE 的反射机制来做一些奇淫巧技的文章：",-1)),s("ul",null,[s("li",null,[s("a",m,[n[3]||(n[3]=a("UE4：Hook UObject")),t(e)])])]),n[21]||(n[21]=p(`<p>UE 的反射实现是依赖于构建系统中 UHT 来执行代码生成的，本篇文章对 UE 的反射做一个基础概念介绍，后续会花几篇文章完整地介绍 UE 里反射的实现机制。</p><p>UE 的反射可以实现 Enum 的反射 (<code>UEnum</code>)、类反射(<code>UClass</code>)、结构反射(<code>UStruct</code>)、数据成员反射(<code>UProperty</code>/<code>FProperty</code>)、成员函数反射(<code>UFunction</code>)，可以在运行时访问到它们，其实反射被称作 <strong>属性系统</strong> 应该更合适。</p><p>可以根据这些反射信息来获取它们的类型信息，本篇文章以类反射为例子介绍一下 UE 的反射。</p><p>如以下纯 C++ 代码：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">ClassRef</span>  
<span class="token punctuation">{</span>  
<span class="token keyword">public</span><span class="token operator">:</span>  
    int32 ival <span class="token operator">=</span> <span class="token number">666</span><span class="token punctuation">;</span>  
    <span class="token keyword">bool</span> <span class="token function">func</span><span class="token punctuation">(</span>int32 InIval<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>想要在运行时获取 <code>ClassRef</code> 类有哪些数据成员、函数，要如何操作？</p><p>C++ 原生并没有提供这样的能力，相同的需求在 UE 中创建的类是以下形式：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once  </span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;CoreMinimal.h&quot;</span>  </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;RefObject.generated.h&quot;</span>  </span>
  
<span class="token function">UCLASS</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  
<span class="token keyword">class</span> <span class="token class-name">REF_API</span> URefObject <span class="token operator">:</span> <span class="token keyword">public</span> UObject  
<span class="token punctuation">{</span>  
	<span class="token function">GENERATED_BODY</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  
<span class="token keyword">public</span><span class="token operator">:</span>  
	<span class="token function">UPROPERTY</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  
	int32 ival <span class="token operator">=</span> <span class="token number">666</span><span class="token punctuation">;</span>  
	  
	<span class="token function">UFUNCTION</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  
	<span class="token keyword">bool</span> <span class="token function">func</span><span class="token punctuation">(</span>int32 InIval<span class="token punctuation">)</span>  
	<span class="token punctuation">{</span>  
    	<span class="token function">UE_LOG</span><span class="token punctuation">(</span>LogTemp<span class="token punctuation">,</span>Log<span class="token punctuation">,</span><span class="token function">TEXT</span><span class="token punctuation">(</span><span class="token string">&quot;Function func: %d&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>InIval<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    	<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  
	<span class="token punctuation">}</span>  
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中关键需要注意的点：</p><ol><li><code>RefObject.generated.h</code>文件</li><li>UCLASS 标记</li><li>GENERATED_BODY 标记</li><li>UPROPERTY 标记</li><li>UFUNCTION 标记</li></ol><p>本文不对它们的具体含义做过多的介绍，后续的文章会做详细的分析。</p><p><code>UCLASS</code>/<code>USTRUCT</code>/<code>UFUNCTION</code>/<code>UPROPERTY</code>等可以在 <code>()</code> 中添加很多的标记值以及 meta 参数，用于指导 UHT 来生成对应的反射代码，它们支持的参数可以在 UE 的文档中查看：</p>`,12)),s("ul",null,[s("li",null,[s("a",v,[n[4]||(n[4]=a("Class Specifiers")),t(e)])]),s("li",null,[s("a",g,[n[5]||(n[5]=a("Struct Specifiers")),t(e)])]),s("li",null,[s("a",b,[n[6]||(n[6]=a("Function Specifiers")),t(e)])]),s("li",null,[s("a",f,[n[7]||(n[7]=a("Property Specifiers")),t(e)])]),s("li",null,[s("a",U,[n[8]||(n[8]=a("Metadata Specifiers")),t(e)])])]),n[22]||(n[22]=p(`<p>这种通过添加的 <strong>代码标记</strong> 来告诉 UE 的构建系统，由 UHT 来生成反射的代码，反射的代码保存在 <code>gen.cpp</code> 中，注意这些反射标记 <strong>只是</strong> 用来告诉 UHT 来生成代码的，在经过 C++ 的预处理阶段后它们大多都是空宏（有些是真的 C++ 宏），这也导致 UE 的反射标记有一个缺点：无法使用 C++ 的宏来包裹 UE 的反射标记，因为它们先于 <strong>预处理</strong> 执行。</p><blockquote><p>而且，UHT 只是简单粗暴的关键字匹配硬扫描，限制很大。</p></blockquote><p>对于继承自 UObject 的类而言，它的反射信息被创建出了一个 UClass 对象，可以通过这个对象在运行时获取对象类型的信息。并且，类内部的 <strong>反射数据成员</strong> 和<strong>反射成员函数</strong> ，都会给生成对应的<code>FProperty</code> 和<code>UFunction</code>对象，用来运行时访问到它们。</p><p>UClass 的继承关系：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>UObjectBase
  UObjectBaseUtility
    UObject
      UField
        UStruct
          UClass
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>针对继承自 UObject 的类，可以通过 <code>GetClass()</code> 来获取 UClass 实例，但是如果想直接获取某个类型的 UClass，则可以通过 <code>StaticClass&lt;UObject&gt;</code> 或者 <code>UObject::StaticClass()</code> 来获取。</p><p>UClass 中记录这类的继承关系、实现的接口、各种 Flag 等等，具体可以直接查阅 UClass 的类定义，通过它可以访问到该 UObject 的 C++ 类型中的信息。</p><p>而且，在运行时可以通过 <code>TFieldIterator</code> 来遍历 UClass 中的反射属性：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token class-name">URefObject</span><span class="token double-colon punctuation">::</span><span class="token function">URefObject</span><span class="token punctuation">(</span><span class="token keyword">const</span> FObjectInitializer<span class="token operator">&amp;</span> Initializer<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">Super</span><span class="token punctuation">(</span>Initializer<span class="token punctuation">)</span>  
<span class="token punctuation">{</span>  
    <span class="token keyword">for</span><span class="token punctuation">(</span>TFieldIterator<span class="token operator">&lt;</span>FProperty<span class="token operator">&gt;</span> <span class="token function">PropertyIter</span><span class="token punctuation">(</span><span class="token function">GetClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>PropertyIter<span class="token punctuation">;</span><span class="token operator">++</span>PropertyIter<span class="token punctuation">)</span>  
    <span class="token punctuation">{</span>  
        FProperty<span class="token operator">*</span> PropertyIns <span class="token operator">=</span> <span class="token operator">*</span>PropertyIter<span class="token punctuation">;</span>  
        <span class="token function">UE_LOG</span><span class="token punctuation">(</span>LogTemp<span class="token punctuation">,</span>Log<span class="token punctuation">,</span><span class="token function">TEXT</span><span class="token punctuation">(</span><span class="token string">&quot;Property Name: %s&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">*</span>PropertyIns<span class="token operator">-&gt;</span><span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token keyword">for</span><span class="token punctuation">(</span>TFieldIterator<span class="token operator">&lt;</span>UFunction<span class="token operator">&gt;</span> <span class="token function">PropertyIter</span><span class="token punctuation">(</span><span class="token function">GetClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>PropertyIter<span class="token punctuation">;</span><span class="token operator">++</span>PropertyIter<span class="token punctuation">)</span>  
    <span class="token punctuation">{</span>  
        UFunction<span class="token operator">*</span> PropertyIns <span class="token operator">=</span> <span class="token operator">*</span>PropertyIter<span class="token punctuation">;</span>  
        <span class="token function">UE_LOG</span><span class="token punctuation">(</span>LogTemp<span class="token punctuation">,</span>Log<span class="token punctuation">,</span><span class="token function">TEXT</span><span class="token punctuation">(</span><span class="token string">&quot;Function Name: %s&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">*</span>PropertyIns<span class="token operator">-&gt;</span><span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行结果：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>LogTemp: Property Name: ival  
LogTemp: Function Name: func  
LogTemp: Function Name: ExecuteUbergraph
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么如何通过属性和成员函数的反射信息来访问到它们呢？</p><h3 id="访问数据成员" tabindex="-1"><a class="header-anchor" href="#访问数据成员"><span>访问数据成员</span></a></h3>`,13)),s("p",null,[n[10]||(n[10]=a("首先，在 C++ 中类内存布局中是编译时固定的，所以一个数据成员在类中的位置是固定的，C++ 有一个特性叫做 ")),n[11]||(n[11]=s("strong",null,"指向类成员的指针",-1)),n[12]||(n[12]=a("，本质上就是描述了当前数据成员在类布局内的偏移值。这部分内容在我之前的文章中有介绍：")),s("a",E,[n[9]||(n[9]=a("C++ 中指向类成员的指针并非指针")),t(e)]),n[13]||(n[13]=a("。"))]),n[23]||(n[23]=p(`<p>FProperty 做的就是类似的事情，记录反射数据成员的类内偏移信息，UE 中的实现也是通过 <strong>指向成员的指针</strong> 来实现的，这部分后面的文章会着重介绍，这里只介绍使用方法。</p><p>通过 FProperty 获取对象中值的方式，需要通过调用 <code>FProperty</code> 的<code>ContainerPtrToValuePtr</code>来实现：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">for</span><span class="token punctuation">(</span>TFieldIterator<span class="token operator">&lt;</span>FProperty<span class="token operator">&gt;</span> <span class="token function">PropertyIter</span><span class="token punctuation">(</span><span class="token function">GetClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>PropertyIter<span class="token punctuation">;</span><span class="token operator">++</span>PropertyIter<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    FProperty<span class="token operator">*</span> PropertyIns <span class="token operator">=</span> <span class="token operator">*</span>PropertyIter<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>PropertyIns<span class="token operator">-&gt;</span><span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Equals</span><span class="token punctuation">(</span><span class="token function">TEXT</span><span class="token punctuation">(</span><span class="token string">&quot;ival&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        int32<span class="token operator">*</span> i32 <span class="token operator">=</span> PropertyIns<span class="token operator">-&gt;</span><span class="token generic-function"><span class="token function">ContainerPtrToValuePtr</span><span class="token generic class-name"><span class="token operator">&lt;</span>int32<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            
        <span class="token function">UE_LOG</span><span class="token punctuation">(</span>LogTemp<span class="token punctuation">,</span>Log<span class="token punctuation">,</span><span class="token function">TEXT</span><span class="token punctuation">(</span><span class="token string">&quot;Property %s value is %d&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">*</span>PropertyIns<span class="token operator">-&gt;</span><span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">*</span>i32<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://img.imzlp.com/imgs/zlp/blog/posts/12624/fproperty-get-data-member-value.webp" alt="" loading="lazy"></p><p>这样就实现了通过 FProperty 来访问数据成员的目的，因为获取到的是数据成员的指针，所以修改它也是没问题的。</p><h3 id="访问成员函数" tabindex="-1"><a class="header-anchor" href="#访问成员函数"><span>访问成员函数</span></a></h3><p>通过反射访问函数则要复杂一些，因为要处理参数传递和返回值的接收问题。</p><p>前面已经提到了，UE 的反射成员函数会生成 <code>UFunction</code> 对象，函数的反射信息就在它里面，因为 UFUNCTION 是只能标记在继承自 UObject 的类中，所以 UE 封装了一套基于 UObject 的反射函数调用方式：</p><p>……</p><p>……</p><p>……</p>`,11))])}const P=o(r,[["render",y],["__file","index.html.vue"]]),T=JSON.parse('{"path":"/01.%20DesignAndDevelop/Develop/04.%20Project/Platform/SoftCode/Game/UE4%EF%BC%88%E8%93%9D%E5%9B%BE%20C__%EF%BC%89/%E3%80%8Aue5wiki%E3%80%8B/%E5%8F%8D%E5%B0%84/","title":"README","lang":"zh-CN","frontmatter":{"description":"README 原文：https://ue5wiki.com/wiki/12624/ UE 反射实现分析：基础概念 反射，是指程序在运行时进行自检的的能力，在编辑器的属性面板、序列化、GC 等方面非常有用。但是 C++ 语言本身不支持反射特性，UE 在 C++ 的语法基础上通过 UHT 实现了反射信息的生成，从而实现了运行时的反射的目的。 在之前的文章中...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/04.%20Project/Platform/SoftCode/Game/UE4%EF%BC%88%E8%93%9D%E5%9B%BE%20C__%EF%BC%89/%E3%80%8Aue5wiki%E3%80%8B/%E5%8F%8D%E5%B0%84/"}],["meta",{"property":"og:site_name","content":"MdNote_Public"}],["meta",{"property":"og:title","content":"README"}],["meta",{"property":"og:description","content":"README 原文：https://ue5wiki.com/wiki/12624/ UE 反射实现分析：基础概念 反射，是指程序在运行时进行自检的的能力，在编辑器的属性面板、序列化、GC 等方面非常有用。但是 C++ 语言本身不支持反射特性，UE 在 C++ 的语法基础上通过 UHT 实现了反射信息的生成，从而实现了运行时的反射的目的。 在之前的文章中..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://img.imzlp.com/imgs/zlp/blog/posts/12624/fproperty-get-data-member-value.webp"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-01-26T15:46:06.000Z"}],["meta",{"property":"article:author","content":"LincDocs"}],["meta",{"property":"article:modified_time","content":"2025-01-26T15:46:06.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"README\\",\\"image\\":[\\"https://img.imzlp.com/imgs/zlp/blog/posts/12624/fproperty-get-data-member-value.webp\\"],\\"dateModified\\":\\"2025-01-26T15:46:06.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/MdNote_Public/\\"}]}"]]},"headers":[{"level":1,"title":"README","slug":"readme","link":"#readme","children":[{"level":2,"title":"UE 反射实现分析：基础概念","slug":"ue-反射实现分析-基础概念","link":"#ue-反射实现分析-基础概念","children":[{"level":3,"title":"访问数据成员","slug":"访问数据成员","link":"#访问数据成员","children":[]},{"level":3,"title":"访问成员函数","slug":"访问成员函数","link":"#访问成员函数","children":[]}]}]}],"git":{"createdTime":1737906366000,"updatedTime":1737906366000,"contributors":[{"name":"Linc","email":"762699299@qq.com","commits":1}]},"readingTime":{"minutes":4.9,"words":1470},"filePathRelative":"01. DesignAndDevelop/Develop/04. Project/Platform/SoftCode/Game/UE4（蓝图 C++）/《ue5wiki》/反射/README.md","localizedDate":"2025年1月26日","excerpt":"\\n<p>原文：https://ue5wiki.com/wiki/12624/</p>\\n<h2>UE 反射实现分析：基础概念</h2>\\n<p><strong>反射</strong>，是指程序在运行时进行自检的的能力，在编辑器的属性面板、序列化、GC 等方面非常有用。但是 C++ 语言本身不支持反射特性，UE 在 C++ 的语法基础上通过 UHT 实现了反射信息的生成，从而实现了运行时的反射的目的。</p>\\n<p>在之前的文章中，有一些涉及到 UE 的构建系统和反射相关的内容。</p>\\n<p>涉及了 UE 的构建系统文章：</p>\\n<ul>\\n<li><a href=\\"https://imzlp.com/posts/6362/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">Build flow of the Unreal Engine4 project</a></li>\\n<li><a href=\\"https://img.imzlp.com/imgs/zlp/blog/posts/16643/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">UE4 Build System: Target and Module</a></li>\\n<li><a href=\\"https://imzlp.com/posts/20425/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">UEC++ 与标准 C++ 的区别与联系</a></li>\\n</ul>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"01. DesignAndDevelop/Develop/04. Project/Platform/SoftCode/Game/UE4（蓝图 C++）/《ue5wiki》/反射/README.md","value":{"title":"《ue5wiki》/","path":"01. DesignAndDevelop/Develop/04. Project/Platform/SoftCode/Game/UE4（蓝图 C++）/《ue5wiki》/反射/README.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{P as comp,T as data};
