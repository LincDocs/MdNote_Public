import{_ as t,c as e,f as n,a as s,d as l,r as h,o as p}from"./app-CfmvdVmg.js";const r="/MdNote_Public/assets/20210319000028665-BTc30K0m.png",k={};function d(o,i){const a=h("Mermaid");return p(),e("div",null,[i[2]||(i[2]=n(`<h1 id="c" tabindex="-1"><a class="header-anchor" href="#c"><span>C++</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="oop-vs-gp" tabindex="-1"><a class="header-anchor" href="#oop-vs-gp"><span>OOP vs GP</span></a></h1><h2 id="比较" tabindex="-1"><a class="header-anchor" href="#比较"><span>比较</span></a></h2><h3 id="数据和方法的区别" tabindex="-1"><a class="header-anchor" href="#数据和方法的区别"><span>数据和方法的区别</span></a></h3><ul><li><p>OOP的目的是将<strong>数据</strong>和<strong>方法</strong>绑定在一起</p><ul><li>例如对<code>std::list</code>容器进行排序要调用<code>std::list::sort</code>方法</li></ul></li><li><p>GP的目的是将<strong>数据</strong>和<strong>方法</strong>分离开来</p><ul><li>例如对<code>std::vector</code>容器进行排序要调用<code>std::sort</code>方法</li></ul></li></ul><h3 id="oop-object-oriented-programming" tabindex="-1"><a class="header-anchor" href="#oop-object-oriented-programming"><span>OOP（Object-Oriented Programming）</span></a></h3><p><mark>OOP企图将 datas 和 methods 关联在一起</mark></p><p>类定义</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">/* list类 */</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">template</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> T</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Alloc</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">alloc&gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> list</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    //...</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> sort</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Q：引申问题：为什么list不能用<code>::sort</code>排序</li><li>A：<code>std::sort</code>的实现使用了随机访问，而list不能随机访问，不能用<code>::sort</code>排序</li></ul><h3 id="gp-generic-programming" tabindex="-1"><a class="header-anchor" href="#gp-generic-programming"><span>GP（Generic Programming）</span></a></h3><p>标准库使用GP编程</p><p><mark>GP却是将 datas 和 methods 分开来</mark></p><p>类定义（这两个容器都提供 RandomAccessIterator 随机遍历器）</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">/* vector类 */</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">template</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> T</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Alloc</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">alloc&gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> vector</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    //...</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    //（没有sort方法）</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">/* deque类 */</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">template</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> T</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Alloc</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">alloc, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">size_t</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> BufSiz</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> deque</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    //...</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    //（没有sort方法）</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>算法 Algorithms（排序）</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">template</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">typename</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> _RandomAccessIterator</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">inline</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> sort</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">_RandomAccessIterator</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> __first</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">_RandomAccessIterator</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> __last</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // std::__sort(__first, __last, __gnu_cxx::__ops::__iter_less_iter());</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">template</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">typename</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> _RandomAccessIterator</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">typename</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> _Compare</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">inline</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> sort</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">_RandomAccessIterator</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> __first</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">_RandomAccessIterator</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> __last</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">_Compare</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> __comp</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (__first </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">!=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> __last) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        std::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">__introsort_loop</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(__first, __last,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                              std::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">__lg</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(__last </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> __first) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">		// 对iterator进行减运算,std::list的iterator没有实现该运算</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                              __comp);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        std::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">__final_insertion_sort</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(__first, __last, __comp);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="gp-补充" tabindex="-1"><a class="header-anchor" href="#gp-补充"><span>GP 补充</span></a></h2><h3 id="好处" tabindex="-1"><a class="header-anchor" href="#好处"><span>好处</span></a></h3><ul><li>Containers 和 Algorithms 团队可以各自开发，其间以Iterator沟通即可</li><li>Algorithms 通过 Iterator 确定操作范围，并通过Iterator取用Container元素</li></ul><h3 id="组件结构" tabindex="-1"><a class="header-anchor" href="#组件结构"><span>组件结构</span></a></h3>`,22)),s("ul",null,[s("li",null,[i[0]||(i[0]=s("p",null,"图示",-1)),l(a,{id:"mermaid-106",code:"eJxLL0osyFAIceJ6snv/0/a9z6ZuiHcrzUsuyS8qjn+yrzs5P7cALqOra8f1fN30Z5unxjvmpOcXZZZk5IJVFecXlTybthMooav3Yv/aJ7sXP525It6zJLUoEWSQnh5Q49N1O0GCzvl5JYmZeakQ48tSQTY965iWklpYmgpRwgUAR9tM7w=="})]),s("li",null,[i[1]||(i[1]=s("p",null,"复习下六组件结构",-1)),l(a,{id:"mermaid-112",code:"eJxLL0osyFDwCeIqLk2CsF/sX/tk9+KnM1e8bGh62doLZHBxwsW4UvNSEEqfrtuJqg4igKroye79T9v3Ppu6AUkdXAys9GlHG0RCV9cOagJcAVDo+brpzzZP1dXTtYM7A8SBqgQAhp9q3Q=="})])]),i[3]||(i[3]=n('<h2 id="操作符重载-vs-模板-泛化、全特化、偏特化" tabindex="-1"><a class="header-anchor" href="#操作符重载-vs-模板-泛化、全特化、偏特化"><span>操作符重载 vs 模板（泛化、全特化、偏特化）</span></a></h2><p><img src="'+r+'" alt="请添加图片描述" loading="lazy"></p><h3 id="operator-overloading-操作符重载" tabindex="-1"><a class="header-anchor" href="#operator-overloading-操作符重载"><span>Operator Overloading 操作符重载</span></a></h3><p>略</p><h3 id="templates-模板" tabindex="-1"><a class="header-anchor" href="#templates-模板"><span>Templates 模板</span></a></h3><p>略</p>',6))])}const g=t(k,[["render",d],["__file","08. OOP vs GP.html.vue"]]),A=JSON.parse('{"path":"/01.%20DesignAndDevelop/Develop/01.%20Language/C__/07.%20%E6%A8%A1%E5%9D%97%E5%BA%93/STL/08.%20OOP%20vs%20GP.html","title":"C++","lang":"zh-CN","frontmatter":{"description":"C++ 目录 OOP vs GP 比较 数据和方法的区别 OOP的目的是将数据和方法绑定在一起 例如对std::list容器进行排序要调用std::list::sort方法 GP的目的是将数据和方法分离开来 例如对std::vector容器进行排序要调用std::sort方法 OOP（Object-Oriented Programming） OOP企图...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/01.%20Language/C__/07.%20%E6%A8%A1%E5%9D%97%E5%BA%93/STL/08.%20OOP%20vs%20GP.html"}],["meta",{"property":"og:site_name","content":"MdNote_Public"}],["meta",{"property":"og:title","content":"C++"}],["meta",{"property":"og:description","content":"C++ 目录 OOP vs GP 比较 数据和方法的区别 OOP的目的是将数据和方法绑定在一起 例如对std::list容器进行排序要调用std::list::sort方法 GP的目的是将数据和方法分离开来 例如对std::vector容器进行排序要调用std::sort方法 OOP（Object-Oriented Programming） OOP企图..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-05T05:13:59.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-05T05:13:59.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"C++\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-05T05:13:59.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/MdNote_Public/\\"}]}"]]},"headers":[{"level":1,"title":"C++","slug":"c","link":"#c","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"OOP vs GP","slug":"oop-vs-gp","link":"#oop-vs-gp","children":[{"level":2,"title":"比较","slug":"比较","link":"#比较","children":[{"level":3,"title":"数据和方法的区别","slug":"数据和方法的区别","link":"#数据和方法的区别","children":[]},{"level":3,"title":"OOP（Object-Oriented Programming）","slug":"oop-object-oriented-programming","link":"#oop-object-oriented-programming","children":[]},{"level":3,"title":"GP（Generic Programming）","slug":"gp-generic-programming","link":"#gp-generic-programming","children":[]}]},{"level":2,"title":"GP 补充","slug":"gp-补充","link":"#gp-补充","children":[{"level":3,"title":"好处","slug":"好处","link":"#好处","children":[]},{"level":3,"title":"组件结构","slug":"组件结构","link":"#组件结构","children":[]}]},{"level":2,"title":"操作符重载 vs 模板（泛化、全特化、偏特化）","slug":"操作符重载-vs-模板-泛化、全特化、偏特化","link":"#操作符重载-vs-模板-泛化、全特化、偏特化","children":[{"level":3,"title":"Operator Overloading 操作符重载","slug":"operator-overloading-操作符重载","link":"#operator-overloading-操作符重载","children":[]},{"level":3,"title":"Templates 模板","slug":"templates-模板","link":"#templates-模板","children":[]}]}]}],"git":{"createdTime":1738732439000,"updatedTime":1738732439000,"contributors":[{"name":"Linc","username":"Linc","email":"762699299@qq.com","commits":1,"url":"https://github.com/Linc"}]},"readingTime":{"minutes":1.65,"words":496},"filePathRelative":"01. DesignAndDevelop/Develop/01. Language/C++/07. 模块库/STL/08. OOP vs GP.md","localizedDate":"2025年2月5日","excerpt":"\\n<h1>目录</h1>\\n<h1>OOP vs GP</h1>\\n<h2>比较</h2>\\n<h3>数据和方法的区别</h3>\\n<ul>\\n<li>\\n<p>OOP的目的是将<strong>数据</strong>和<strong>方法</strong>绑定在一起</p>\\n<ul>\\n<li>例如对<code>std::list</code>容器进行排序要调用<code>std::list::sort</code>方法</li>\\n</ul>\\n</li>\\n<li>\\n<p>GP的目的是将<strong>数据</strong>和<strong>方法</strong>分离开来</p>\\n<ul>\\n<li>例如对<code>std::vector</code>容器进行排序要调用<code>std::sort</code>方法</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"01. DesignAndDevelop/Develop/01. Language/C++/07. 模块库/STL/08. OOP vs GP.md","value":{"title":"08. OOP vs GP","path":"01. DesignAndDevelop/Develop/01. Language/C++/07. 模块库/STL/08. OOP vs GP.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{g as comp,A as data};
