import{_ as s,c as a,f as n,o as l}from"./app-Cy4VlaP7.js";const t={};function e(h,i){return l(),a("div",null,i[0]||(i[0]=[n(`<h1 id="gc-垃圾回收" tabindex="-1"><a class="header-anchor" href="#gc-垃圾回收"><span>GC 垃圾回收</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="python的垃圾回收" tabindex="-1"><a class="header-anchor" href="#python的垃圾回收"><span>Python的垃圾回收</span></a></h1><p>参考：</p><ul><li><a href="https://www.cnblogs.com/chickenwrap/p/10473124.html" target="_blank" rel="noopener noreferrer">【博客园】Python垃圾回收机制（转）</a></li></ul><h2 id="简概-garbage-collection-gc" tabindex="-1"><a class="header-anchor" href="#简概-garbage-collection-gc"><span>简概 Garbage collection(GC)</span></a></h2><p>现在的高级语言如java，c#等，都采用了垃圾收集机制，而不再是c，c++里用户自己管理维护内存的方式。 自己管理内存极其自由，可以任意申请内存，但如同一把<strong>双刃剑</strong>，为大量<strong>内存泄露，悬空指针</strong>等bug埋下隐患。</p><p>对于一个字符串、列表、类甚至数值都是对象，且定位简单易用的语言，自然不会让用户去处理如何分配回收内存的问题。</p><p>python里也同java一样采用了垃圾收集机制，不过不一样的是: python采用的是<code>引用计数</code>机制为主，<code>标记-清除</code>和<code>分代收集</code>两种机制为辅的策略</p><h2 id="引用计数机制" tabindex="-1"><a class="header-anchor" href="#引用计数机制"><span>引用计数机制</span></a></h2><p>python里每一个东西都是对象，它们的核心就是一个结构体：<code>PyObject</code></p><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">typedef struct_object {</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">	int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ob_refcnt;				</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 引用计数。当一个对象有新的引用时。它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">	struct_typeobject </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">ob_type;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">} PyObject;  					</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># PyObject是每个对象必有的内容</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方法</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#define</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Py_INCREF</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">op</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">						// 增加计数</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">	((op)-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ob_refcnt</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#define</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Py_DECREF</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">op</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  						// 减少计数</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">--</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(op)-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ob_refcnt</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> !=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\\</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    	; </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\\</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    else</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> \\</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    	__Py_Dealloc</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">((PyObject </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)(op))</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">		// 引用计数为0时删除对象，对象生命就结束了</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="引用计数机制的优点" tabindex="-1"><a class="header-anchor" href="#引用计数机制的优点"><span>引用计数机制的优点</span></a></h3><ol><li>简单</li><li>实时性：一旦没有引用，内存就直接释放了。不用像其他机制等到特定时机。实时性还带来一个好处：处理回收内存的时间分摊到了平时。</li></ol><h3 id="引用计数机制的缺点" tabindex="-1"><a class="header-anchor" href="#引用计数机制的缺点"><span>引用计数机制的缺点</span></a></h3><ol><li><p>维护引用计数消耗资源</p></li><li><p>循环引用</p><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">list1 </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> []</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">list2 </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> []</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">list1.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">append</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(list2)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">list2.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">append</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(list1)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>list1与list2相互引用，即便不存在其他对象对它们的引用，list1与list2的引用计数也仍然为1，<strong>所占用的内存永远无法被回收</strong>，这将是致命的。</p><p>对于如今的强大硬件，缺点1尚可接受，但是循环引用导致内存泄露，注定python还将引入新的回收机制。(标记清除和分代收集)</p></li></ol><h2 id="画说-ruby-与-python-垃圾回收" tabindex="-1"><a class="header-anchor" href="#画说-ruby-与-python-垃圾回收"><span>画说 Ruby 与 Python 垃圾回收</span></a></h2><h2 id="使用gc模块" tabindex="-1"><a class="header-anchor" href="#使用gc模块"><span>使用GC模块</span></a></h2><h3 id="打印类的实例" tabindex="-1"><a class="header-anchor" href="#打印类的实例"><span>打印类的实例</span></a></h3><p>参考：<a href="https://blog.csdn.net/weixin_39951419/article/details/113991530" target="_blank" rel="noopener noreferrer">【CSDN】python输出类的实例_打印类的所有实例</a></p><h4 id="方法一-利用静态成员手动计数" tabindex="-1"><a class="header-anchor" href="#方法一-利用静态成员手动计数"><span>方法一，利用静态成员手动计数</span></a></h4><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">count </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">def</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> __init__</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">():</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">    type</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">self</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">).count </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">def</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> __del__</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-light-font-style:inherit;--shiki-dark:#E5C07B;--shiki-dark-font-style:italic;">self</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">):</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">    type</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">self</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">).count </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="方法二-使用gc类" tabindex="-1"><a class="header-anchor" href="#方法二-使用gc类"><span>方法二，使用GC类</span></a></h4><p>常用方法（参考官网文档：https://docs.python.org/zh-cn/3/library/gc.html?highlight=gc#module-gc）</p><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">gc.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">enable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()			</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 启用自动垃圾回收</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">gc.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">disable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()		</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 停用自动垃圾回收</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">gc.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">isenabled</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()		</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 返回是否启用了自动回收</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">gc.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">get_objects</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">generation</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">None</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)		</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 返回一个收集器所跟踪的所有对象的列表</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">gc.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">get_count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()						</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 将当前回收计数以形为(count0, count1, count2)的元组返回</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">gc.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">is_tracked</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(obj)	</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 当对象正在被垃圾回收器监控时返回 True。一般来说，原子类的实例不会被监控，原子类（如容器、用户自定义的对象）会被监控</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">gc.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">is_finalized</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(obj)</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 如果给定对象已被垃圾回收器终结则返回 True，否则返回 False</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>应用</p><ul><li>用来检查漏析构对象很方便</li><li>发现漏析构对象用，可以通过<code>print(gc.get_referents(obj))</code>发现循环引用、remove属性不彻底的问题</li></ul><p>举例</p><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> gc</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> obj </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">in</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> gc.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">get_objects</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">():</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> isinstance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(obj, Node):</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">        print</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;GC_Node&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, obj, gc.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">isenabled</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(), gc.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">get_referents</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(obj))</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    elif</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> isinstance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(obj, Edge):</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">        print</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;GC_Edge&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, obj)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    elif</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> isinstance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(obj, Socket):</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">        print</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;GC_Socket&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, obj)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="手动析构问题-与c-不同" tabindex="-1"><a class="header-anchor" href="#手动析构问题-与c-不同"><span>手动析构问题（与C++不同）</span></a></h2><p>参考：http://c.biancheng.net/view/2371.html</p><ul><li><p>Python中</p><ul><li>不要误认为，只要为该实例对象调用 <code>__del__()</code> 方法，该对象所占用的内存空间就会被释放。</li><li>举个例子：</li></ul><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> CLanguage</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    def</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> __init__</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-light-font-style:inherit;--shiki-dark:#E5C07B;--shiki-dark-font-style:italic;">self</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">):</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">        print</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;调用 __init__() 方法构造对象&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    def</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> __del__</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-light-font-style:inherit;--shiki-dark:#E5C07B;--shiki-dark-font-style:italic;">self</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">):</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">        print</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;调用__del__() 销毁对象，释放其空间&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">clangs </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;"> CLanguage</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">#添加一个引用clangs对象的实例对象</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">cl </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> clangs</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">del</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> clangs  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 手动析构失败。对象没被析构，cl也不会变成空悬指针</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">print</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;***********&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;&quot;&quot; 程序运行结果为：</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">调用 __init__() 方法构造对象</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">***********</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">调用__del__() 销毁对象，释放其空间</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;&quot;&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>C++中</p><ul><li>调用析构函数、对象所占用的内存空间必然会被释放。上面的例子中，cl会变成 <code>空悬指针</code></li></ul></li></ul>`,34)]))}const p=s(t,[["render",e],["__file","Python的垃圾回收.html.vue"]]),d=JSON.parse('{"path":"/01.%20DesignAndDevelop/Develop/03.%20Tools/04.%20%E4%BC%98%E5%8C%96%E5%B1%82/GC%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Python%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.html","title":"GC 垃圾回收","lang":"zh-CN","frontmatter":{"description":"GC 垃圾回收 目录 Python的垃圾回收 参考： 【博客园】Python垃圾回收机制（转） 简概 Garbage collection(GC) 现在的高级语言如java，c#等，都采用了垃圾收集机制，而不再是c，c++里用户自己管理维护内存的方式。 自己管理内存极其自由，可以任意申请内存，但如同一把双刃剑，为大量内存泄露，悬空指针等bug埋下隐患。...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/03.%20Tools/04.%20%E4%BC%98%E5%8C%96%E5%B1%82/GC%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Python%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.html"}],["meta",{"property":"og:site_name","content":"MdNote_Public"}],["meta",{"property":"og:title","content":"GC 垃圾回收"}],["meta",{"property":"og:description","content":"GC 垃圾回收 目录 Python的垃圾回收 参考： 【博客园】Python垃圾回收机制（转） 简概 Garbage collection(GC) 现在的高级语言如java，c#等，都采用了垃圾收集机制，而不再是c，c++里用户自己管理维护内存的方式。 自己管理内存极其自由，可以任意申请内存，但如同一把双刃剑，为大量内存泄露，悬空指针等bug埋下隐患。..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-03T08:19:47.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-03T08:19:47.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"GC 垃圾回收\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-03T08:19:47.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/MdNote_Public/\\"}]}"]]},"headers":[{"level":1,"title":"GC 垃圾回收","slug":"gc-垃圾回收","link":"#gc-垃圾回收","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"Python的垃圾回收","slug":"python的垃圾回收","link":"#python的垃圾回收","children":[{"level":2,"title":"简概 Garbage collection(GC)","slug":"简概-garbage-collection-gc","link":"#简概-garbage-collection-gc","children":[]},{"level":2,"title":"引用计数机制","slug":"引用计数机制","link":"#引用计数机制","children":[{"level":3,"title":"引用计数机制的优点","slug":"引用计数机制的优点","link":"#引用计数机制的优点","children":[]},{"level":3,"title":"引用计数机制的缺点","slug":"引用计数机制的缺点","link":"#引用计数机制的缺点","children":[]}]},{"level":2,"title":"画说 Ruby 与 Python 垃圾回收","slug":"画说-ruby-与-python-垃圾回收","link":"#画说-ruby-与-python-垃圾回收","children":[]},{"level":2,"title":"使用GC模块","slug":"使用gc模块","link":"#使用gc模块","children":[{"level":3,"title":"打印类的实例","slug":"打印类的实例","link":"#打印类的实例","children":[{"level":4,"title":"方法一，利用静态成员手动计数","slug":"方法一-利用静态成员手动计数","link":"#方法一-利用静态成员手动计数","children":[]},{"level":4,"title":"方法二，使用GC类","slug":"方法二-使用gc类","link":"#方法二-使用gc类","children":[]}]}]},{"level":2,"title":"手动析构问题（与C++不同）","slug":"手动析构问题-与c-不同","link":"#手动析构问题-与c-不同","children":[]}]}],"git":{"createdTime":1738570787000,"updatedTime":1738570787000,"contributors":[{"name":"Linc","username":"Linc","email":"762699299@qq.com","commits":1,"url":"https://github.com/Linc"}]},"readingTime":{"minutes":3.59,"words":1076},"filePathRelative":"01. DesignAndDevelop/Develop/03. Tools/04. 优化层/GC 垃圾回收/Python的垃圾回收.md","localizedDate":"2025年2月3日","excerpt":"\\n<h1>目录</h1>\\n<h1>Python的垃圾回收</h1>\\n<p>参考：</p>\\n<ul>\\n<li><a href=\\"https://www.cnblogs.com/chickenwrap/p/10473124.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">【博客园】Python垃圾回收机制（转）</a></li>\\n</ul>\\n<h2>简概 Garbage collection(GC)</h2>\\n<p>现在的高级语言如java，c#等，都采用了垃圾收集机制，而不再是c，c++里用户自己管理维护内存的方式。\\n自己管理内存极其自由，可以任意申请内存，但如同一把<strong>双刃剑</strong>，为大量<strong>内存泄露，悬空指针</strong>等bug埋下隐患。</p>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"01. DesignAndDevelop/Develop/03. Tools/04. 优化层/GC 垃圾回收/Python的垃圾回收.md","value":{"title":"Python的垃圾回收","path":"01. DesignAndDevelop/Develop/03. Tools/04. 优化层/GC 垃圾回收/Python的垃圾回收.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{p as comp,d as data};
