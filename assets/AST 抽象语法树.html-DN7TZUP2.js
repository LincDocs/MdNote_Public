import{_ as o,c as l,e as p,a as s,b as a,d as e,o as i,r}from"./app-D56eNcZZ.js";const u={},c={href:"https://www.jianshu.com/p/6fa90ee14d0e",target:"_blank",rel:"noopener noreferrer"},k={href:"https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fjamiebuilds%2Fbabel-handbook%2Fblob%2Fmaster%2Ftranslations%2Fzh-Hans%2Fplugin-handbook.md",target:"_blank",rel:"noopener noreferrer"},d={href:"https://links.jianshu.com/go?to=https%3A%2F%2Fblog.arvinh.info%2F2018%2F08%2F25%2Fvisit-ast-with-babel-plugin%2F",target:"_blank",rel:"noopener noreferrer"},b={href:"https://links.jianshu.com/go?to=http%3A%2F%2Fwww.imooc.com%2Farticle%2F290884",target:"_blank",rel:"noopener noreferrer"},m={href:"https://links.jianshu.com/go?to=https%3A%2F%2Fpro.ant.design%2Findex-cn",target:"_blank",rel:"noopener noreferrer"},v={href:"https://links.jianshu.com/go?to=https%3A%2F%2Fumijs.org%2F",target:"_blank",rel:"noopener noreferrer"},g={href:"https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fbabel%2Fbabel%2Fblob%2Fmaster%2Fpackages%2Fbabel-parser%2Fast%2Fspec.md",target:"_blank",rel:"noopener noreferrer"},h={href:"https://links.jianshu.com/go?to=https%3A%2F%2Fbabeljs.io%2Fdocs%2Fen%2Fnext%2Fbabel-parser.html",target:"_blank",rel:"noopener noreferrer"},f={href:"https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fbabel%2Fbabylon",target:"_blank",rel:"noopener noreferrer"},A={href:"https://links.jianshu.com/go?to=https%3A%2F%2Fbabeljs.io%2Fdocs%2Fen%2Fnext%2Fbabel-traverse.html",target:"_blank",rel:"noopener noreferrer"},F={href:"https://links.jianshu.com/go?to=https%3A%2F%2Fbabeljs.io%2Fdocs%2Fen%2Fnext%2Fbabel-types.html",target:"_blank",rel:"noopener noreferrer"},T={href:"https://www.jianshu.com/p/b66593151f0f",target:"_blank",rel:"noopener noreferrer"},S={href:"https://links.jianshu.com/go?to=https%3A%2F%2Fbabeljs.io%2Fdocs%2Fen%2Fnext%2Fbabel-generator.html",target:"_blank",rel:"noopener noreferrer"},y={href:"https://links.jianshu.com/go?to=https%3A%2F%2Fastexplorer.net%2F",target:"_blank",rel:"noopener noreferrer"},w={href:"https://links.jianshu.com/go?to=https%3A%2F%2Fresources.jointjs.com%2Fdemos%2Frappid%2Fapps%2FAst%2Findex.html",target:"_blank",rel:"noopener noreferrer"},x={href:"https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fbenjamn%2Frecast",target:"_blank",rel:"noopener noreferrer"},D={href:"https://links.jianshu.com/go?to=https%3A%2F%2Fbabeljs.io%2Fdocs%2Fen%2Fnext%2Fbabel-template.html",target:"_blank",rel:"noopener noreferrer"},j={href:"https://88250.b3log.org/articles/2020/04/23/1587637426085.html",target:"_blank",rel:"noopener noreferrer"},L={href:"https://github.com/commonmark/commonmark-spec",target:"_blank",rel:"noopener noreferrer"},N={href:"https://github.com/88250/lute",target:"_blank",rel:"noopener noreferrer"},M={href:"https://github.com/Vanessa219/vditor",target:"_blank",rel:"noopener noreferrer"},B={href:"https://88250.b3log.org/articles/2020/04/23/1587637426085.html#sourcemap",target:"_blank",rel:"noopener noreferrer"},E={href:"https://spec.commonmark.org/0.29/#appendix-a-parsing-strategy",target:"_blank",rel:"noopener noreferrer"},C={href:"https://hacpai.com/article/1566893557720",target:"_blank",rel:"noopener noreferrer"},I={href:"https://hacpai.com/article/1567062979327",target:"_blank",rel:"noopener noreferrer"},q={href:"https://github.com/Vanessa219/vditor",target:"_blank",rel:"noopener noreferrer"},P={href:"https://hacpai.com/guide/markdown",target:"_blank",rel:"noopener noreferrer"},R={href:"https://github.com/88250/lute/blob/master/ast/node.go",target:"_blank",rel:"noopener noreferrer"};function V(O,n){const t=r("ExternalLinkIcon");return i(),l("div",null,[n[67]||(n[67]=p('<h1 id="ast-抽象语法树" tabindex="-1"><a class="header-anchor" href="#ast-抽象语法树"><span>AST 抽象语法树</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="ast-抽象语法树-1" tabindex="-1"><a class="header-anchor" href="#ast-抽象语法树-1"><span>AST 抽象语法树</span></a></h1><h2 id="ast-abstract-syntax-tree-抽象语法树" tabindex="-1"><a class="header-anchor" href="#ast-abstract-syntax-tree-抽象语法树"><span>AST (Abstract Syntax Tree，抽象语法树)</span></a></h2><p>参考：</p>',5)),s("ul",null,[s("li",null,[s("p",null,[s("a",c,[n[0]||(n[0]=a("【简书】AST 介绍")),e(t)]),n[1]||(n[1]=a(" 资源&文章推荐"))]),s("ul",null,[s("li",null,[s("p",null,[s("a",k,[n[2]||(n[2]=a("Babel 插件手册")),e(t)])])]),s("li",null,[s("p",null,[s("a",d,[n[3]||(n[3]=a("透過製作 Babel-plugin 初訪 AST")),e(t)])])]),s("li",null,[s("p",null,[s("a",b,[n[4]||(n[4]=a("AST 与前端工程化实战")),e(t)])])])])])]),n[68]||(n[68]=p(`<h3 id="什么是ast" tabindex="-1"><a class="header-anchor" href="#什么是ast"><span>什么是AST？</span></a></h3><p>AST (Abstract Syntax Tree，抽象语法树) ，是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构。</p><p>它由一堆节点（Node）组成，每个节点都表示源代码中的一种结构。不同结构用类型来区分，常见的类型有： Identifier(标识符)，BinaryExpression(二元表达式)，VariableDeclaration(变量定义)，FunctionDeclaration(函数定义)等。</p><p>AST是编译器看的。编译器会将源码转化成AST。如下源码:</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">addA</span><span class="token punctuation">(</span><span class="token parameter">d</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> d<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token function">addA</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> b<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>会换转化成这样的AST:</p><p>![image-20221108155858091](AST 抽象语法树.assets/image-20221108155858091.png)</p><h3 id="ast-的使用场景" tabindex="-1"><a class="header-anchor" href="#ast-的使用场景"><span>AST 的使用场景？</span></a></h3><p><strong>TypeScript、babel、webpack、vue-cli</strong> 得都是依赖 AST 进行开发的。</p><p>通过AST，可以将代码转化后，再输出。比如：</p>`,10)),s("ul",null,[n[10]||(n[10]=s("li",null,"代码压缩。删除没用的空格，未使用的语句，变量名替换等。",-1)),n[11]||(n[11]=s("li",null,"代码高亮。",-1)),n[12]||(n[12]=s("li",null,"将 ES6 代码转换成 ES5 代码。",-1)),n[13]||(n[13]=s("li",null,[a("给 CSS 中的某些属性加浏览器前缀"),s("code",null,"-webkit-"),a("。")],-1)),n[14]||(n[14]=s("li",null,"将 CSS 中的px转化成rem。",-1)),s("li",null,[n[7]||(n[7]=a("生成代码。最近用了")),s("a",m,[n[5]||(n[5]=a("ANT DESIGN PRO")),e(t)]),n[8]||(n[8]=a("。 ANT DESIGN PRO 中的 ")),s("a",v,[n[6]||(n[6]=a("umi")),e(t)]),n[9]||(n[9]=a(" 可以在生成页面的代码和路由时，修改路由配置的js。umi 这种方式，用户体验很好。因此，我准备用这种方式来改造我之前做的代码生成工具。修改路由配置需要通过AST来转换代码。"))])]),n[69]||(n[69]=s("h3",{id:"需要学习-ast-的哪些知识",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#需要学习-ast-的哪些知识"},[s("span",null,"需要学习 AST 的哪些知识？")])],-1)),n[70]||(n[70]=s("blockquote",null,[s("h5",{id:"了解ast常见节点的结构",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#了解ast常见节点的结构"},[s("span",null,"了解AST常见节点的结构")])])],-1)),s("p",null,[n[16]||(n[16]=a("了解AST常见节点的结构推荐通读下")),s("a",g,[n[15]||(n[15]=a("AST node 规范")),e(t)]),n[17]||(n[17]=a("。"))]),n[71]||(n[71]=s("blockquote",null,[s("h5",{id:"源码解析",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#源码解析"},[s("span",null,"源码解析")])])],-1)),n[72]||(n[72]=s("p",null,"将源码转化为AST。该步骤分为词法分析（Lexical Analysis）和 语法分析（Syntactic Analysis）。",-1)),s("p",null,[n[20]||(n[20]=a("解析 JavaScript 可以用")),s("a",h,[n[18]||(n[18]=a("@babel/parser")),e(t)]),n[21]||(n[21]=a("(以前叫 ")),s("a",f,[n[19]||(n[19]=a("Babylon")),e(t)]),n[22]||(n[22]=a(")。"))]),n[73]||(n[73]=s("blockquote",null,[s("h5",{id:"转换",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#转换"},[s("span",null,"转换")])])],-1)),n[74]||(n[74]=s("p",null,"在遍历AST时，对指定的AST节点做新增，修改或删除操作。",-1)),s("p",null,[n[24]||(n[24]=a("转换可以用")),s("a",A,[n[23]||(n[23]=a("@babel/traverse")),e(t)]),n[25]||(n[25]=a("。"))]),s("p",null,[n[28]||(n[28]=a("创建和验证节点可以用")),s("a",F,[n[26]||(n[26]=a("@babel/types")),e(t)]),n[29]||(n[29]=a("。创建AST节点代码示例见")),s("a",T,[n[27]||(n[27]=a("这里")),e(t)]),n[30]||(n[30]=a("。"))]),n[75]||(n[75]=s("blockquote",null,[s("h5",{id:"生成目标代码",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#生成目标代码"},[s("span",null,"生成目标代码")])])],-1)),n[76]||(n[76]=s("p",null,"将上一步转换过的AST，转化为目标代码，并生成源码映射（source maps）。",-1)),s("p",null,[n[32]||(n[32]=a("生成目标代码可以用")),s("a",S,[n[31]||(n[31]=a("@babel/generator")),e(t)])]),n[77]||(n[77]=s("h3",{id:"工具",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#工具"},[s("span",null,"工具")])],-1)),s("ul",null,[s("li",null,[s("a",y,[n[33]||(n[33]=a("AST 浏览器")),e(t)])]),s("li",null,[s("a",w,[n[34]||(n[34]=a("AST 可视化工具")),e(t)])]),s("li",null,[n[39]||(n[39]=a("npm 包 ")),s("ul",null,[s("li",null,[s("a",x,[n[35]||(n[35]=a("recast")),e(t)]),n[36]||(n[36]=a(" AST工具库。解析AST(parse)，遍历AST，修改AST，生成代码。官方文档太简单了。"))]),s("li",null,[s("a",D,[n[37]||(n[37]=a("@babel/template")),e(t)]),n[38]||(n[38]=a(" 它能让你编写字符串形式且带有占位符的代码来代替手动编码， 尤其是生成的大规模 AST的时候。 在计算机科学中，这种能力被称为准引用（quasiquotes）。"))])])])]),n[78]||(n[78]=s("h2",{id:"md解析原理-lute工具",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#md解析原理-lute工具"},[s("span",null,"Md解析原理（Lute工具）")])],-1)),s("p",null,[n[41]||(n[41]=a("参考：")),s("a",j,[n[40]||(n[40]=a("Markdown 解析原理详解和 Markdown AST 描述")),e(t)])]),n[79]||(n[79]=s("h3",{id:"这篇文章中涉及的开源项目",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#这篇文章中涉及的开源项目"},[s("span",null,"这篇文章中涉及的开源项目")])],-1)),s("ul",null,[s("li",null,[s("a",L,[n[42]||(n[42]=a("CommonMark Spec")),e(t)])]),s("li",null,[s("a",N,[n[43]||(n[43]=a("Lute")),e(t)]),n[44]||(n[44]=a(" 一款对中文语境优化的 Markdown 引擎，支持 Go 和 JavaScript"))]),s("li",null,[s("a",M,[n[45]||(n[45]=a("Vditor")),e(t)]),n[46]||(n[46]=a(" 一款浏览器端的 Markdown 编辑器，支持所见即所得、即时渲染（类似 Typora）和分屏预览模式"))])]),n[80]||(n[80]=p(`<h3 id="编译原理" tabindex="-1"><a class="header-anchor" href="#编译原理"><span>编译原理</span></a></h3><p>我们通过编译原理实现了 Lute ，大致步骤是 ① 预处理、② 词法分析、③ 语法分析、④ 代码生成 这几个步骤。</p><h3 id="解析" tabindex="-1"><a class="header-anchor" href="#解析"><span>解析</span></a></h3><p>Lute 的使用</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token comment">// Markdown 将 markdown 文本字节数组处理为相应的 html 字节数组。</span>
<span class="token comment">// name 参数仅用于标识文本，比如可传入 id 或者标题，也可以传入 &quot;&quot;。</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>lute <span class="token operator">*</span>Lute<span class="token punctuation">)</span> <span class="token function">Markdown</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">,</span> markdown <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>html <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	tree <span class="token operator">:=</span> parse<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> markdown<span class="token punctuation">,</span> lute<span class="token punctuation">.</span>Options<span class="token punctuation">)</span>
	renderer <span class="token operator">:=</span> render<span class="token punctuation">.</span><span class="token function">NewHtmlRenderer</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span>
	html <span class="token operator">=</span> renderer<span class="token punctuation">.</span><span class="token function">Render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">return</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解析过程用于从 Markdown 原文构造抽象语法树。</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token comment">// Parse 会将 markdown 原始文本字节数组解析为一颗语法树。</span>
<span class="token keyword">func</span> <span class="token function">Parse</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">,</span> markdown <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> options <span class="token operator">*</span>Options<span class="token punctuation">)</span> <span class="token punctuation">(</span>tree <span class="token operator">*</span>Tree<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	tree <span class="token operator">=</span> <span class="token operator">&amp;</span>Tree<span class="token punctuation">{</span>Name<span class="token punctuation">:</span> name<span class="token punctuation">,</span> Context<span class="token punctuation">:</span> <span class="token operator">&amp;</span>Context<span class="token punctuation">{</span>Option<span class="token punctuation">:</span> options<span class="token punctuation">}</span><span class="token punctuation">}</span>
	tree<span class="token punctuation">.</span>Context<span class="token punctuation">.</span>Tree <span class="token operator">=</span> tree
	tree<span class="token punctuation">.</span>lexer <span class="token operator">=</span> lex<span class="token punctuation">.</span><span class="token function">NewLexer</span><span class="token punctuation">(</span>markdown<span class="token punctuation">)</span>
	tree<span class="token punctuation">.</span>Root <span class="token operator">=</span> <span class="token operator">&amp;</span>ast<span class="token punctuation">.</span>Node<span class="token punctuation">{</span>Type<span class="token punctuation">:</span> ast<span class="token punctuation">.</span>NodeDocument<span class="token punctuation">}</span>
	tree<span class="token punctuation">.</span><span class="token function">parseBlocks</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	tree<span class="token punctuation">.</span><span class="token function">parseInlines</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	tree<span class="token punctuation">.</span>lexer <span class="token operator">=</span> <span class="token boolean">nil</span>
	<span class="token keyword">return</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码结构方面我们分为两部分：解析和渲染</p><ul><li>渲染过程将遍历语法树生成 HTML 代码，本文略过</li><li>解析过程下面我们将着重介绍，从预处理阶段开始</li></ul><h4 id="_1-预处理" tabindex="-1"><a class="header-anchor" href="#_1-预处理"><span>① 预处理</span></a></h4><p>预处理阶段主要是将输入的 Markdown 文本字节数组结尾添加换行符 <code>\\n</code>，以方便后续解析可以统一按行读取。</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token comment">// NewLexer 创建一个词法分析器。</span>
<span class="token keyword">func</span> <span class="token function">NewLexer</span><span class="token punctuation">(</span>input <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>ret <span class="token operator">*</span>Lexer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	ret <span class="token operator">=</span> <span class="token operator">&amp;</span>Lexer<span class="token punctuation">{</span><span class="token punctuation">}</span>
	ret<span class="token punctuation">.</span>input <span class="token operator">=</span> input
	ret<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token function">len</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token number">0</span> <span class="token operator">&lt;</span> ret<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> ItemNewline <span class="token operator">!=</span> ret<span class="token punctuation">.</span>input<span class="token punctuation">[</span>ret<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
		<span class="token comment">// 以 \\n 结尾预处理</span>
		ret<span class="token punctuation">.</span>input <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>input<span class="token punctuation">,</span> ItemNewline<span class="token punctuation">)</span>
		ret<span class="token punctuation">.</span>length<span class="token operator">++</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-词法分析" tabindex="-1"><a class="header-anchor" href="#_2-词法分析"><span>② 词法分析</span></a></h4><p>词法分析的目的是将 Markdown 文本转换为 token 数组。标准的编译原理中词法分析产生的 token 将带有如下这样一些属性：</p><ul><li>类型（token type），比如标识符、操作符、数字、字符等</li><li>词素（lexeme），原始的文本字节数组</li><li>位置（pos），该 token 的第一个字节相对于整个文本字节数组的下标</li></ul><p>Markdown 的词法分析进行了简化，仅返回词素作为 token，因为：</p>`,16)),s("ul",null,[n[49]||(n[49]=s("li",null,[a("Markdown 解析不需要类型信息，使用的标记符（比如 "),s("code",null,"#"),a("、"),s("code",null,"*"),a(" 等）本身就是 token 类型和词素")],-1)),s("li",null,[n[48]||(n[48]=a("大部分场景下的 Markdown 解析不需要实现")),s("a",B,[n[47]||(n[47]=a("源码映射")),e(t)])]),n[50]||(n[50]=s("li",null,"提升性能",-1))]),n[81]||(n[81]=p(`<p>另外，编译原理教科书中是将词法分析和语法分析完全分开介绍的，即词法分析器产生 token 数组后作为参数传入语法分析器，而实际工程上因为性能考虑，是在语法分析中调用词法分析来按需获得 token 数组，这样可以减少内存分配。</p><p>Markdown 词法分析的具体实现是按行进行处理的，每次处理后词法分析器会记录当前读取位置，以便下次继续按行处理。</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token comment">// Lexer 描述了词法分析器结构。</span>
<span class="token keyword">type</span> Lexer <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	input  <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span> <span class="token comment">// 输入的文本字节数组</span>
	length <span class="token builtin">int</span>    <span class="token comment">// 输入的文本字节数组的长度</span>
	offset <span class="token builtin">int</span>    <span class="token comment">// 当前读取字节位置</span>
	width  <span class="token builtin">int</span>    <span class="token comment">// 最新一个字符的长度（字节数）</span>
<span class="token punctuation">}</span>

<span class="token comment">// NextLine 返回下一行。</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>l <span class="token operator">*</span>Lexer<span class="token punctuation">)</span> <span class="token function">NextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>ret <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> l<span class="token punctuation">.</span>offset <span class="token operator">&gt;=</span> l<span class="token punctuation">.</span>length <span class="token punctuation">{</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">var</span> b<span class="token punctuation">,</span> nb <span class="token builtin">byte</span>
	i <span class="token operator">:=</span> l<span class="token punctuation">.</span>offset
	<span class="token keyword">for</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">+=</span> l<span class="token punctuation">.</span>width <span class="token punctuation">{</span>
		b <span class="token operator">=</span> l<span class="token punctuation">.</span>input<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
		<span class="token keyword">if</span> ItemNewline <span class="token operator">==</span> b <span class="token punctuation">{</span>
			i<span class="token operator">++</span>
			<span class="token keyword">break</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> ItemCarriageReturn <span class="token operator">==</span> b <span class="token punctuation">{</span>
			<span class="token comment">// 处理 \\r</span>
			<span class="token keyword">if</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">{</span>
				nb <span class="token operator">=</span> l<span class="token punctuation">.</span>input<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>
				<span class="token keyword">if</span> ItemNewline <span class="token operator">==</span> nb <span class="token punctuation">{</span>
					l<span class="token punctuation">.</span>input <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>l<span class="token punctuation">.</span>input<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> l<span class="token punctuation">.</span>input<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">...</span><span class="token punctuation">)</span> <span class="token comment">// 移除 \\r，依靠下一个的 \\n 切行</span>
					l<span class="token punctuation">.</span>length<span class="token operator">--</span>                                      <span class="token comment">// 重新计算总长</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			i<span class="token operator">++</span>
			<span class="token keyword">break</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token char">&#39;\\u0000&#39;</span> <span class="token operator">==</span> b <span class="token punctuation">{</span>
			<span class="token comment">// 将 \\u0000 替换为 \\uFFFD</span>
			l<span class="token punctuation">.</span>input <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>l<span class="token punctuation">.</span>input<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
			<span class="token function">copy</span><span class="token punctuation">(</span>l<span class="token punctuation">.</span>input<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> l<span class="token punctuation">.</span>input<span class="token punctuation">[</span>i<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token comment">// \\uFFFD 的 UTF-8 编码为 \\xEF\\xBF\\xBD 共三个字节</span>
			l<span class="token punctuation">.</span>input<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> l<span class="token punctuation">.</span>input<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> l<span class="token punctuation">.</span>input<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">&#39;\\xEF&#39;</span><span class="token punctuation">,</span> <span class="token char">&#39;\\xBF&#39;</span><span class="token punctuation">,</span> <span class="token char">&#39;\\xBD&#39;</span>
			l<span class="token punctuation">.</span>length <span class="token operator">+=</span> <span class="token number">2</span> <span class="token comment">// 重新计算总长</span>
			l<span class="token punctuation">.</span>width <span class="token operator">=</span> <span class="token number">3</span>
			<span class="token keyword">continue</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">if</span> utf8<span class="token punctuation">.</span>RuneSelf <span class="token operator">&lt;=</span> b <span class="token punctuation">{</span> <span class="token comment">// 说明占用多个字节</span>
			<span class="token boolean">_</span><span class="token punctuation">,</span> l<span class="token punctuation">.</span>width <span class="token operator">=</span> utf8<span class="token punctuation">.</span><span class="token function">DecodeRune</span><span class="token punctuation">(</span>l<span class="token punctuation">.</span>input<span class="token punctuation">[</span>i<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
			l<span class="token punctuation">.</span>width <span class="token operator">=</span> <span class="token number">1</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	ret <span class="token operator">=</span> l<span class="token punctuation">.</span>input<span class="token punctuation">[</span>l<span class="token punctuation">.</span>offset<span class="token punctuation">:</span>i<span class="token punctuation">]</span>
	l<span class="token punctuation">.</span>offset <span class="token operator">=</span> i
	<span class="token keyword">return</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_3-语法分析" tabindex="-1"><a class="header-anchor" href="#_3-语法分析"><span>③ 语法分析</span></a></h4>`,4)),s("p",null,[n[52]||(n[52]=a("CommonMark 规范中介绍了一种")),s("a",E,[n[51]||(n[51]=a("解析算法")),e(t)]),n[53]||(n[53]=a("，分为两个阶段："))]),n[82]||(n[82]=s("ol",null,[s("li",null,"构造所有块级节点，包括标题、块引用、代码块、分隔线、列表、段落等，还需要构造好链接引用定义映射表"),s("li",null,"遍历每个块级节点，构造行级节点，包括文本、链接、强调、加粗等，链接的处理可能会需要查找步骤 1 中构造好的链接引用定义映射表")],-1)),s("p",null,[n[56]||(n[56]=a("关于 CommonMark 规范的一些实现细节可参考我之前的笔记（")),s("a",C,[n[54]||(n[54]=a("CommonMark 规范要点解读")),e(t)]),n[57]||(n[57]=a("、")),s("a",I,[n[55]||(n[55]=a("Lute 实现后记")),e(t)]),n[58]||(n[58]=a("），这里就不展开了，如果感兴趣欢迎跟帖讨论。"))]),n[83]||(n[83]=p('<h4 id="_4-代码生成" tabindex="-1"><a class="header-anchor" href="#_4-代码生成"><span>④ 代码生成</span></a></h4><h3 id="抽象语法树" tabindex="-1"><a class="header-anchor" href="#抽象语法树"><span>抽象语法树</span></a></h3><p>Markdown 抽象语法树是由节点构成的树，从包含关系来说节点可以分为四类：</p><ol><li>根节点，可以包含所有其他任意节点</li><li>块级容器节点，可以包含非根节点的其他任意节点，比如列表项包含段落</li><li>块级节点，可以包含行级节点，比如段落包含强调</li><li>行级节点，可以包含行级节点，比如强调包含文本</li></ol><p>我们在实现 Lute 时做了“最细粒度”的节点结构，比如对于超链接 <code>[foo](bar)</code> 形成的节点结构包含了左方括号 <code>[</code>、链接文本 <code>foo</code>、右方括号 <code>]</code>、左圆括号 <code>(</code>、链接地址 <code>bar</code> 和右圆括号 <code>)</code>。这样做的优点是方便处理细致的节点操作，缺点是性能稍差，因为需要构造和遍历更多的节点。</p>',5)),s("p",null,[n[61]||(n[61]=a("如果你想看到较粗粒度的语法树，可以通过 ")),s("a",q,[n[59]||(n[59]=a("Vditor Markdown 编辑器")),e(t)]),n[62]||(n[62]=a("的开发者工具来查看，请")),s("a",P,[n[60]||(n[60]=a("到此")),e(t)]),n[63]||(n[63]=a("进行测试（点击编辑器工具栏上的“开发者工具”按钮就可以看到根据输入进行实时渲染的语法树了）。"))]),s("p",null,[n[65]||(n[65]=a("下面我们按 Lute 源码中的")),s("a",R,[n[64]||(n[64]=a("节点")),e(t)]),n[66]||(n[66]=a("类型常量顺序来逐一描述。"))])])}const H=o(u,[["render",V],["__file","AST 抽象语法树.html.vue"]]),G=JSON.parse('{"path":"/01.%20DesignAndDevelop/Develop/02.%20Theory/Type/Doc/AST%20%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91.html","title":"AST 抽象语法树","lang":"zh-CN","frontmatter":{"description":"AST 抽象语法树 目录 AST 抽象语法树 AST (Abstract Syntax Tree，抽象语法树) 参考： 【简书】AST 介绍 资源&文章推荐 Babel 插件手册 透過製作 Babel-plugin 初訪 AST AST 与前端工程化实战 什么是AST？ AST (Abstract Syntax Tree，抽象语法树) ，是源代码语法结...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/02.%20Theory/Type/Doc/AST%20%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91.html"}],["meta",{"property":"og:site_name","content":"MdNote_Public"}],["meta",{"property":"og:title","content":"AST 抽象语法树"}],["meta",{"property":"og:description","content":"AST 抽象语法树 目录 AST 抽象语法树 AST (Abstract Syntax Tree，抽象语法树) 参考： 【简书】AST 介绍 资源&文章推荐 Babel 插件手册 透過製作 Babel-plugin 初訪 AST AST 与前端工程化实战 什么是AST？ AST (Abstract Syntax Tree，抽象语法树) ，是源代码语法结..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-01-26T15:46:06.000Z"}],["meta",{"property":"article:author","content":"LincDocs"}],["meta",{"property":"article:modified_time","content":"2025-01-26T15:46:06.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"AST 抽象语法树\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-01-26T15:46:06.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/MdNote_Public/\\"}]}"]]},"headers":[{"level":1,"title":"AST 抽象语法树","slug":"ast-抽象语法树","link":"#ast-抽象语法树","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"AST 抽象语法树","slug":"ast-抽象语法树-1","link":"#ast-抽象语法树-1","children":[{"level":2,"title":"AST (Abstract Syntax Tree，抽象语法树)","slug":"ast-abstract-syntax-tree-抽象语法树","link":"#ast-abstract-syntax-tree-抽象语法树","children":[{"level":3,"title":"什么是AST？","slug":"什么是ast","link":"#什么是ast","children":[]},{"level":3,"title":"AST 的使用场景？","slug":"ast-的使用场景","link":"#ast-的使用场景","children":[]},{"level":3,"title":"需要学习 AST 的哪些知识？","slug":"需要学习-ast-的哪些知识","link":"#需要学习-ast-的哪些知识","children":[]},{"level":3,"title":"工具","slug":"工具","link":"#工具","children":[]}]},{"level":2,"title":"Md解析原理（Lute工具）","slug":"md解析原理-lute工具","link":"#md解析原理-lute工具","children":[{"level":3,"title":"这篇文章中涉及的开源项目","slug":"这篇文章中涉及的开源项目","link":"#这篇文章中涉及的开源项目","children":[]},{"level":3,"title":"编译原理","slug":"编译原理","link":"#编译原理","children":[]},{"level":3,"title":"解析","slug":"解析","link":"#解析","children":[{"level":4,"title":"① 预处理","slug":"_1-预处理","link":"#_1-预处理","children":[]},{"level":4,"title":"② 词法分析","slug":"_2-词法分析","link":"#_2-词法分析","children":[]},{"level":4,"title":"③ 语法分析","slug":"_3-语法分析","link":"#_3-语法分析","children":[]},{"level":4,"title":"④ 代码生成","slug":"_4-代码生成","link":"#_4-代码生成","children":[]}]},{"level":3,"title":"抽象语法树","slug":"抽象语法树","link":"#抽象语法树","children":[]}]}]}],"git":{"createdTime":1737906366000,"updatedTime":1737906366000,"contributors":[{"name":"Linc","email":"762699299@qq.com","commits":1}]},"readingTime":{"minutes":7.92,"words":2377},"filePathRelative":"01. DesignAndDevelop/Develop/02. Theory/Type/Doc/AST 抽象语法树.md","localizedDate":"2025年1月26日","excerpt":"\\n<h1>目录</h1>\\n<h1>AST 抽象语法树</h1>\\n<h2>AST (Abstract Syntax Tree，抽象语法树)</h2>\\n<p>参考：</p>\\n<ul>\\n<li>\\n<p><a href=\\"https://www.jianshu.com/p/6fa90ee14d0e\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">【简书】AST 介绍</a>\\n资源&amp;文章推荐</p>\\n<ul>\\n<li>\\n<p><a href=\\"https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fjamiebuilds%2Fbabel-handbook%2Fblob%2Fmaster%2Ftranslations%2Fzh-Hans%2Fplugin-handbook.md\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">Babel 插件手册</a></p>\\n</li>\\n<li>\\n<p><a href=\\"https://links.jianshu.com/go?to=https%3A%2F%2Fblog.arvinh.info%2F2018%2F08%2F25%2Fvisit-ast-with-babel-plugin%2F\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">透過製作 Babel-plugin 初訪 AST</a></p>\\n</li>\\n<li>\\n<p><a href=\\"https://links.jianshu.com/go?to=http%3A%2F%2Fwww.imooc.com%2Farticle%2F290884\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">AST 与前端工程化实战</a></p>\\n</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"01. DesignAndDevelop/Develop/02. Theory/Type/Doc/AST 抽象语法树.md","value":{"title":"AST 抽象语法树","path":"01. DesignAndDevelop/Develop/02. Theory/Type/Doc/AST 抽象语法树.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{H as comp,G as data};
