import{_ as e,c as d,f as n,o}from"./app-BpMPCgQm.js";const l={};function i(c,t){return o(),d("div",null,t[0]||(t[0]=[n('<h1 id="qt" tabindex="-1"><a class="header-anchor" href="#qt"><span>Qt</span></a></h1><h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h1><h1 id="正则表达式" tabindex="-1"><a class="header-anchor" href="#正则表达式"><span>正则表达式</span></a></h1><h2 id="qregexp" tabindex="-1"><a class="header-anchor" href="#qregexp"><span>QRegExp</span></a></h2><p>Qt的<code>QRegExp</code>类是正则表达式的表示类，基于Perl的正则表达式语言，完全支持Unicode</p><ul><li><p>组成：正则表达式由三部分组成</p><ul><li>表达式（<em>expressions</em>）</li><li>量词（<em>quantifiers</em>）</li><li>断言（<em>assertions</em>）</li></ul></li><li><p>表达式</p><ul><li>最简单的表达式是一个字符</li><li>字符集举例 <ul><li><code>[AEIOU]</code>表示匹配所有的大写元音字母</li><li><code>[^AEIOU]</code>表示匹配所有非元音字母，即辅音字母</li><li><code>[a-z]</code>表示匹配所有的小写英文字母</li></ul></li></ul></li><li><p>量词</p><ul><li><p>说明表达式出现的次数</p></li><li><p>举例</p><ul><li><code>x[1,2]</code>表示x为1或2个</li><li><code>[A-Za-z_]+[A-Za-z_0-9]*</code>匹配计算机语言的标识符</li></ul></li><li><p>正则表达式的量词（<code>E</code>是表达式的意思）（<strong>这里的方括号好像要变成花括号才对，不知道为什么书上的是方括号</strong>）</p><table><thead><tr><th>量词</th><th>含义</th></tr></thead><tbody><tr><td><code>E?</code></td><td>匹配0次或1次，等同<code>E[0,1]</code></td></tr><tr><td><code>E+</code></td><td>匹配1次或多次，等同<code>E[1,]</code></td></tr><tr><td><code>E*</code></td><td>匹配0次或多次，等同<code>E[0,]</code></td></tr><tr><td><code>E[n]</code></td><td>匹配n次</td></tr><tr><td><code>E[n,]</code></td><td>匹配至少n次</td></tr><tr><td><code>E[,m]</code></td><td>匹配最多m次，等同<code>E[0,m]</code></td></tr><tr><td><code>E[n,m]</code></td><td>匹配n次到m次</td></tr></tbody></table></li></ul></li><li><p>断言</p><ul><li><p>举例</p><ul><li><code>using(?=E\\s+namespace)</code>，匹配后面接 namespace 的 using</li><li><code>using(?!E\\s+namespace)</code>，匹配后面不接 namespace 的 using</li><li><code>using\\s+namespace</code>，匹配 using namespace</li></ul></li><li><p>正则表达式的断言</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td><code>^</code></td><td>字符串开头进行匹配</td></tr><tr><td><code>$</code></td><td>字符串结尾进行匹配</td></tr><tr><td><code>\\b</code></td><td>单词边界</td></tr><tr><td><code>\\B</code></td><td>非单词边界</td></tr><tr><td><code>(?=E)</code></td><td>表达式后紧随E才匹配</td></tr><tr><td><code>(?!E)</code></td><td>表达式后不跟随E才匹配</td></tr></tbody></table></li></ul></li></ul>',6)]))}const a=e(l,[["render",i],["__file","02. 正则表达式.html.vue"]]),p=JSON.parse('{"path":"/01.%20DesignAndDevelop/Develop/04.%20Project/Platform/Multi/QT%EF%BC%88Cpp%EF%BC%89/03.%20Qt%E5%85%B6%E4%BB%96%E7%B1%BB%EF%BC%88%E6%8C%89%E5%8A%9F%E8%83%BD%EF%BC%89/01.%20%E6%96%87%E6%9C%AC%E7%9B%B8%E5%85%B3/02.%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html","title":"Qt","lang":"zh-CN","frontmatter":{"description":"Qt 目录 正则表达式 QRegExp Qt的QRegExp类是正则表达式的表示类，基于Perl的正则表达式语言，完全支持Unicode 组成：正则表达式由三部分组成 表达式（expressions） 量词（quantifiers） 断言（assertions） 表达式 最简单的表达式是一个字符 字符集举例 [AEIOU]表示匹配所有的大写元音字母 [...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/MdNote_Public/01.%20DesignAndDevelop/Develop/04.%20Project/Platform/Multi/QT%EF%BC%88Cpp%EF%BC%89/03.%20Qt%E5%85%B6%E4%BB%96%E7%B1%BB%EF%BC%88%E6%8C%89%E5%8A%9F%E8%83%BD%EF%BC%89/01.%20%E6%96%87%E6%9C%AC%E7%9B%B8%E5%85%B3/02.%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html"}],["meta",{"property":"og:site_name","content":"MdNote_Public"}],["meta",{"property":"og:title","content":"Qt"}],["meta",{"property":"og:description","content":"Qt 目录 正则表达式 QRegExp Qt的QRegExp类是正则表达式的表示类，基于Perl的正则表达式语言，完全支持Unicode 组成：正则表达式由三部分组成 表达式（expressions） 量词（quantifiers） 断言（assertions） 表达式 最简单的表达式是一个字符 字符集举例 [AEIOU]表示匹配所有的大写元音字母 [..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-05T16:08:48.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-05T16:08:48.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Qt\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-05T16:08:48.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/MdNote_Public/\\"}]}"]]},"headers":[{"level":1,"title":"Qt","slug":"qt","link":"#qt","children":[]},{"level":1,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":1,"title":"正则表达式","slug":"正则表达式","link":"#正则表达式","children":[{"level":2,"title":"QRegExp","slug":"qregexp","link":"#qregexp","children":[]}]}],"git":{"createdTime":1738771728000,"updatedTime":1738771728000,"contributors":[{"name":"Linc","username":"Linc","email":"762699299@qq.com","commits":1,"url":"https://github.com/Linc"}]},"readingTime":{"minutes":1.31,"words":394},"filePathRelative":"01. DesignAndDevelop/Develop/04. Project/Platform/Multi/QT（Cpp）/03. Qt其他类（按功能）/01. 文本相关/02. 正则表达式.md","localizedDate":"2025年2月5日","excerpt":"\\n<h1>目录</h1>\\n<h1>正则表达式</h1>\\n<h2>QRegExp</h2>\\n<p>Qt的<code>QRegExp</code>类是正则表达式的表示类，基于Perl的正则表达式语言，完全支持Unicode</p>\\n<ul>\\n<li>\\n<p>组成：正则表达式由三部分组成</p>\\n<ul>\\n<li>表达式（<em>expressions</em>）</li>\\n<li>量词（<em>quantifiers</em>）</li>\\n<li>断言（<em>assertions</em>）</li>\\n</ul>\\n</li>\\n<li>\\n<p>表达式</p>\\n<ul>\\n<li>最简单的表达式是一个字符</li>\\n<li>字符集举例\\n<ul>\\n<li><code>[AEIOU]</code>表示匹配所有的大写元音字母</li>\\n<li><code>[^AEIOU]</code>表示匹配所有非元音字母，即辅音字母</li>\\n<li><code>[a-z]</code>表示匹配所有的小写英文字母</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>量词</p>\\n<ul>\\n<li>\\n<p>说明表达式出现的次数</p>\\n</li>\\n<li>\\n<p>举例</p>\\n<ul>\\n<li><code>x[1,2]</code>表示x为1或2个</li>\\n<li><code>[A-Za-z_]+[A-Za-z_0-9]*</code>匹配计算机语言的标识符</li>\\n</ul>\\n</li>\\n<li>\\n<p>正则表达式的量词（<code>E</code>是表达式的意思）（<strong>这里的方括号好像要变成花括号才对，不知道为什么书上的是方括号</strong>）</p>\\n<table>\\n<thead>\\n<tr>\\n<th>量词</th>\\n<th>含义</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>E?</code></td>\\n<td>匹配0次或1次，等同<code>E[0,1]</code></td>\\n</tr>\\n<tr>\\n<td><code>E+</code></td>\\n<td>匹配1次或多次，等同<code>E[1,]</code></td>\\n</tr>\\n<tr>\\n<td><code>E*</code></td>\\n<td>匹配0次或多次，等同<code>E[0,]</code></td>\\n</tr>\\n<tr>\\n<td><code>E[n]</code></td>\\n<td>匹配n次</td>\\n</tr>\\n<tr>\\n<td><code>E[n,]</code></td>\\n<td>匹配至少n次</td>\\n</tr>\\n<tr>\\n<td><code>E[,m]</code></td>\\n<td>匹配最多m次，等同<code>E[0,m]</code></td>\\n</tr>\\n<tr>\\n<td><code>E[n,m]</code></td>\\n<td>匹配n次到m次</td>\\n</tr>\\n</tbody>\\n</table>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>断言</p>\\n<ul>\\n<li>\\n<p>举例</p>\\n<ul>\\n<li><code>using(?=E\\\\s+namespace)</code>，匹配后面接 namespace 的 using</li>\\n<li><code>using(?!E\\\\s+namespace)</code>，匹配后面不接 namespace 的 using</li>\\n<li><code>using\\\\s+namespace</code>，匹配 using namespace</li>\\n</ul>\\n</li>\\n<li>\\n<p>正则表达式的断言</p>\\n<table>\\n<thead>\\n<tr>\\n<th>符号</th>\\n<th>含义</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>^</code></td>\\n<td>字符串开头进行匹配</td>\\n</tr>\\n<tr>\\n<td><code>$</code></td>\\n<td>字符串结尾进行匹配</td>\\n</tr>\\n<tr>\\n<td><code>\\\\b</code></td>\\n<td>单词边界</td>\\n</tr>\\n<tr>\\n<td><code>\\\\B</code></td>\\n<td>非单词边界</td>\\n</tr>\\n<tr>\\n<td><code>(?=E)</code></td>\\n<td>表达式后紧随E才匹配</td>\\n</tr>\\n<tr>\\n<td><code>(?!E)</code></td>\\n<td>表达式后不跟随E才匹配</td>\\n</tr>\\n</tbody>\\n</table>\\n</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"01. DesignAndDevelop/Develop/04. Project/Platform/Multi/QT（Cpp）/03. Qt其他类（按功能）/01. 文本相关/02. 正则表达式.md","value":{"title":"02. 正则表达式","path":"01. DesignAndDevelop/Develop/04. Project/Platform/Multi/QT（Cpp）/03. Qt其他类（按功能）/01. 文本相关/02. 正则表达式.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{a as comp,p as data};
